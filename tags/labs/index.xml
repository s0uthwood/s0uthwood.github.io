<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Labs on s0uthwood&#39;s Blog</title>
    <link>/tags/labs/</link>
    <description>Recent content in Labs on s0uthwood&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Apr 2023 00:04:31 +0800</lastBuildDate><atom:link href="/tags/labs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>pwn.college babyheap writeups</title>
      <link>/post/pwn-college-babyheap/</link>
      <pubDate>Thu, 13 Apr 2023 00:04:31 +0800</pubDate>
      
      <guid>/post/pwn-college-babyheap/</guid>
      <description>主要的考点是 tcache
level 1.0 ###### Welcome to ./babyheap_level1.0!###This challenge allows you to perform various heap operations, some of which may involve the flag. Through this series ofchallenges, you will become familiar with the concept of heap exploitation.This challenge can manage up to 1 unique allocations.[*] Function (malloc/free/puts/read_flag/quit): mallocSize: 550[*] allocations[0] = malloc(550)[*] allocations[0] = 0x55706c8782c0[*] Function (malloc/free/puts/read_flag/quit): free[*] free(allocations[0])+====================+========================+==============+============================+============================+| TCACHE BIN #33 | SIZE: 537 - 552 | COUNT: 1 | HEAD: 0x55706c8782c0 | KEY: 0x55706c878010 |+====================+========================+==============+============================+============================+| ADDRESS | PREV_SIZE (-0x10) | SIZE (-0x08) | next (+0x00) | key (+0x08) |+---------------------+---------------------+------------------------------+---------------------+---------------------+| 0x55706c8782c0 | 0 | 0x231 (P) | (nil) | 0x55706c878010 |+----------------------------------------------------------------------------------------------------------------------+[*] Function (malloc/free/puts/read_flag/quit): read_flag[*] flag_buffer = malloc(549)[*] flag_buffer = 0x55706c8782c0[*] read the flag!</description>
    </item>
    
    <item>
      <title>pwn.college embryosuid writeups</title>
      <link>/post/pwn-college-babysuid/</link>
      <pubDate>Tue, 04 Apr 2023 00:26:43 +0800</pubDate>
      
      <guid>/post/pwn-college-babysuid/</guid>
      <description>level 1 - level 49
Ref: GTFOBins
level1 cat $ cat /flag level2 more $ more /flag level3 less $ less /flag level4 tail $ tail /flag level5 head $ head /flag level6 sort $ sort /flag level7 vim $ vim /flag level8 emacs $ emacs /flag level9 nano $ nano /flag level10 rev $ rev /flag | rev level11 od $ od -c /flag level12 hd $ hd /flag level13 xxd $ xxd /flag level14 base32 $ base32 /flag | base32 -d level15 base64 $ base64 /flag | base64 -d level16 split $ split /flag $ cat xaa level17 gzip $ gzip -k /flag $ gzip -cd /flag.</description>
    </item>
    
    <item>
      <title>pwn.college embryoasm writeups</title>
      <link>/post/pwn-college-embryoasm/</link>
      <pubDate>Tue, 04 Apr 2023 00:20:12 +0800</pubDate>
      
      <guid>/post/pwn-college-embryoasm/</guid>
      <description>level 6 - level 23
level 6 from pwn import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;) p = process(&amp;#39;./embryoasm_level6&amp;#39;) p.recvuntil(b&amp;#39;bytes): \n&amp;#39;) p.send(asm(&amp;#39;movb al, dil\nmovw bx, si&amp;#39;)) p.interactive() level 7 from pwn import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;) p = process(&amp;#39;./embryoasm_level7&amp;#39;) p.recvuntil(b&amp;#39;bytes): \n&amp;#39;) p.send(asm(&amp;#39;shr rdi, 24\nmovb al, dil&amp;#39;)) p.interactive() level 8 from pwn import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;) p = process(&amp;#39;./embryoasm_level8&amp;#39;) p.recvuntil(b&amp;#39;bytes): \n&amp;#39;) p.send(asm(&amp;#39;and rdi, rsi\nxor rax, rax\nor rax, rdi&amp;#39;)) p.interactive() level 9 from pwn import * context(os=&amp;#39;linux&amp;#39;, arch=&amp;#39;amd64&amp;#39;) p = process(&amp;#39;.</description>
    </item>
    
    <item>
      <title>pwn.college embryoio writeups</title>
      <link>/post/pwn-college-embryoio/</link>
      <pubDate>Tue, 04 Apr 2023 00:06:59 +0800</pubDate>
      
      <guid>/post/pwn-college-embryoio/</guid>
      <description>已完成：level 7 - level 59
level7 launch this program with 0 environment variables env -i command level8 non-interactive shell hacker@embryoio_level8:~$ bash tmp.sh hB [INFO] This challenge will now perform a bunch of checks. [INFO] If you pass these checks, you will receive the flag. [TEST] Performing checks on the parent process of this process. [TEST] Checking to make sure the process is a non-interactive shell script. [GOOD] You have passed the checks on the parent process!</description>
    </item>
    
    <item>
      <title>CS110L week1 writeup</title>
      <link>/post/cs110l-week1-writeup/</link>
      <pubDate>Tue, 28 Feb 2023 01:55:25 +0800</pubDate>
      
      <guid>/post/cs110l-week1-writeup/</guid>
      <description>Part 1: Getting oriented Rust 源码文件基本结构
|- src| |- main.rs|- Cargo.toml 其中 Cargo.toml 文件内容
[package]name = &amp;#34;hello-world&amp;#34;version = &amp;#34;0.1.0&amp;#34;authors = [&amp;#34;Ryan Eberhardt &amp;lt;reberhardt7@gmail.com&amp;gt;&amp;#34;]edition = &amp;#34;2018&amp;#34;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] main.rs 文件内容
fn main() { println!(&amp;#34;Hello, world!&amp;#34;); } 编译命令
$ cargo build 生成二进制文件为 target/debug/hello-world，文件名称由 toml 文件中的 name 设置
运行命令
$ cargo run Part 2: Rust warmup 语法 Numeric types</description>
    </item>
    
    <item>
      <title>CSAPP Labs</title>
      <link>/post/csapp-labs/</link>
      <pubDate>Wed, 12 Oct 2022 00:19:32 +0800</pubDate>
      
      <guid>/post/csapp-labs/</guid>
      <description>Lab1 Data-lab bitXor 用 ~ 和 &amp;amp; 进行异或运算，简单离散数学
/* * bitXor - x^y using only ~ and &amp;amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp;amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(~x &amp;amp; y) &amp;amp; ~(x &amp;amp; ~y)); } tmin 要求返回补码中最小的整数
众所周知补码形式下最小数为0x80000000，由于使用的常数不能超过 0xff，所以需要使用左移运算生成
/* * tmin - return minimum two&amp;#39;s complement integer * Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return (1 &amp;lt;&amp;lt; 31); } isTmax 判断 x 是否为补码格式下的最大数字</description>
    </item>
    
    <item>
      <title>angr ctf writeup</title>
      <link>/post/angr-ctf-writeup/</link>
      <pubDate>Mon, 27 Sep 2021 21:03:03 +0800</pubDate>
      
      <guid>/post/angr-ctf-writeup/</guid>
      <description>&lt;p&gt;开始学angr&lt;/p&gt;
&lt;p&gt;&lt;del&gt;就是在抄solution&lt;/del&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AITMC-challenge</title>
      <link>/post/aitmc-challenge/</link>
      <pubDate>Wed, 09 Dec 2020 23:27:25 +0000</pubDate>
      
      <guid>/post/aitmc-challenge/</guid>
      <description>Quiz from bzb 前言&amp;amp;题目 前段时间学习信安数基，助教学长就配套出了道Quiz，来给我们练手。
先上题目
import math from AITMCLab.Crypto.Util.number import long_to_bytes from AITMCLab.Crypto.Util.number import bytes_to_long from AITMCLab.Crypto.Util.number import getRandomNBitInteger from AITMCLab.Crypto.Util.number import getPrime from AITMCLab.Crypto.Util.number import isPrime from AITMCLab.Crypto.Util.number import inverse from secret import flag def nextPrime(n): n += 2 if n &amp;amp; 1 else 1 while not isPrime(n): n += 2 return n def init(S, K): j = 0 k = [] K = list(K) for i in range(len(K)): K[i] = ord(K[i]) for i in range(256): S.</description>
    </item>
    
  </channel>
</rss>
