<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on s0uthwood&#39;s Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on s0uthwood&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Oct 2022 02:41:13 +0800</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RTFSC-Linux0.11 Part1: From BIOS to main</title>
      <link>/post/rtfsc-linux-part1-from-bios-to-main/</link>
      <pubDate>Sun, 23 Oct 2022 02:41:13 +0800</pubDate>
      
      <guid>/post/rtfsc-linux-part1-from-bios-to-main/</guid>
      <description>跟着大佬的文章读一下 Linux 0.11 的源码
github.com/sunym1993/flash-linux0.11-talk
How Everything Begins (bootsects.s) 从 0x7C00 开始的操作系统启动 开机首先会执行主板上的 BIOS 程序，BIOS 将启动区的 512 字节（一个扇区）复制到内存中的 0x7C00 地址，随后跳转到这个地址继续执行
 启动区的识别：0 盘 0 道 1 扇区的 512 字节最后两个字节为 55 AA
 所以操作系统将从第一扇区启动，这在源码中对应了 boot/bootsect.s 文件
最开始的两行源码：
mov ax, 0x07C0 mov ds, ax 将 ds 寄存器赋值为 0x7C0
 为了能够在 16 位实模式下访问 20 位的地址，在读取段寄存器时需要 &amp;lt;&amp;lt; 4，所以 ds 是 0x7C0 时对应了地址 0x7C00，指向了此时代码段的地址，方便了后续对内存的访问
 给自己挪个地方 随后执行：
mov ax, 0x9000 mov es, ax mov cx, #256 sub si, si sub di, di rep movw 前面两行和最开始的两行类似，将 es 寄存器赋值为 0x9000，随后 cx = 0x100; si = 0; di = 0，最后循环执行 movw 指令</description>
    </item>
    
    <item>
      <title>CSAPP Labs</title>
      <link>/post/csapp-labs/</link>
      <pubDate>Wed, 12 Oct 2022 00:19:32 +0800</pubDate>
      
      <guid>/post/csapp-labs/</guid>
      <description>Lab1 Data-lab bitXor 用 ~ 和 &amp;amp; 进行异或运算，简单离散数学
/* * bitXor - x^y using only ~ and &amp;amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp;amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(~x &amp;amp; y) &amp;amp; ~(x &amp;amp; ~y)); } tmin 要求返回补码中最小的整数
众所周知补码形式下最小数为0x80000000，由于使用的常数不能超过 0xff，所以需要使用左移运算生成
/* * tmin - return minimum two&amp;#39;s complement integer * Legal ops: ! ~ &amp;amp; ^ | + &amp;lt;&amp;lt; &amp;gt;&amp;gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return (1 &amp;lt;&amp;lt; 31); } isTmax 判断 x 是否为补码格式下的最大数字</description>
    </item>
    
    <item>
      <title>qwb 2022 rev writeups</title>
      <link>/post/qwb2022-rev-writeups/</link>
      <pubDate>Tue, 02 Aug 2022 23:23:23 +0800</pubDate>
      
      <guid>/post/qwb2022-rev-writeups/</guid>
      <description>find_basic  没保存过程数据，以后找时间再补吧
 用 IDA 查看，能够发现反编译结果很奇怪，看看反汇编就能够发现存在很多 pusha 和 call 之类的指令，不如对着汇编动调
动调后因为不好找核心逻辑的位置，所以在输入处下个硬件断点，发现取出了输入的第一位内容，然后进行乘法和累加，类似下面这段代码：
ADD EAX,0x11MOVZX EAX,byte ptr [EAX]MOVZX EAX,ALIMUL EAX,EAX,-0x35cf6主逻辑在0x750a9的位置，继续跟踪一下逻辑，整体相当于n个虚拟机，结构大概如下：
father_func@0x750a9:MOV CL, 0x??CALL son_funcson_func:CMP CL, 0x??JMP ???CMP CL, 0x??JMP ???每个子函数的开头和结尾都有一些类似话指令的逻辑，但动调发现好像不影响程序的逻辑，所以就忽略了
跟踪了几个验证用的逻辑后，发现主要是乘法和累加，说明应该是一个矩阵运算，考虑到工作量很大，那就需要想办法进行自动提取了
使用了 idapython 进行自动调试，并记录过程中运行的指令：
from binascii import hexlify ea = get_reg_value(&amp;#39;eip&amp;#39;) end = ea + 0x1806 main_func = get_func_name(ea) fp = open(&amp;#39;all_asm.txt&amp;#39;,&amp;#39;w&amp;#39;) while True: ea = get_reg_value(&amp;#39;eip&amp;#39;) next_ea = next_head(ea) fp.</description>
    </item>
    
    <item>
      <title>Google CTF 2022 MIXED Writeup</title>
      <link>/post/google-ctf-2022-mixed-writeup/</link>
      <pubDate>Mon, 04 Jul 2022 16:01:21 +0800</pubDate>
      
      <guid>/post/google-ctf-2022-mixed-writeup/</guid>
      <description>This challenge gives a .pyc file and a Python 3.11 alpha7 based patch file.
Patch This patch file mainly patches the opcode.py file. After the patch, opcode.py file first generated two random lists and modifies the opcode according to the values of the lists. Finally, it will output the new opcode to a tmp file.
+import sys +if &amp;#34;generate_opcode_h&amp;#34; in sys.argv[0]: + random = __import__(&amp;#34;random&amp;#34;) + random.shuffle(perm) + random.shuffle(perm2) -def_op(&amp;#39;CACHE&amp;#39;, 0) -def_op(&amp;#39;POP_TOP&amp;#39;, 1) -def_op(&amp;#39;PUSH_NULL&amp;#39;, 2) +def_op(&amp;#39;CACHE&amp;#39;, perm[0]) +def_op(&amp;#39;POP_TOP&amp;#39;, perm[1]) +def_op(&amp;#39;PUSH_NULL&amp;#39;, perm[2]) +with open(&amp;#34;/tmp/opcode_map&amp;#34;, &amp;#34;w&amp;#34;) as f: + for x, y in enumerate(opname): + f.</description>
    </item>
    
    <item>
      <title>How to build peach fuzzer on Ubuntu18.04</title>
      <link>/post/how-to-build-peach-fuzzer-on-ubuntu1804/</link>
      <pubDate>Fri, 03 Jun 2022 00:38:33 +0800</pubDate>
      
      <guid>/post/how-to-build-peach-fuzzer-on-ubuntu1804/</guid>
      <description>Repository:
https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce
Modify from a dockerfile based on DEBIAN: https://raw.githubusercontent.com/vanhauser-thc/peachpro/main/Dockerfile
shell sudo apt update sudo apt install -y \  coreutils apt-utils wget curl openssl ca-certificates bash-completion \  joe vim nano \  unzip p7zip \  hping3 httping thc-ipv6 gdb \  tcpdump wireshark-common \  locales-all \  git build-essential joe vim strace tcpdump python python-pip python-is-python2\  ruby doxygen libxml2-utils less openjdk-8-jre xsltproc asciidoctor \  nodejs node-typescript wget \  apt-transport-https dirmngr gnupg libtool-bin \  cmake dos2unix g++-multilib --fix-missing cd ~/Downloads git clone https://gitlab.</description>
    </item>
    
    <item>
      <title>DefCamp2022 can-you-crack-this Writeup</title>
      <link>/post/defcamp2022-can-you-crack-this-wp/</link>
      <pubDate>Mon, 14 Feb 2022 23:08:32 +0800</pubDate>
      
      <guid>/post/defcamp2022-can-you-crack-this-wp/</guid>
      <description>can-you-crack-this The main function reads the input and constrains the length.
v11 = std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, &amp;#34;Enter your public key: &amp;#34;); std::ostream::operator&amp;lt;&amp;lt;(v11, std::endl&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;&amp;gt;); std::operator&amp;gt;&amp;gt;&amp;lt;char&amp;gt;(&amp;amp;std::cin, public_key); if ( (unsigned __int64)std::string::length(public_key) &amp;gt;= 20 ) { v9 = std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, &amp;#34;Enter serial key:&amp;#34;); std::ostream::operator&amp;lt;&amp;lt;(v9, std::endl&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;&amp;gt;); std::operator&amp;gt;&amp;gt;&amp;lt;char&amp;gt;(&amp;amp;std::cin, serial_key); v8 = 4 * std::string::length(public_key) - 1; if ( v8 == std::string::length(serial_key) ) { std::string::basic_string(str_public_key, public_key); std::string::basic_string(str_serial_key, serial_key); v6 = verify_serial((__int64)str_public_key, (__int64)str_serial_key); std::string::~string(str_serial_key); std::string::~string(str_public_key); if ( v6 ) { v5 = std::operator&amp;lt;&amp;lt;&amp;lt;std::char_traits&amp;lt;char&amp;gt;&amp;gt;(&amp;amp;std::cout, &amp;#34;Serial accepted.</description>
    </item>
    
    <item>
      <title>HGAME2022 writeups</title>
      <link>/post/hgame2022-writeups/</link>
      <pubDate>Fri, 04 Feb 2022 13:08:32 +0800</pubDate>
      
      <guid>/post/hgame2022-writeups/</guid>
      <description>Week1 [RE]easyasm 题目说 asm，那就硬看汇编呗
循环右移 4 位，然后异或 0x17
cipher = [ 0x91, 0x61, 0x01, 0xC1, 0x41, 0xA0, 0x60, 0x41, 0xD1, 0x21, 0x14, 0xC1, 0x41, 0xE2, 0x50, 0xE1, 0xE2, 0x54, 0x20, 0xC1, 0xE2, 0x60, 0x14, 0x30, 0xD1, 0x51, 0xC0, 0x17 ] def ror(x): return (x &amp;gt;&amp;gt; 4) | (x &amp;lt;&amp;lt; 4) &amp;amp; 0xff for c in cipher: print (chr(ror(c ^ 0x17)), end=&amp;#39;&amp;#39;) # hgame{welc0me_to_4sm_w0rld} [RE]creakme int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // edx  int i; // esi  unsigned int v5; // edi  unsigned int v6; // ebx  int v7; // esi  int v8; // esi  _DWORD v10[17]; // [esp+Ch] [ebp-8Ch] BYREF  _BYTE v11[32]; // [esp+50h] [ebp-48h]  char Arglist[32]; // [esp+70h] [ebp-28h] BYREF  int v13; // [esp+90h] [ebp-8h]  int v14; // [esp+94h] [ebp-4h]  memset(Arglist, 0, sizeof(Arglist)); sub_40103A(&amp;#34;%s&amp;#34;, (char)Arglist); strcpy((char *)v10, &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;#34;); v3 = 0; v14 = 0; for ( i = 0; i &amp;lt; 32; v14 = i ) { v5 = *(_DWORD *)&amp;amp;Arglist[i]; v6 = *(_DWORD *)&amp;amp;Arglist[i + 4]; v13 = 0; v7 = 32; do { v3 += 0x12345678; v5 += v3 ^ (v3 + v6) ^ (v10[2] + 16 * v6) ^ (v10[3] + (v6 &amp;gt;&amp;gt; 5)); v6 += v3 ^ (v3 + v5) ^ (v10[0] + 16 * v5) ^ (v10[1] + (v5 &amp;gt;&amp;gt; 5)); --v7; } while ( v7 ); v8 = v14; v3 = 0; *(_DWORD *)&amp;amp;Arglist[v14] = v5; *(_DWORD *)&amp;amp;Arglist[v8 + 4] = v6; i = v8 + 8; } *(_OWORD *)v11 = *(_OWORD *)dword_402180; *(_OWORD *)&amp;amp;v11[16] = dword_402170; while ( Arglist[v3] == v11[v3] ) { if ( ++v3 &amp;gt;= 32 ) { sub_40100C(&amp;#34;right!</description>
    </item>
    
    <item>
      <title>Reversing.kr writeups</title>
      <link>/post/reversing-kr-writeups/</link>
      <pubDate>Thu, 13 Jan 2022 20:41:50 +0800</pubDate>
      
      <guid>/post/reversing-kr-writeups/</guid>
      <description>CSHOP 按一下回车就通关了
如果要查看逻辑的话，需要先使用 de4dot 脱壳，然后用 dnSpy 打开
private void Form1_Load(object sender, EventArgs e) { this.lblSu.Text = &amp;#34; &amp;#34;; this.lblGu.Text = &amp;#34; &amp;#34;; this.lblNu.Text = &amp;#34; &amp;#34;; this.lblKu.Text = &amp;#34; &amp;#34;; this.lblZu.Text = &amp;#34; &amp;#34;; this.lblMu.Text = &amp;#34; &amp;#34;; this.lblTu.Text = &amp;#34; &amp;#34;; this.ppppp.Text = &amp;#34; &amp;#34;; this.lblGu.Text = &amp;#34; &amp;#34;; this.lblQu.Text = &amp;#34; &amp;#34;; this.ppppp.Text = &amp;#34; &amp;#34;; this.lblTu.Text = &amp;#34; &amp;#34;; this.lblXu.Text = &amp;#34; &amp;#34;; } // Token: 0x06000004 RID: 4 RVA: 0x000021B0 File Offset: 0x000003B0 	private void btnStart_Click(object sender, EventArgs e) { this.</description>
    </item>
    
    <item>
      <title>Two Challenges in KCTF2021 Fall</title>
      <link>/post/two-challenges-in-kctf2021-fall/</link>
      <pubDate>Thu, 23 Dec 2021 22:23:17 +0800</pubDate>
      
      <guid>/post/two-challenges-in-kctf2021-fall/</guid>
      <description>有些题还是很值得补的，最近没什么时间，假期补吧（
第一题 签到 这题还是比较容易的，需要一点点动调的经验
上张队友的截图吧，懒得自己截了

动调看看内存就知道，流程是：
serial-&amp;gt;十进制-&amp;gt;与name的crc异或-&amp;gt;计算crc
最后需要是一个固定的值，于是只需要想办法反解就行了
这里注意到了一个事情，那就是图中看似是对 v6 的 crc 结果做了约束，其实是对 v6 本身进行了约束
由于题目给了一个实例的 name 和 serial，我们只需要动调拿到这个的 v6，就知道能通过验证的 v6 是多少了
接下来动调拿一下 KCTF 的 crc，这个的结果再异或一下目标的 v6，就得到serial了
 靠记忆写的，希望没错
 第二题 迷失丛林  这题就直接放提交的wp了
 很容易定位到程序的输入

输入长度为32，需要通过 sub_4014A0, sub_401580 的验证
4014A0 较为简单，是个经典的hexstr转成char存到 4041F0 这个地址，最后的16是计算转换后的长度，所以输入就是 [0-9A-F]{32}
随后将输入的前八字节存入 404000 中，剩下的部分传参进 sub_401580
要想让该函数返回1，需要先通过如下的if验证

简单看一下使用的变量，应该是对前八字节的输入进行的验证

结合动调发现大概就是根据404000数组，构成一个 &amp;lt;value, index&amp;gt; 的结构，两两存放到404420当中
分析了一下404000数组的作用和特征，发现这个数组应该是构成一个环状的结构（以当前数值作为索引寻找下一个数），猜测不能有重复的数字，否则可能会构成小循环之类的，用脚本验证了一下发现后面248个数字果然没有重复，于是将前八字节的取值可能锁定到了 0x1e, 0x28, 0x4b, 0x6d, 0x8c, 0xa3, 0xd2, 0xfb 中，总共有 $8!</description>
    </item>
    
    <item>
      <title>Migrate to Hugo</title>
      <link>/post/migrate-to-hugo/</link>
      <pubDate>Tue, 21 Dec 2021 23:23:50 +0800</pubDate>
      
      <guid>/post/migrate-to-hugo/</guid>
      <description>修改主题的想法 之前的 Next 用了有一年多了，自己也做了各种修改，比如加个背景、改个字体之类的。但最近发现由于我硬改了一些颜色，导致深色模式下没什么问题，但浅色模式下就有一个模块是黑色的，很难看，又懒得找当时自己写的代码在哪儿了。
另一个原因是队友们都跟风用 Next 主题，难免有点审美疲劳。最终就决定给自己换个主题。
本来的选择 其实最一开始并没有打算换成 Hugo，毕竟 Hexo 又不是不能用，既然很多东西都配置好了，那换个主题直接生成多好。于是我精挑细选选了个一个 Hexo 主题：https://github.com/Haojen/hexo-theme-Claudia。
然而配置的时候发现好像因为 npm 的原因，scss 文件一直跑不起来，很多 css 文件无法生成，于是就想干脆迁移到 Hugo，这样还省得配 npm 了。
结识 Hugo stack 最初看到 Hugo 其实是在帮 web 手收集博客的时候看到了陆队的博客，正好记录了迁移到 Hugo 的过程。博客里讲了 Hugo 的静态网页生成速度很快。联想到自己的博客垃圾文章也越来越多，Hexo 确实有点慢了，Hugo 也许以后会是个不错的选择。
后来想要帮校队搭个博客，于是决定试试 Hugo。最一开始看中的是 Hugo Bootstrap Theme，想把背景改一下颜色，但是失败了，于是又找了找主题，发现 Stack 更好看，于是干脆就拿 Stack 搭了，而后来才发现，原来陆队的博客也是 stack 主题，看来审美从来没有变过 😂。
于是，在 Claudia 配置失败后，我果断转到了 Hugo Stack 主题。
目前的修改 友链 Stack 主题本身是不带友链的，作者应该是正在写，但比较忙，也不知道什么时候能写完，于是就看了看别人的方案。直接搜能搜到一个方案，但讲得不是特别清楚，搭建失败了。后来在 pull request 里面发现有人实现了一个，作者没有采纳而已，于是就以这个作为临时方案了。
主题 assets/scss/style.scss 27行添加：
@import &amp;#34;partials/layout/links.scss&amp;#34;; 新建 assets/scss/partials/layout/links.scss
/* Place your custom SCSS in HUGO_SITE_FOLDER/assets/scss/custom.</description>
    </item>
    
    <item>
      <title>All Solves During a Weekend</title>
      <link>/post/all-solves-during-a-weekend/</link>
      <pubDate>Mon, 13 Dec 2021 19:37:54 +0800</pubDate>
      
      <guid>/post/all-solves-during-a-weekend/</guid>
      <description>打美团 CTF 的时候才意识到，有一种坐牢叫AK
 [MTCTF 4th]wow 先进行脱壳，因为脱壳后用的是绝对地址，而加载的时候是动态加载，所有没有办法调试，那就直接静态看吧
JUMPOUT 那里看一下汇编，发现有一个天堂之门
push 0x33 call $+5 add [esp+84h+var_84], 5 retf 直接把后面的数据全 dump 出来，然后用 ida64 打开
void __fastcall sub_0(unsigned int *a1) { unsigned int v1; // er9  int v2; // ebp  unsigned int v3; // esi  unsigned int *v4; // rdi  unsigned int *v5; // r10  unsigned int v6; // ebx  unsigned int i; // er11  unsigned int v8; // er8  int v9; // edx  unsigned int v10; // eax  unsigned int v11; // er9  unsigned int v12; // er8  int v13; // ebx  int v14; // ebx  int v15; // ebx  int v16; // edx  unsigned int v17; // eax  unsigned int v18; // er9  v1 = a1[8]; v2 = 12; v3 = 0; while ( 1 ) { v3 += 1732584193; v4 = a1 + 1; v5 = a1; v6 = v3 &amp;gt;&amp;gt; 2; for ( i = 0; i &amp;lt; 8; ++i ) { v8 = *v4; if ( (((unsigned __int8)i ^ (unsigned __int8)v6) &amp;amp; 3) !</description>
    </item>
    
    <item>
      <title>DragonCTF Runofthemill Writeup</title>
      <link>/post/dragonctf-runofthemill-writeup/</link>
      <pubDate>Fri, 10 Dec 2021 02:01:06 +0000</pubDate>
      
      <guid>/post/dragonctf-runofthemill-writeup/</guid>
      <description>题目分析 获取输入
v1 = sys_read(0, byte_412000, 0x40uLL); 中间计算
byte_412000[42] = __ROR1__(byte_412000[42], 4); *(_DWORD *)&amp;amp;byte_412000[44] ^= 0x4EC10FC6u; *(_WORD *)&amp;amp;byte_412000[15] ^= 0xEBFFu; *(_DWORD *)&amp;amp;byte_412000[38] -= 1698263770; // 以下省略 最后的验证
v9 = byte_412000; v10 = byte_412050; v11 = 64LL; v12 = 0; do { v12 |= *v10++ ^ *v9++; --v11; } while ( v11 ); Angr求解 还是很容易看懂的，主要是如何求解
一种思路是把汇编反过来，pizza爷用的是这种做法，于是就写了个Angr喝茶去了
Angr用的是手动往全局变量注入符号，然后在验证前停止，手动添加约束，wp中的写法是直接用程序中的验证，并添加了 LAZY_SOLVES 参数，学到了
之前用自己脚本跑的适合发现一直是 unsat，以为Angr会有问题，但后来发现有个wp就是用的Angr
于是掏出了之前写的脚本做了一些尝试
from angr import * import claripy import binascii input_length = 56 base_addr = 0x400000 proj = Project(&#39;runofthemill&#39;, main_opts={&amp;quot;base_addr&amp;quot;: base_addr}) start_addr = 0x401054 state = proj.</description>
    </item>
    
    <item>
      <title>Learn Basic Signal from DNUICTF easyre</title>
      <link>/post/learn-basic-signal-from-dnuictf-easyre/</link>
      <pubDate>Thu, 09 Dec 2021 15:05:55 +0000</pubDate>
      
      <guid>/post/learn-basic-signal-from-dnuictf-easyre/</guid>
      <description>一些信号量函数的学习 信号量的注册在init函数中
v2.sa_handler = (__sighandler_t)sub_400E1D; v2.sa_flags = 4; sigaction(34, &amp;amp;v2, &amp;amp;v1); sigaction() 函数定义为
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); sigaction 结构体定义如下
struct sigaction { void (*sa_handler) (int); sigset_t sa_mask; int sa_flags; // 用来设置信号处理的相关操作  void (*sa_restorer) (void); } 关于 sa_flags 的定义如下 (from linux/include/uapi/asm-generic/signal-defs.h)
#ifndef SA_NOCLDSTOP #define SA_NOCLDSTOP	0x00000001 #endif #ifndef SA_NOCLDWAIT #define SA_NOCLDWAIT	0x00000002 #endif #ifndef SA_SIGINFO #define SA_SIGINFO	0x00000004 #endif /* 0x00000008 used on alpha, mips, parisc */ /* 0x00000010 used on alpha, parisc */ /* 0x00000020 used on alpha, parisc, sparc */ /* 0x00000040 used on alpha, parisc */ /* 0x00000080 used on parisc */ /* 0x00000100 used on sparc */ /* 0x00000200 used on sparc */ #define SA_UNSUPPORTED	0x00000400 #define SA_EXPOSE_TAGBITS	0x00000800 /* 0x00010000 used on mips */ /* 0x00800000 used for internal SA_IMMUTABLE */ /* 0x01000000 used on x86 */ /* 0x02000000 used on x86 */ /* * New architectures should not define the obsolete *	SA_RESTORER	0x04000000 */ #ifndef SA_ONSTACK #define SA_ONSTACK	0x08000000 #endif #ifndef SA_RESTART #define SA_RESTART	0x10000000 #endif #ifndef SA_NODEFER #define SA_NODEFER	0x40000000 #endif #ifndef SA_RESETHAND #define SA_RESETHAND	0x80000000 #endif 题目中使用的是 SA_SIGINFO，对信号处理程序提供了附加信息：一个指向 siginfo 结构的指针以及一个指向上下文标识符的指针</description>
    </item>
    
    <item>
      <title>Resent RE Challenge</title>
      <link>/post/resent-re-challenge/</link>
      <pubDate>Tue, 23 Nov 2021 14:06:23 +0000</pubDate>
      
      <guid>/post/resent-re-challenge/</guid>
      <description>[N1CTF 2021]babyrust [N1CTF 2021]Py [L3HCTF 2021]double-joy [L3HCTF 2021]Load [hack.lu]pycoin [hack.lu]atareee  TODO:
 [L3HCTF 2021]idaaaaaaaa  [N1CTF]babyrust 题目直接给了Rust源码，之前没有见过，现查文档学习
首先main函数里只是调用了一个 check!
let result = check!(@s /*your answer*/); main 上面就是 check 的实现
macro_rules! check { (@s n1ctf{$Never:tt}) =&amp;gt; { check!(stringify!($Never)) }; macro_rules! 是个宏定义，里面的 @s，@e 应该是类似字符串匹配的东西
一开始的 (@s n1ctf{$Never:tt}) 就把flag中去除 n1ctf{} 的部分存到了 $Never 变量中，stringify! 将其转换为字符串常量
 stringify! 为 Rust 内置宏。其接收一个 Rust 表达式，如 1 + 2 ， 然后在编译时将表达式转换为一个字符串常量，如 &amp;ldquo;1 + 2&amp;rdquo; 。
 接下来的宏定义有很多类似这个的：</description>
    </item>
    
    <item>
      <title>TSGCTF2021 and pbctf2021 RE writeups</title>
      <link>/post/tsgctf2021-and-pbctf2021-re-writeups/</link>
      <pubDate>Sat, 09 Oct 2021 22:22:33 +0000</pubDate>
      
      <guid>/post/tsgctf2021-and-pbctf2021-re-writeups/</guid>
      <description>TSGCTF2021 Beginners Rev 用 fork() 遍历了 32 位输入，每个输入都分别进行一次函数运算
do { ++v2; if ( !fork() ) { v2 = 0; v1 |= 1 &amp;lt;&amp;lt; v3; v7 = open(&amp;#34;/dev/null&amp;#34;, 1); dup2(v7, 1); } ++v3; } while ( v3 != 5 ); 每个函数运算都是将输入迭代好多次
v4 = (unsigned __int8 *)&amp;amp;key + a2; v5 = v4[2]; v6 = 1; while ( (unsigned int)(-1217102449 * v5 + 1217102449) &amp;gt; 0xB2927C ) { ++v6; v5 += v4[2]; if ( v6 == 367 ) { v6 = -1; break; } } v7 = v4[4]; v8 = v4[3] * ((a1 + *v4) % 367 * v4[1] % 367 * v6 % 367) % 367; 被retaddr坑了一会，后面才反应过来开头那个 if ( retaddr - (_BYTE *)check !</description>
    </item>
    
    <item>
      <title>angr ctf writeup</title>
      <link>/post/angr-ctf-writeup/</link>
      <pubDate>Mon, 27 Sep 2021 21:03:03 +0000</pubDate>
      
      <guid>/post/angr-ctf-writeup/</guid>
      <description>&lt;p&gt;开始学angr&lt;/p&gt;
&lt;p&gt;&lt;del&gt;就是在抄solution&lt;/del&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DASCTF 2021-09 Writeup</title>
      <link>/post/dasctf-2021-09-writeup/</link>
      <pubDate>Sun, 26 Sep 2021 00:10:18 +0000</pubDate>
      
      <guid>/post/dasctf-2021-09-writeup/</guid>
      <description>[RE]ea5ycpp 一开始还被逻辑绕了一下，结果发现核心部分就是brainfuck
有一些结构体，可以恢复一下，会比较好看
brainfuck解析出来就是简单的加减法
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; unsigned char a[9999]; int c; int main(int argc, char **argv) { a[24] += 2; while (a[24]) { ++a[0]; --a[24]; } a[24] += 3; while (a[24]) { ++a[1]; --a[24]; } a[24] += 4; while (a[24]) { ++a[2]; --a[24]; } a[24] += 5; while (a[24]) { ++a[3]; --a[24]; } a[24] += 6; while (a[24]) { ++a[4]; --a[24]; } a[24] += 7; while (a[24]) { ++a[5]; --a[24]; } a[24] += 8; while (a[24]) { ++a[6]; --a[24]; } a[24] += 9; while (a[24]) { ++a[7]; --a[24]; } a[24] += 10; while (a[24]) { ++a[8]; --a[24]; } a[24] += 11; while (a[24]) { ++a[9]; --a[24]; } a[24] += 12; while (a[24]) { ++a[10]; --a[24]; } a[24] += 13; while (a[24]) { ++a[11]; --a[24]; } a[24] += 14; while (a[24]) { ++a[12]; --a[24]; } a[24] += 15; while (a[24]) { ++a[13]; --a[24]; } a[24] += 16; while (a[24]) { ++a[14]; --a[24]; } a[24] += 18; while (a[24]) { ++a[15]; --a[24]; } a[24] += 19; while (a[24]) { ++a[16]; --a[24]; } a[24] += 20; while (a[24]) { ++a[17]; --a[24]; } a[24] += 21; while (a[24]) { ++a[18]; --a[24]; } a[24] += 22; while (a[24]) { ++a[19]; --a[24]; } a[24] += 23; while (a[24]) { ++a[20]; --a[24]; } a[24] += 24; while (a[24]) { ++a[21]; --a[24]; } a[24] += 25; while (a[24]) { ++a[22]; --a[24]; } a[24] += 26; while (a[24]) { ++a[23]; --a[24]; } return 0; } 根据字符串就能看到比较的位置，密文减一下就行</description>
    </item>
    
    <item>
      <title>加密与解密学习笔记（持续更新ing）</title>
      <link>/post/note-of-book-encryption-and-decryption/</link>
      <pubDate>Sat, 25 Sep 2021 02:15:45 +0800</pubDate>
      
      <guid>/post/note-of-book-encryption-and-decryption/</guid>
      <description>&lt;p&gt;suibiankankan&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dfjk 2021 RE</title>
      <link>/post/2021dfjk-re/</link>
      <pubDate>Wed, 04 Aug 2021 13:48:58 +0000</pubDate>
      
      <guid>/post/2021dfjk-re/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;RE1：迷宫&lt;/li&gt;
&lt;li&gt;RE2：so层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一个好像是php？告辞&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CISCN-N 2021 RE Writeup</title>
      <link>/post/ciscn-n-2021-re-writeup/</link>
      <pubDate>Tue, 22 Jun 2021 23:25:43 +0000</pubDate>
      
      <guid>/post/ciscn-n-2021-re-writeup/</guid>
      <description>imnotavirus 解exe，解密pyc
利用解密后的pyc，找到注入的shellcode，用ida解smc，最后解密
比赛的时候还被迫阅读了一下pyinstaller的源码，收获很大
解exe 看到附件给了个pyinstaller，猜测是python逆向
先ida看一眼，有upx壳，自动脱壳，再用exeinfo确认了一下是python逆向，pyinstxtractor.py解包（之前V&amp;amp;N2021就吃了这个亏）
解pyc 解包时提示被加密了
取struct头作为标准头，用pycdc还原出main.py，发现调用了sign
去PYZ00文件夹看一下，发现被加密了，看一下目录，发现pyimod和比一般情况多了一些东西，把这些都解开看一下，有一个key文件
同时发现archive中有一个Cipher类，但是pycdc缺少指令，无法全部还原，考虑看一下pycdas解出来的字节码
字节码中有个对pyinstaller源码的引用，直接去文件夹里面看，发现能解密出来的部分完全一致
照着源码中的方法解密sign
from key import key import tinyaes print (key) f = open(&amp;#39;./PYZ-00.pyz_extracted/sign.pyc.encrypted&amp;#39;, &amp;#39;rb&amp;#39;) data = f.read() cipher = tinyaes.AES(key.encode(), data[:16]) output = cipher.CTR_xcrypt_buffer(data[16:]) f.close() import zlib output = zlib.decompress(output) f = open(&amp;#39;./sign.pyc&amp;#39;, &amp;#39;wb&amp;#39;) f.write(output) 解密 解出sign后看到有三个base64，其中两个是执行的语句，此外大部分语句涉及到了内存
另外一个base解出来是乱码，用字节码辅助恢复函数（其实特征已经很明显了），发现进行了rc4加密，直接打印出解密结果，将结果写入文件，用ida查看
发现smc
mov eax, 41178Bh mov ecx, 411802h sub ecx, eax loc_2A: mov ebx, [rax] xor ebx, 77h mov [rax], ebx loop loc_2A 解出来后尝试恢复了一下函数，结果很丑&amp;hellip;只能和汇编比较着进行分析了（好像只要把00 patch一下就可以反编译了）</description>
    </item>
    
    <item>
      <title>Reverse from 1 to 2</title>
      <link>/post/reverse-from-1-to-2/</link>
      <pubDate>Wed, 26 May 2021 23:54:09 +0000</pubDate>
      
      <guid>/post/reverse-from-1-to-2/</guid>
      <description>[NPUCTF2020]BasicASM 纯考察汇编的题目，有考虑想办法改成正确的汇编形式然后编译用ida看，但感觉就失去意义了，于是硬啃汇编
00007FF7A8AC5A50 push rbp 00007FF7A8AC5A52 push rdi 00007FF7A8AC5A53 sub rsp,238h 00007FF7A8AC5A5A lea rbp,[rsp+20h] 00007FF7A8AC5A5F mov rdi,rsp 00007FF7A8AC5A62 mov ecx,8Eh 00007FF7A8AC5A67 mov eax,0CCCCCCCCh 00007FF7A8AC5A6C rep stos dword ptr [rdi] 00007FF7A8AC5A6E mov rax,qword ptr [__security_cookie (07FF7A8AD3018h)] 00007FF7A8AC5A75 xor rax,rbp 00007FF7A8AC5A78 mov qword ptr [rbp+208h],rax 00007FF7A8AC5A7F lea rcx,[__06A15900_ConsoleApplication@cpp (07FF7A8AD902Ah)] 00007FF7A8AC5A86 call __CheckForDebuggerJustMyCode (07FF7A8AC1122h) 00007FF7A8AC5A8B lea rdx,[string &amp;quot;flag{this_is_a_fake_flag}&amp;quot; (07FF7A8ACF450h)] 00007FF7A8AC5A92 lea rcx,[flag] 00007FF7A8AC5A96 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt; (07FF7A8AC15E1h) 00007FF7A8AC5A9B nop 00007FF7A8AC5A9C mov dword ptr [p],0 00007FF7A8AC5AA3 mov i,0 00007FF7A8AC5AAA jmp main+64h (07FF7A8AC5AB4h) 00007FF7A8AC5AAC mov eax,i 00007FF7A8AC5AAF inc eax 00007FF7A8AC5AB1 mov i,eax 00007FF7A8AC5AB4 movsxd rax,i 00007FF7A8AC5AB8 mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5ABF lea rcx,[flag] 00007FF7A8AC5AC3 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::length (07FF7A8AC122Bh) 00007FF7A8AC5AC8 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5ACF cmp rcx,rax 00007FF7A8AC5AD2 jae main+1B2h (07FF7A8AC5C02h) ; 无符号数比较，大于或等于时跳转 00007FF7A8AC5AD8 mov eax,i 00007FF7A8AC5ADB and eax,1 ; 取最后1位 00007FF7A8AC5ADE cmp eax,1 ; 判断奇偶 00007FF7A8AC5AE1 jne main+126h (07FF7A8AC5B76h) ; 偶数跳转（不相等跳转） 00007FF7A8AC5AE7 movsxd rax,i 00007FF7A8AC5AEB mov rdx,rax 00007FF7A8AC5AEE lea rcx,[flag] 00007FF7A8AC5AF2 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5AF7 movsx eax,byte ptr [rax] ; 取flag第i位 00007FF7A8AC5AFA xor eax,42h ; 与0x42异或 00007FF7A8AC5AFD mov dword ptr [p],eax ; 异或结果移到内存中 00007FF7A8AC5B00 mov dl,30h 00007FF7A8AC5B02 lea rcx,[rbp+144h] 00007FF7A8AC5B09 call std::setfill&amp;lt;char&amp;gt; (07FF7A8AC1046h) ; 用字符&#39;0&#39;进行填充 00007FF7A8AC5B0E mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5B15 mov edx,2 00007FF7A8AC5B1A lea rcx,[rbp+168h] 00007FF7A8AC5B21 call std::setw (07FF7A8AC10D2h) ; 填充至2位 00007FF7A8AC5B26 mov qword ptr [rbp+200h],rax 00007FF7A8AC5B2D lea rdx,[std::hex (07FF7A8AC1488h)] ; 以十六进制形式输出 00007FF7A8AC5B34 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5B3B call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7160h)] 00007FF7A8AC5B41 mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5B48 mov rdx,rcx 00007FF7A8AC5B4B mov rcx,rax 00007FF7A8AC5B4E call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,__int64&amp;gt; (07FF7A8AC12F8h) 00007FF7A8AC5B53 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5B5A mov rdx,rcx 00007FF7A8AC5B5D mov rcx,rax 00007FF7A8AC5B60 call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,char&amp;gt; (07FF7A8AC11A4h) 00007FF7A8AC5B65 mov edx,dword ptr [p] 00007FF7A8AC5B68 mov rcx,rax 00007FF7A8AC5B6B call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7158h)] 00007FF7A8AC5B71 jmp main+1ADh (07FF7A8AC5BFDh) 00007FF7A8AC5B76 movsxd rax,i ; 偶数时跳转到这里，与奇数唯一的区别为没有异或运算 00007FF7A8AC5B7A mov rdx,rax 00007FF7A8AC5B7D lea rcx,[flag] 00007FF7A8AC5B81 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5B86 movsx eax,byte ptr [rax] 00007FF7A8AC5B89 mov dword ptr [p],eax 00007FF7A8AC5B8C mov dl,30h 00007FF7A8AC5B8E lea rcx,[rbp+194h] 00007FF7A8AC5B95 call std::setfill&amp;lt;char&amp;gt; (07FF7A8AC1046h) 00007FF7A8AC5B9A mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5BA1 mov edx,2 00007FF7A8AC5BA6 lea rcx,[rbp+1B8h] 00007FF7A8AC5BAD call std::setw (07FF7A8AC10D2h) 00007FF7A8AC5BB2 mov qword ptr [rbp+200h],rax 00007FF7A8AC5BB9 lea rdx,[std::hex (07FF7A8AC1488h)] 00007FF7A8AC5BC0 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5BC7 call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7160h)] 00007FF7A8AC5BCD mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5BD4 mov rdx,rcx 00007FF7A8AC5BD7 mov rcx,rax 00007FF7A8AC5BDA call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,__int64&amp;gt; (07FF7A8AC12F8h) 00007FF7A8AC5BDF mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5BE6 mov rdx,rcx 00007FF7A8AC5BE9 mov rcx,rax 00007FF7A8AC5BEC call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,char&amp;gt; (07FF7A8AC11A4h) 00007FF7A8AC5BF1 mov edx,dword ptr [p] 00007FF7A8AC5BF4 mov rcx,rax 00007FF7A8AC5BF7 call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7158h)] 00007FF7A8AC5BFD jmp main+5Ch (07FF7A8AC5AACh) 00007FF7A8AC5C02 mov dword ptr [rbp+1E4h],0 00007FF7A8AC5C0C lea rcx,[flag] 00007FF7A8AC5C10 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::~basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt; (07FF7A8AC1302h) 00007FF7A8AC5C15 mov eax,dword ptr [rbp+1E4h] 00007FF7A8AC5C1B mov edi,eax 00007FF7A8AC5C1D lea rcx,[rbp-20h] 00007FF7A8AC5C21 lea rdx,[__xt_z+540h (07FF7A8ACEFE0h)] 00007FF7A8AC5C28 call _RTC_CheckStackVars (07FF7A8AC1596h) 00007FF7A8AC5C2D mov eax,edi 00007FF7A8AC5C2F mov rcx,qword ptr [rbp+208h] 00007FF7A8AC5C36 xor rcx,rbp 00007FF7A8AC5C39 call __security_check_cookie (07FF7A8AC1190h) 00007FF7A8AC5C3E lea rsp,[rbp+218h] 00007FF7A8AC5C45 pop rdi 00007FF7A8AC5C46 pop rbp 00007FF7A8AC5C47 ret 简单的说，过程就是一个循环，根据 i 的奇偶进行判断，是否与 0x42 进行异或，然后将结果以 2 位十六进制输出，所以只需要进行反向求解即可</description>
    </item>
    
    <item>
      <title>CISCN2021 RE writeup</title>
      <link>/post/ciscn2021-re-writeup/</link>
      <pubDate>Thu, 20 May 2021 01:21:59 +0000</pubDate>
      
      <guid>/post/ciscn2021-re-writeup/</guid>
      <description>glass 安卓逆向，使用jeb打开，发现在java层仅进行了简单的输入，然后进入so层判断
用ida打开so层，直接搜索java，进入判断函数
下面的字符串应该是密钥
qmemcpy(v6, &amp;#34;12345678&amp;#34;, sizeof(v6)); 然后调用了三个函数
sub_FFC(v7, v6, v4); sub_1088(v7, flag, 39); sub_10D4(flag, 39, v6, v4); 进入查看，第一个是RC4密钥初始化，第二个是RC4加密，第三个是对密文进行简单的运算
从字符串里拿密文，写脚本进行求解，先对简单运算进行反向运算，然后找个RC4密码的脚本，跑一下就可以找到flag
cipher = [0xA3, 0x1A, 0xE3, 0x69, 0x2F, 0xBB, 0x1A, 0x84, 0x65, 0xC2, 0xAD, 0xAD, 0x9E, 0x96, 5, 2, 0x1F, 0x8E, 0x36, 0x4F, 0xE1, 0xEB, 0xAF, 0xF0, 0xEA, 0xC4, 0xA8, 0x2D, 0x42, 0xC7, 0x6E, 0x3F, 0xB0, 0xD3, 0xCC, 0x78, 0xF9, 0x98, 0x3F, 0] key = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38] def __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b&amp;#39;&amp;#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).</description>
    </item>
    
    <item>
      <title>津门杯 GoodRE writeup</title>
      <link>/post/jinmen-cup-goodre-writeup/</link>
      <pubDate>Mon, 10 May 2021 02:32:59 +0000</pubDate>
      
      <guid>/post/jinmen-cup-goodre-writeup/</guid>
      <description>&lt;p&gt;和两位学长一起做出来的，总算是能在团队赛中做出来题了，结束了长达一个月的白给生涯，不容易啊&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>hmg2021 RSA Attack writeup</title>
      <link>/post/hmg2021-rsa-attack-writeup/</link>
      <pubDate>Tue, 13 Apr 2021 21:39:43 +0000</pubDate>
      
      <guid>/post/hmg2021-rsa-attack-writeup/</guid>
      <description>已知一个 $1024$ 位的 $p1$，$p2$ 比 $p1$ 稍小，根据代码知道 $p3\equiv p2!\pmod{p1}$
根据 Wilson 定理，$n$ 为质数时有 $(n-1)!\equiv -1\pmod{n}$，所以 $p2! \prod\limits_{i=p2+1}^{p1-2}i\equiv 1\pmod{p1}$，所以可以计算出 $p2+1$ 乘到 $p1-1$ 的结果，然后取模拟并调用 sympy 库即可得到 $p3$
import sympy from libnum import invmod p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031 p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034 res = 1 for i in range(p2 + 1, p1 - 1): res = res * i % p1 res = invmod(res, p1) p3 = sympy.nextprime(res) p = p3 &amp;gt;&amp;gt; 50 &amp;lt;&amp;lt; 50 得到的 $p$ 是最终 RSA 加密用的 $P$ 的高位，因此可以使用 Factoring with High Bits Known 攻击，用 sage 构造如下攻击脚本（网上找的）</description>
    </item>
    
    <item>
      <title>BUUOJ FlareOn Challenge</title>
      <link>/post/buuoj-flareon-challenge/</link>
      <pubDate>Fri, 09 Apr 2021 01:04:16 +0000</pubDate>
      
      <guid>/post/buuoj-flareon-challenge/</guid>
      <description>Chanllenge1 一个修改了 table 的 Base64
import base64 import string fake_base = &amp;#39;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&amp;#39; true_base = string.ascii_uppercase + string.ascii_lowercase + string.digits + &amp;#39;+/&amp;#39; cipher = &amp;#39;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&amp;#39; good_cipher = &amp;#39;&amp;#39; for c in cipher: good_cipher += true_base[fake_base.index(c)] print (good_cipher) print (base64.b64decode(good_cipher)) Bob Doge 先运行测试一下，发现点击 Decode 之后是乱码
用 dnSpy 打开，找到 Main 函数
private static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } 发现只新建了一个 Form1
进入 Form1，找到带有 Click 的函数
private void btnDecode_Click(object sender, EventArgs e) { this.</description>
    </item>
    
    <item>
      <title>GWCTF2019 re3 writeup</title>
      <link>/post/gwctf2019-re3-writeup/</link>
      <pubDate>Thu, 08 Apr 2021 22:36:12 +0000</pubDate>
      
      <guid>/post/gwctf2019-re3-writeup/</guid>
      <description>静态分析 首先通过关键字符串 Wrong 进入 main 函数
void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-48h]  char s[40]; // [rsp+20h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+48h] [rbp-8h]  v5 = __readfsqword(0x28u); __isoc99_scanf(&amp;#34;%39s&amp;#34;, s); if ( (unsigned int)strlen(s) != 32 ) { puts(&amp;#34;Wrong!&amp;#34;); exit(0); } mprotect(&amp;amp;dword_400000, 0xF000uLL, 7); for ( i = 0; i &amp;lt;= 223; ++i ) *((_BYTE *)sub_402219 + i) ^= 0x99u; sub_40207B((__int64)&amp;amp;unk_603170); sub_402219(); } 阅读一下代码，发现先是输入一个长度为32的字符串</description>
    </item>
    
    <item>
      <title>高校战役 re writeups</title>
      <link>/post/gxzy-re-writeups/</link>
      <pubDate>Wed, 31 Mar 2021 20:33:02 +0000</pubDate>
      
      <guid>/post/gxzy-re-writeups/</guid>
      <description>cycle graph 天津垓 fxck easyparser  cycle graph 逆向代码 根据提示，这是一道纯算法题，拖到 ida 中，根据关键字符串定位到关键函数。查看核心代码
dword_403370 = 0; v1 = &amp;amp;unk_403384; byte_403374 = 48; v2 = 0; dword_403378 = (int)&amp;amp;unk_403380; do { v3 = dword_402178[v2]; ++v2; *(v1 - 1) = v3; *v1 = (char *)&amp;amp;unk_403380 + 12 * dword_402274[v2]; v1[1] = (char *)&amp;amp;unk_403380 + 12 * dword_4021F4[v2]; v1 += 3; } while ( (signed int)v1 &amp;lt; (signed int)&amp;amp;unk_403504 ); 上面的代码是主函数开头的初始化部分
sub_401020(&amp;#34;You need a flag to get out of this:\n&amp;#34;, a1); scan(&amp;#34;%s&amp;#34;, &amp;amp;input); v4 = dword_403370; // 0  v5 = byte_403374; // 48  v6 = 5; v7 = dword_403378; do { v11 = *(&amp;amp;input + v6); if ( *(_DWORD *)v7 + v5 == v11 ) { v7 = *(_DWORD *)(v7 + 4); } else { if ( v5 - *(_DWORD *)v7 !</description>
    </item>
    
    <item>
      <title>VNCTF2021 FilpGame and notsudoku</title>
      <link>/post/vnctf2021-filpgame-and-notsudoku/</link>
      <pubDate>Thu, 25 Mar 2021 03:06:10 +0000</pubDate>
      
      <guid>/post/vnctf2021-filpgame-and-notsudoku/</guid>
      <description>notsudoku V&amp;amp;NCTF直接白给了，全程耗在了Crackme2上，辛辛苦苦找到密文和算法后发现需要动态调试？过程中not sudoku这题就扫了一眼，结果还没发现是python逆向，于是就爬爬了。
正文 好像是第一次做python exe的逆向
首先使用 exeinfo 差壳，发现有个 UPX
用 upx.exe -d 脱壳
比赛的时候没想到这个是python逆向，直接拖到ida里面了，于是直接gg
再使用 exeinfo 查一下，会发现是 pyinstaller 编译的文件，说明是python逆向
上网下载一下 pyinstxtractor.py 进行反编译
$ python3 pyinstxtractor.py notsudoku-noupx.exe 进入文件夹，找没有后缀的文件，发现有一个叫做 2 的，使用 010editor 从 struct 文件复制文件头（第一行），然后添加 .pyc 后缀，进行 pyc 反编译
$ uncompyle6 -o 2.py 2.pyc 即可得到 python 源码文件
发现文件里有一些日文，于是边阅读边修改就行
# uncompyle6 version 3.7.4 # Python bytecode 3.7 (3394) # Decompiled from: Python 3.6.9 (default, Jan 26 2021, 15:33:00)  # [GCC 8.4.0] # Embedded file name: 2.</description>
    </item>
    
    <item>
      <title>NepCTF2021 re writeups</title>
      <link>/post/nepctf2021-re-writeups/</link>
      <pubDate>Mon, 22 Mar 2021 18:30:03 +0000</pubDate>
      
      <guid>/post/nepctf2021-re-writeups/</guid>
      <description>hardsharp (.NET 逆向) 使用exeinfo发现是 C# .NET文件
直接用 dnSpy 打开
找到主函数
private static void Main(string[] args) { AesClass aesClass = new AesClass(); string text = &amp;#34;&amp;#34;; string strB = &amp;#34;1Umgm5LG6lNPyRCd0LktJhJtyBN7ivpq+EKGmTAcXUM+0ikYZL4h4QTHGqH/3Wh0&amp;#34;; byte[] array = new byte[] { 81, 82, 87, 81, 82, 87, 68, 92, 94, 86, 93, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 }; Console.WriteLine(&amp;#34;Welcome to nepnep csharp test!</description>
    </item>
    
    <item>
      <title>HGAME2021 Vernam and FAKE</title>
      <link>/post/hgame2021-vernam-and-fake/</link>
      <pubDate>Wed, 17 Mar 2021 20:06:09 +0000</pubDate>
      
      <guid>/post/hgame2021-vernam-and-fake/</guid>
      <description>对称之美 题目 Vernam 密码
import random import string import itertools from secret import FLAG key = &amp;#39;&amp;#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) cipher = bytes([ord(m)^ord(k) for m, k in zip(FLAG, itertools.cycle(key))]) print(cipher) 思路 由于给了大量的密文，完全可以对密钥空间进行范围上的缩小。
由于进行的是异或操作，且明文与密钥均为可见字符，只需要对相同位置的密文与所有可能的密钥字符进行异或计算，结果不在可见字符范围内的均可以排除掉。
经过初步筛选后密钥空间会小很多，进行爆破或者根据上下文手动选择即可。
代码 import string import itertools key = string.ascii_letters + string.digits # first = [94, 116, 57, 32, 54, 49, 33, 32, 54, 38, 116, 59, 37, 32, 32, 116, 60, 32, 57, 59, 51, 34, 38, 39, 116, 59, 116, 38, 60, 61, 35, 58, 39, 55, 59, 116, 49, 32, 48, 39, 55, 94, 59, 116, 38, 39, 116, 50, 59, 53, 48, 122, 60, 94, 116, 61, 54, 38, 38, 32, 39, 116, 56, 59, 53, 97, 1] # first = [35, 25, 21, 25, 17, 2, 28, 3, 5, 21, 17, 3, 5, 80, 80, 18, 25, 31, 21, 31, 94, 21, 80, 4, 24, 31, 17, 3, 17, 4, 80, 80, 25, 17, 3, 0, 9, 24, 9, 25, 24, 17, 30, 3, 9, 80, 17, 17, 2, 80, 31, 80, 80, 22, 3, 3, 25, 9, 21, 24, 80, 17, 21, 80, 23, 93, 62] # first = [78, 68, 89, 89, 91, 23, 83, 23, 67, 91, 89, 94, 82, 69, 78, 66, 89, 23, 67, 92, 23, 69, 67, 23, 86, 92, 89, 23, 83, 27, 67, 85, 84, 91, 82, 69, 25, 94, 23, 89, 94, 65, 23, 89, 23, 88, 23, 84, 23, 91, 64, 110, 68, 86, 78, 23, 91, 23, 23, 82, 61, 71, 68, 95, 13, 86, 89] # first = [43, 102, 50, 33, 39, 76, 102, 50, 102, 39, 34, 50, 53, 35, 41, 53, 34, 53, 52, 102, 76, 39, 46, 47, 52, 102, 37, 43, 102, 102, 46, 41, 39, 106, 102, 35, 102, 53, 49, 33, 40, 41, 50, 39, 54, 52, 42, 35, 76, 47, 40, 41, 47, 37, 43, 47, 39, 39, 36, 52, 34, 54, 53, 35, 102, 25, 63] # first = [3, 25, 29, 78, 0, 1, 12, 6, 7, 26, 78, 7, 64, 15, 27, 23, 78, 11, 23, 15, 58, 2, 7, 29, 10, 8, 7, 15, 100, 12, 15, 10, 2, 78, 1, 10, 100, 78, 6, 78, 9, 7, 6, 28, 15, 78, 1, 78, 15, 0, 78, 27, 10, 11, 3, 29, 26, 0, 1, 78, 7, 11, 78, 28, 100, 27, 49] # first = [31, 18, 90, 21, 25, 15, 31, 31, 14, 31, 112, 21, 112, 22, 8, 90, 14, 31, 90, 14, 18, 90, 9, 90, 87, 21, 31, 3, 27, 15, 14, 19, 22, 27, 28, 27, 46, 25, 31, 27, 90, 30, 31, 22, 25, 24, 21, 19, 20, 31, 14, 93, 31, 90, 31, 90, 31, 30, 14, 9, 12, 27, 14, 31, 18, 41, 57] # first = [69, 84, 94, 67, 84, 69, 17, 92, 17, 17, 94, 95, 104, 88, 17, 70, 89, 90, 70, 17, 84, 67, 31, 69, 70, 67, 95, 17, 17, 69, 17, 84, 72, 66, 17, 69, 89, 80, 69, 17, 85, 88, 17, 88, 90, 84, 90, 95, 85, 17, 89, 93, 66, 80, 69, 59, 67, 17, 89, 88, 88, 67, 89, 17, 86, 2, 0] # first = [65, 93, 85, 19, 19, 29, 71, 64, 80, 71, 71, 82, 92, 73, 81, 92, 86, 19, 91, 82, 65, 86, 19, 91, 90, 19, 71, 93, 93, 19, 71, 64, 19, 19, 67, 92, 86, 94, 91, 94, 90, 93, 94, 93, 19, 82, 19, 19, 19, 64, 86, 95, 19, 65, 65, 88, 82, 90, 19, 87, 87, 19, 86, 90, 82, 85, 67] # first = [49, 104, 104, 44, 45, 104, 32, 45, 41, 39, 32, 36, 61, 45, 58, 58, 104, 66, 45, 104, 45, 41, 28, 41, 58, 66, 104, 39, 41, 60, 32, 104, 59, 66, 39, 58, 58, 45, 45, 41, 38, 47, 45, 47, 39, 58, 41, 60, 33, 60, 104, 104, 39, 45, 33, 38, 36, 60, 59, 45, 33, 37, 104, 59, 37, 29, 0] # first = [119, 35, 93, 37, 54, 3, 50, 59, 57, 119, 50, 119, 119, 119, 54, 60, 36, 56, 57, 39, 119, 36, 63, 35, 50, 62, 54, 35, 58, 63, 50, 32, 46, 32, 35, 36, 50, 119, 37, 35, 57, 119, 57, 123, 49, 36, 35, 63, 58, 37, 93, 36, 49, 119, 52, 56, 119, 112, 62, 119, 57, 56, 36, 119, 50, 102, 100] # first = [57, 56, 49, 49, 51, 56, 112, 38, 112, 51, 34, 36, 61, 57, 57, 57, 51, 37, 112, 49, 49, 63, 53, 112, 52, 36, 62, 112, 53, 53, 57, 53, 61, 53, 53, 112, 54, 57, 112, 53, 53, 50, 37, 112, 112, 113, 112, 53, 49, 49, 61, 53, 112, 32, 49, 39, 35, 35, 52, 63, 55, 34, 49, 36, 43, 123, 34] # first = [87, 92, 25, 78, 81, 80, 86, 92, 88, 86, 25, 92, 88, 77, 87, 87, 92, 77, 64, 80, 75, 87, 25, 78, 25, 23, 90, 81, 25, 64, 75, 75, 84, 75, 87, 86, 86, 87, 51, 21, 75, 92, 25, 51, 78, 51, 64, 25, 94, 80, 80, 92, 64, 75, 85, 87, 64, 25, 92, 95, 25, 92, 84, 81, 97, 13, 68] # first = [65, 65, 17, 8, 65, 18, 3, 18, 13, 13, 2, 2, 24, 77, 65, 6, 15, 65, 14, 15, 4, 18, 107, 4, 21, 65, 4, 0, 7, 65, 65, 4, 4, 4, 21, 19, 19, 65, 2, 65, 65, 8, 14, 9, 14, 53, 14, 12, 8, 6, 5, 65, 14, 4, 79, 65, 12, 107, 18, 65, 13, 65, 4, 4, 81, 15, 107] # first = [57, 61, 57, 54, 55, 120, 50, 116, 43, 55, 55, 48, 120, 120, 82, 120, 61, 43, 45, 44, 120, 120, 62, 127, 55, 23, 43, 46, 55, 51, 82, 120, 44, 120, 49, 120, 61, 48, 48, 59, 55, 54, 62, 45, 52, 57, 45, 49, 54, 48, 60, 58, 45, 44, 120, 57, 53, 47, 120, 44, 49, 55, 118, 120, 42, 60] # first = [5, 27, 30, 16, 3, 20, 18, 87, 24, 5, 26, 25, 25, 21, 30, 21, 4, 14, 87, 30, 4, 17, 30, 5, 87, 2, 3, 18, 5, 25, 24, 21, 5, 3, 22, 7, 91, 22, 24, 22, 5, 16, 87, 25, 1, 28, 5, 5, 18, 3, 27, 24, 5, 3, 35, 4, 18, 31, 18, 31, 25, 5, 125, 17, 40, 83] # first = [38, 55, 60, 114, 58, 61, 49, 88, 114, 33, 34, 59, 61, 39, 33, 55, 114, 63, 62, 60, 55, 61, 32, 55, 62, 32, 61, 114, 114, 55, 37, 51, 59, 58, 62, 32, 114, 60, 61, 38, 114, 114, 51, 53, 55, 55, 114, 32, 114, 114, 55, 38, 114, 43, 58, 114, 38, 55, 59, 59, 55, 114, 1, 62, 59, 52] def test(char): for c in first: num = ord(char) ^ c if (num &amp;lt; 0x20 or 0x7f &amp;lt;= num) and num !</description>
    </item>
    
    <item>
      <title>Reverse from 0 to 1</title>
      <link>/post/reverse-from-0-to-1/</link>
      <pubDate>Fri, 15 Jan 2021 18:29:48 +0000</pubDate>
      
      <guid>/post/reverse-from-0-to-1/</guid>
      <description>内涵的软件 首先使用file命令，发现exe是32位的，将其拖入ida中
进入main函数
点击进入main0函数
可以看到一串v2字符串
结合程序运行时出现的文字：”这里本来应该是答案的“
猜测v2就是答案
直接提交
发现不对
将开头修改为flag
提交后直接通过
新年快乐 首先使用file命令查看exe文件信息，发现是32位
尝试运行发现是要求输入flag
拖入ida进行静态分析
发现只有一个start函数，ida各种报错，无法分析
猜测使用了upx壳
使用exeinfope软件进行查看，upx壳实锤
脱壳后再次拖入ida
发现v4为&amp;quot;HappyNewYear!&amp;quot;
对于输入v5，直接与v4进行strncmp的比较
因此只需要与v4相同即可
尝试后发现没问题
套上flag提交
成功
guessgame 使用软件，发现是一个猜数游戏
拖入ida分析
发现整个代码与flag没有任何关系，就是一个猜测随机数的游戏
于是猜测flag隐藏在字符串常量中
进入字符串常量最顶部，发现如下字符串：
BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}
即为flag
helloword 下载后发现是apk文件
首先将apk后缀更改为zip
解压后发现文件夹中含有一个classes.dex文件
使用dex2jar软件将其转换为jar文件
使用jd-gui.jar对其进行逆向分析
在源代码中有com.example.helloword文件夹，用过Java的都知道com.example是什么东西，因此进入该目录下，发现有个MainActivity.class文件，查看源代码，发现有个flag字符串并对其使用了一个比较方法(compareTo)，猜测这个就是需要的flag，提交后发现正确
xor 拖入ida进行静态分析，发现对输入进行了异或处理，处理结果符合某个特定的函数值即可求解
看到一个for循环，是对每个字符与前面一个字符进行异或
根据异或的性质可知，只需要再异或一次就能还原
所以从后往前进行异或
随便写个脚本计算一下：
#include &amp;lt;stdio.h&amp;gt; int main(){ char flag[35]; flag[0] = &amp;#39;f&amp;#39;; flag[1] = &amp;#39;\n&amp;#39;; flag[2] = &amp;#39;k&amp;#39;; flag[3] = &amp;#39;\f&amp;#39;; flag[4] = &amp;#39;w&amp;#39;; flag[5] = &amp;#39;&amp;amp;&amp;#39;; flag[6] = &amp;#39;O&amp;#39;; flag[7] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>AITMC-challenge</title>
      <link>/post/aitmc-challenge/</link>
      <pubDate>Wed, 09 Dec 2020 23:27:25 +0000</pubDate>
      
      <guid>/post/aitmc-challenge/</guid>
      <description>Quiz from bzb 前言&amp;amp;题目 前段时间学习信安数基，助教学长就配套出了道Quiz，来给我们练手。
先上题目
import math from AITMCLab.Crypto.Util.number import long_to_bytes from AITMCLab.Crypto.Util.number import bytes_to_long from AITMCLab.Crypto.Util.number import getRandomNBitInteger from AITMCLab.Crypto.Util.number import getPrime from AITMCLab.Crypto.Util.number import isPrime from AITMCLab.Crypto.Util.number import inverse from secret import flag def nextPrime(n): n += 2 if n &amp;amp; 1 else 1 while not isPrime(n): n += 2 return n def init(S, K): j = 0 k = [] K = list(K) for i in range(len(K)): K[i] = ord(K[i]) for i in range(256): S.</description>
    </item>
    
    <item>
      <title>Fabric-Architecture-and-SystemChaincode</title>
      <link>/post/fabric-architecture-and-systemchaincode/</link>
      <pubDate>Tue, 08 Dec 2020 01:33:07 +0000</pubDate>
      
      <guid>/post/fabric-architecture-and-systemchaincode/</guid>
      <description>参考文献：Hyperledger Fabric: A Distributed Operation System for Permissioned Blockchains
架构 整体结构 Fabric是一个许可区块链的分布式操作系统，可以执行多种编程语言编写的分布式应用。它能够在一个只能追加的数据结构中安全地跟踪执行历史，并且没有内置的加密账本。
Fabric使用了“执行-order-验证”的区块链架构，而没有遵顼标准的“order-执行”设计。其整体的分布式应用可以分为两个部分
  智能合约，称为链码 (Chaincode) ，是一段实现了应用逻辑的程序代码，并在执行过程中运行。链码是Fabric分布式应用的核心部分，可能会被未受信任的开发者修改。有一种特殊的链码被用于管理区块链系统并维护参数，被称为系统链码 (system chaincode)
  背书政策 (endorsement policy) 在验证阶段进行评价。许可政策无法被未受信任的开发者选择或修改。其在区块链中充当一个用于事物验证的静态库，且只能通过链码进行参数化。只有指定的管理员有权限使用系统管理功能修改。
  “执行-排序-验证”结构示意图：

一个客户端向背书政策指定的peer节点(peers)发送交易。这个交易被特殊的peer节点执行并且记录输出信息，这一步骤被称为背书。执行完成后，交易进入了排序(ordering)阶段，在这一个阶段中，使用了一种可插入的共识协议来产生一个完成排序的已背书交易的序列，并按区块分组。这些交易被广播到所有的节点。这个序列的顺序由输出和状态的依赖性决定。在验证阶段，每个peer节点都需要根据背书政策和执行的一致性对已背书交易的状态变化进行验证。所有peer节点都已相同的顺序进行验证，因此结果具有确定性。
Fabric网络支持多个区块链链接到同一个排序服务上。每个区块链被称为一个通道(Channel)，可以有不同的peer节点作为其成员。这些通道可以被用来分离不同的区块链之间的状态，但每个通道的共识并不一致，并且通道中的交易顺序是相互分开的。认为所有排序都是可信的部署，可以通过通道访问控制来实现对节点的控制。
其中的节点可分为：客户端、peer节点（其中一部分为背书节点）、排序服务节点(OSN, Ordering Service Nodes or orderers)
交易的三个阶段 transaction_flow
执行阶段 在执行阶段，客户端签署并发送一个交易提案给一个或多个背书节点来执行（根据背书政策，每个chaincode都有特定的一组背书节点）。一个交易提案包含了提交客户端的身份（根据MSP），交易的载荷、参数、链码标识符、每个客户端只能使用一次的nonce（随机值或计数器），以及客户端标识符和nonce生成的交易标识符。
背书节点会对交易提案进行模拟，在指定的区块链链码上执行操作。模拟操作在背书节点的本地区块链状态中进行模拟，不与其它节点同步，也不会将模拟的结果永久化到帐本中。区块链的状态仍然由节点交易管理器(Peer Transaction Manager)维护。一个链码创建的状态只能限定在该链码上，不能被其他的链码直接访问。需要注意的是，链码只能维护GetState、PutState、DelState操作访问的内容（可能意思是：需要使用这些接口进行访问，不能直接修改，猜测状态权限为private）。给予适当的权限，链码可以调用同一个通道的链码，并访问其状态。
在模拟后，背书节点会产生一个writeset，其中包括模拟产生的状态更新，和一个readset，代表交易提案模拟的版本依赖（模拟时的所有密钥以及对应的版本号）。在模拟结束后，背书节点会以加密的方式签署一份“背书”消息，包括了writeset和readset（包括交易id和背书节点的一些数据），随后以响应的方式发送给客户端。客户端收集背书，直到满足链码的背书政策，开始交易。特别的，这要求政策决定的所有背书节点都返回相同的writeset和readset。然后，客户端将继续创建交易，并传递给排序阶段。
排序阶段 客户端收集到足够的背书后，将会把交易组装起来并发送给排序服务端。整个交易包括了载荷(payload)（包括参数的链码操作）、交易元数据、背书的集合。排序阶段对每个通道的所有提交建立了一个排序。排序服务端会将多个交易分成块，输出包含交易的哈希链序列，以提高广播协议的吞吐量。
 broadcast(tx)：客户端调用这个函数来广播交易tx，包含了载荷和签名。 B $\leftarrow$ deliver(s)：客户端调用这个函数来获取非负序列号s的区块B，$B=([tx_1,tx_2,\ldots,tx_k],h)$，$h$为s-1区块的哈希值。  排序服务确保了一个通道中的交付区块被完全排序，确保安全。
然而，每一个单独的排序实现都允许在客户端请求中保证自己的活跃性与公平性。
由于区块链中包含了大量的节点，但仅有少部分节点实现了排序服务，因此Fabric可以配置使用内置的gossip服务，将排序服务中交付的区块分发给所有的节点。
验证阶段 排序服务会把区块直接分发给各个节点（或通过gossip）。随后，一个新的区块进入验证阶段，包含三个连续步骤：
 并行执行区块中所有的交易的背书政策评估。评估是验证系统链码(VSCC, validation system chaincode)的任务。VSCC是一个静态库，是区块链配置的一部分，负责根据链码中的背书政策验证背书。如果不满足，这个交易会被标记为无效，并被忽略。 对块中的所有交易进行读写冲突检查(read-write conflict check)（版本号比较）。对于每个交易，将会对比其中readset的版本号和节点本地存储的账本当前状态中的版本号，确保版本相同。如果版本不匹配，交易会被标记为无效，并被忽略。 最后进行账本的更新阶段，在这个阶段，区块被追加到本地存储的账本中，并且更新区块链的状态。将区块添加到账本时，前两步的检查结果将被持久化以掩码的形式表示区块中的交易有效。这有助于后面进行重建状态。此外，所有的状态更新都是通过将writeset中的键值对写入本地完成的。  信任与故障模型 Fabric可以适应灵活的信任和故障假设。通常情况下，所有的客户端都被认为是潜在的恶意用户或是Byzantine。节点都被归入组织(organization)并且每个组织组成一个信任域(trust domain)。每个节点信任其组织内部的其他节点，而不信任其他组织的节点。排序服务同样认为所有的节点（或客户端）都是潜在的拜占庭。</description>
    </item>
    
    <item>
      <title>基物实验</title>
      <link>/post/jwsy/</link>
      <pubDate>Tue, 17 Nov 2020 23:16:05 +0000</pubDate>
      
      <guid>/post/jwsy/</guid>
      <description>分光仪 实验时间：2020年9月21日
这是我做的第一个实验，成功AK（手动狗头）
调整 第一步的粗调非常重要，决定了你接下来的调整速度。个人经验是在实验前千万不要去玩那些螺丝，也许上个人已经调好了，上来随便调一调就合格，可以直接做实验。
按照正常的方法去调整就行，遇到的唯一困难就是转180°后找不到绿十字了，这时可以考虑先用眼睛去找，确定了绿十字反射回来的位置之后再去调目镜和平台，后面按照视频里或者老师讲的做就可以，应该没什么难度。
测量三棱镜的顶角 这个实验还是挺水的。。。随便测测就行了。顶角是60°，测量结果应该是120°
最小偏向角法测量棱镜的折射率 这个实验最大的坑就是“最小偏向角”一定要旋转三棱镜的摆放位置，直到折射光的偏转最小。（折射光在右手边就让光尽可能靠左，左手边就尽可能靠右）
后面应该就不需要去动三棱镜了，钠光的入射光应该是可以找到的。
最终的测量结果应该在50°50′左右。
掠入射法测量棱镜的折射率 当时做这个实验的时候主要是不知道怎么摆放。。。好在最后找了个做过的大佬，画了个草图。

最终的测量结果应该在39°左右。
如果时间不够用的话，一个省时间的技巧是在测下一组数据的时候不动目镜，只转动刻度盘，这样就可以少调整一次。（如果彻底没有时间了，那就测量一组，然后写到第五组的位置上，剩下的数据全靠编。我室友就这么硬水过的。。。）
干涉法测平板玻璃折射率 这个实验做了也不算积分，而且至少要1小时的时间，所以就没做（也没人做）。
示波器 实验时间：2020年10月26日
做的第一个非光学实验（绪论除外），没能AK，后面就决定重回光学的怀抱了。
示波器的使用 这个还是挺简单的，但建议速度一定要快，给后面两个实验留点时间。
需要注意的是，这个实验老师是会查现象的，所以最好不要尝试去水。其实水的目的不是混分，都是现象做出来了，只是时间不够时的一个手段而已，非常不建议滥用，毕竟做出实验现象还是很爽的。
二极管伏安特性曲线 当时按照电路图连了电路，结果发现线貌似不够用，打算先测量声速。
然后就没有然后了
声速测量 测量声速的时候遇到了好几个坑。
 实验前和实验后一定要记得调整频率，使得振幅最大，并记录下来。 实验的线材和器材有毒，各种连接不稳定，最后是用笔袋支撑着线才能做实验的。 我当时老师要求振幅法和李萨如法都要用，很耽误时间，建议先做第二个实验。不过我当时的老师人比较好，让我们几个人拖延了一会，硬是把数据记完了，而且没有查实验器材。  迈克尔逊干涉 实验时间：2020年11月9日
第二个光学实验，也AK了。让人不禁感叹，光学实验真的是适合刷积分啊。
迈克尔逊干涉 这个实验老师会讲好久（但里面有不少干货，建议认真听），我当时足足讲了1小时20分钟，讲到最后我都直接开激光偷偷调整了。
整个调整步骤有四步，一步一步来就行，别忘了第一步是调激光入射光就行（我做完实验才发现这个事情，还好最后没出现问题）。如果发现自己找不到水平一排的三个亮点，可能是入射光没有完全射到各个镜子上，调整的时候出现问题了还是动脑子想一想吧，毕竟遇到的问题真的是各种各样的都有。
如果发现迈克尔逊环很密的话，可能是反射镜位置不太对，调整到老师推荐的位置，然后拧一拧应该就能出来。
装置的空程差真的让人绝望，我一开始大概转了60圈才消除掉，
数的时候真的可能会数错。。。建议十个十个数。技巧就是一定要数内缩环，外扩真的纠结应该数到哪里。
牛顿环干涉 感觉牛顿环是最简单的实验了，只需要调好反射镜的位置和目镜的高度就行。重点是不要数错环，我当时是从11数到20。。。建议从6数到15。
数错了重新数其实也浪费不了多少时间，如果懒的话就继续编数据大法吧。。。
劈尖干涉 这个实验的劈尖干涉应该是来得及做的，我当时最后有几十分钟的时间来纠结应该怎么做（其实想法一直都没问题，但我的仪器测量范围有问题，浪费了巨量时间）。当时认识的大佬没做这个实验，于是只能自己摸索了。下面是我总结的实验步骤。
  本实验的样本无须自己制作。
  做实验过程中遇到的唯一障碍在于测量“细丝位置到尖端的距离”。我遇到的样本为一张纸，因此与图片中的细丝有些小差别。实际操作中的装置如下图所示（左侧是尖端，右侧的小横线是纸张）。图片中的L就是需要测量的部分。具体做法大致就是把装置侧过来，显微镜对焦，然后从尖端量到纸张即可。

  我用的仪器貌似有问题。。。小于25mm的部分手轮转不过去，最后还是借室友的仪器做的&amp;hellip;&amp;hellip;
  在测量干涉条纹宽度时，显微镜物镜可能会被螺丝卡住，建议把装置倒过来测量，把四个突出来的螺丝放在下面当支柱。。。
  我的测量结果是$L\approx39\ \mathrm{mm}$, $n=5$时$l\approx5.6\ \mathrm{mm}$。反正最后处理时别忘了还有个$n$就行，刚开始算出来的结果给我人都看傻了，最后算的大概是$50\mu m$，感觉小了一些，不过至少还有点靠谱。</description>
    </item>
    
    <item>
      <title>My Latex Cheatsheet</title>
      <link>/post/my-latex-cheatsheet/</link>
      <pubDate>Sun, 15 Nov 2020 23:45:58 +0000</pubDate>
      
      <guid>/post/my-latex-cheatsheet/</guid>
      <description>标题及基础设置 \documentclass[a4paper, zihao=-4, UTF8]{ctexart} \CTEXsetup[format={\Large\bfseries}]{section} \title{} \author{} \date{} \pagesytle{} %\setcounter{section}{-1} % section start from 0  \begin{document} \maketitle \section{} \section[short title]{} \label{sec:section_with_short_title} section \ref{sec:section_with_short_title} is a section with a short title. %交叉引用 	\section*{} \subsection{} \subsection*{} \subsubsection{} \subsubsection*{} \paragraph{} \par \end{document} 数学符号 常用数学符号    Code Latex Code Latex     \because $\because$ \therefore $\therefore$   \frac{a}{b} $\frac{a}{b}$ \dfrac{a}{b} $\dfrac{a}{b}$   \cdot $\cdot$ \cdots $\cdots$   \ldots $\ldots$ \infty $\infty$   \log $\log$ \lim $\lim$   \sin $\sin$ \cos $\cos$   \rightarrow $\rightarrow$ \int_{0}^{1} $\int_{0}^{1}$   \iint $\iint$ \oint $\oint$   \oiint $\oiint$ \iiint $\iiint$   \in $\in$ \notin $\notin$   \forall $\forall$ \exist $\exist$   \sqrt{a} $\sqrt{a}$ \exist $\exist$   \neg $\neg$ \oplus $\oplus$    \sum\limits\_{i=1}^{10}: $\sum\limits_{i=1}^{10}$</description>
    </item>
    
  </channel>
</rss>
