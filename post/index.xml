<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on s0uthwood&#39;s Blog</title>
    <link>/post/</link>
    <description>Recent content in Posts on s0uthwood&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Dec 2021 19:37:54 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>All Solves During a Weekend</title>
      <link>/post/all-solves-during-a-weekend/</link>
      <pubDate>Mon, 13 Dec 2021 19:37:54 +0000</pubDate>
      
      <guid>/post/all-solves-during-a-weekend/</guid>
      <description>打美团 CTF 的时候才意识到，有一种坐牢叫AK
 [MTCTF 4th]wow 先进行脱壳，因为脱壳后用的是绝对地址，而加载的时候是动态加载，所有没有办法调试，那就直接静态看吧
JUMPOUT 那里看一下汇编，发现有一个天堂之门
push 0x33 call $+5 add [esp+84h+var_84], 5 retf 直接把后面的数据全 dump 出来，然后用 ida64 打开
void __fastcall sub_0(unsigned int *a1) { unsigned int v1; // er9  int v2; // ebp  unsigned int v3; // esi  unsigned int *v4; // rdi  unsigned int *v5; // r10  unsigned int v6; // ebx  unsigned int i; // er11  unsigned int v8; // er8  int v9; // edx  unsigned int v10; // eax  unsigned int v11; // er9  unsigned int v12; // er8  int v13; // ebx  int v14; // ebx  int v15; // ebx  int v16; // edx  unsigned int v17; // eax  unsigned int v18; // er9  v1 = a1[8]; v2 = 12; v3 = 0; while ( 1 ) { v3 += 1732584193; v4 = a1 + 1; v5 = a1; v6 = v3 &amp;gt;&amp;gt; 2; for ( i = 0; i &amp;lt; 8; ++i ) { v8 = *v4; if ( (((unsigned __int8)i ^ (unsigned __int8)v6) &amp;amp; 3) !</description>
    </item>
    
    <item>
      <title>DragonCTF Runofthemill Writeup</title>
      <link>/post/dragonctf-runofthemill-writeup/</link>
      <pubDate>Fri, 10 Dec 2021 02:01:06 +0000</pubDate>
      
      <guid>/post/dragonctf-runofthemill-writeup/</guid>
      <description>题目分析 获取输入
v1 = sys_read(0, byte_412000, 0x40uLL); 中间计算
byte_412000[42] = __ROR1__(byte_412000[42], 4); *(_DWORD *)&amp;amp;byte_412000[44] ^= 0x4EC10FC6u; *(_WORD *)&amp;amp;byte_412000[15] ^= 0xEBFFu; *(_DWORD *)&amp;amp;byte_412000[38] -= 1698263770; // 以下省略 最后的验证
v9 = byte_412000; v10 = byte_412050; v11 = 64LL; v12 = 0; do { v12 |= *v10++ ^ *v9++; --v11; } while ( v11 ); Angr求解 还是很容易看懂的，主要是如何求解
一种思路是把汇编反过来，pizza爷用的是这种做法，于是就写了个Angr喝茶去了
Angr用的是手动往全局变量注入符号，然后在验证前停止，手动添加约束，wp中的写法是直接用程序中的验证，并添加了 LAZY_SOLVES 参数，学到了
之前用自己脚本跑的适合发现一直是 unsat，以为Angr会有问题，但后来发现有个wp就是用的Angr
于是掏出了之前写的脚本做了一些尝试
from angr import * import claripy import binascii input_length = 56 base_addr = 0x400000 proj = Project(&#39;runofthemill&#39;, main_opts={&amp;quot;base_addr&amp;quot;: base_addr}) start_addr = 0x401054 state = proj.</description>
    </item>
    
    <item>
      <title>Learn Basic Signal from DNUICTF easyre</title>
      <link>/post/learn-basic-signal-from-dnuictf-easyre/</link>
      <pubDate>Thu, 09 Dec 2021 15:05:55 +0000</pubDate>
      
      <guid>/post/learn-basic-signal-from-dnuictf-easyre/</guid>
      <description>一些信号量函数的学习 信号量的注册在init函数中
v2.sa_handler = (__sighandler_t)sub_400E1D; v2.sa_flags = 4; sigaction(34, &amp;amp;v2, &amp;amp;v1); sigaction() 函数定义为
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); sigaction 结构体定义如下
struct sigaction { void (*sa_handler) (int); sigset_t sa_mask; int sa_flags; // 用来设置信号处理的相关操作  void (*sa_restorer) (void); } 关于 sa_flags 的定义如下 (from linux/include/uapi/asm-generic/signal-defs.h)
#ifndef SA_NOCLDSTOP #define SA_NOCLDSTOP	0x00000001 #endif #ifndef SA_NOCLDWAIT #define SA_NOCLDWAIT	0x00000002 #endif #ifndef SA_SIGINFO #define SA_SIGINFO	0x00000004 #endif /* 0x00000008 used on alpha, mips, parisc */ /* 0x00000010 used on alpha, parisc */ /* 0x00000020 used on alpha, parisc, sparc */ /* 0x00000040 used on alpha, parisc */ /* 0x00000080 used on parisc */ /* 0x00000100 used on sparc */ /* 0x00000200 used on sparc */ #define SA_UNSUPPORTED	0x00000400 #define SA_EXPOSE_TAGBITS	0x00000800 /* 0x00010000 used on mips */ /* 0x00800000 used for internal SA_IMMUTABLE */ /* 0x01000000 used on x86 */ /* 0x02000000 used on x86 */ /* * New architectures should not define the obsolete *	SA_RESTORER	0x04000000 */ #ifndef SA_ONSTACK #define SA_ONSTACK	0x08000000 #endif #ifndef SA_RESTART #define SA_RESTART	0x10000000 #endif #ifndef SA_NODEFER #define SA_NODEFER	0x40000000 #endif #ifndef SA_RESETHAND #define SA_RESETHAND	0x80000000 #endif 题目中使用的是 SA_SIGINFO，对信号处理程序提供了附加信息：一个指向 siginfo 结构的指针以及一个指向上下文标识符的指针</description>
    </item>
    
    <item>
      <title>Resent RE Challenge</title>
      <link>/post/resent-re-challenge/</link>
      <pubDate>Tue, 23 Nov 2021 14:06:23 +0000</pubDate>
      
      <guid>/post/resent-re-challenge/</guid>
      <description>[N1CTF 2021]babyrust [N1CTF 2021]Py [L3HCTF 2021]double-joy [L3HCTF 2021]Load [hack.lu]pycoin [hack.lu]atareee  TODO:
 [L3HCTF 2021]idaaaaaaaa  [N1CTF]babyrust 题目直接给了Rust源码，之前没有见过，现查文档学习
首先main函数里只是调用了一个 check!
let result = check!(@s /*your answer*/); main 上面就是 check 的实现
macro_rules! check { (@s n1ctf{$Never:tt}) =&amp;gt; { check!(stringify!($Never)) }; macro_rules! 是个宏定义，里面的 @s，@e 应该是类似字符串匹配的东西
一开始的 (@s n1ctf{$Never:tt}) 就把flag中去除 n1ctf{} 的部分存到了 $Never 变量中，stringify! 将其转换为字符串常量
 stringify! 为 Rust 内置宏。其接收一个 Rust 表达式，如 1 + 2 ， 然后在编译时将表达式转换为一个字符串常量，如 &amp;ldquo;1 + 2&amp;rdquo; 。
 接下来的宏定义有很多类似这个的：</description>
    </item>
    
    <item>
      <title>pbctf2021 RE writeups</title>
      <link>/post/pbctf2021-re-writeups/</link>
      <pubDate>Mon, 11 Oct 2021 16:07:41 +0000</pubDate>
      
      <guid>/post/pbctf2021-re-writeups/</guid>
      <description>cosmo main函数在 sub_403066
要求长度是38，简单看了一下加密逻辑，发现是两个字符一起加密并验证，还想用pintools试试，结果发现根本跑不起来
于是又开始了快乐的手写爆破，不过这个比较简单，动调一下就知道只用了最下面的几行加密逻辑
#include &amp;lt;stdio.h&amp;gt; long long qword_40C000[20] = { 21233875ll, 69468586ll, 146735755ll, 251265871ll, 379651085ll, 536872170ll, 719455639ll, 924911196ll, 1158088491ll, 1412368333ll, 1695680674ll, 2005272944ll, 2341407284ll, 2698316511ll, 3076262773ll, 3483634782ll, 3913551105ll, 72486322ll, 548474478ll, 0ll }; long long encrypt(char *a, int len, int cur){ int v5 = len; int res = 0; long long v3 = qword_40C000[cur - 1]; int v6 = v3 &amp;gt;&amp;gt; 16; int v7 = v3 &amp;amp; 0xffff; while(v5){ v7 += *a; v6 += v7; --v5; ++a; } if (v7 &amp;gt; 0xFFF0) v7 -= 0xFFF1; return v7 | ((v6 % 0xFFF1) &amp;lt;&amp;lt; 16); } int test_cnt(int cnt){ for (int i = 0x20; i &amp;lt; 0x80; i++){ for (int j = 0x20; j &amp;lt; 0x80; j++){ char a[] = {i, j}; if (encrypt(a, 2, cnt) == qword_40C000[cnt]){ printf(&amp;#34;%c%c&amp;#34;, i, j); return 0; } } } } int main(){ printf(&amp;#34;pbctf{&amp;#34;); for (int i = 3; i &amp;lt; 19; i++) test_cnt(i); printf(&amp;#34;\n&amp;#34;); return 0; } 除了找main函数之外也没有什么特别的</description>
    </item>
    
    <item>
      <title>TSGCTF2021 RE WP</title>
      <link>/post/tsgctf2021-re-wp/</link>
      <pubDate>Sat, 09 Oct 2021 22:22:33 +0000</pubDate>
      
      <guid>/post/tsgctf2021-re-wp/</guid>
      <description>Beginners Rev 用 fork() 遍历了 32 位输入，每个输入都分别进行一次函数运算
do { ++v2; if ( !fork() ) { v2 = 0; v1 |= 1 &amp;lt;&amp;lt; v3; v7 = open(&amp;#34;/dev/null&amp;#34;, 1); dup2(v7, 1); } ++v3; } while ( v3 != 5 ); 每个函数运算都是将输入迭代好多次
v4 = (unsigned __int8 *)&amp;amp;key + a2; v5 = v4[2]; v6 = 1; while ( (unsigned int)(-1217102449 * v5 + 1217102449) &amp;gt; 0xB2927C ) { ++v6; v5 += v4[2]; if ( v6 == 367 ) { v6 = -1; break; } } v7 = v4[4]; v8 = v4[3] * ((a1 + *v4) % 367 * v4[1] % 367 * v6 % 367) % 367; 被retaddr坑了一会，后面才反应过来开头那个 if ( retaddr - (_BYTE *)check !</description>
    </item>
    
    <item>
      <title>angr ctf writeup</title>
      <link>/post/angr-ctf-writeup/</link>
      <pubDate>Mon, 27 Sep 2021 21:03:03 +0000</pubDate>
      
      <guid>/post/angr-ctf-writeup/</guid>
      <description>&lt;p&gt;开始学angr&lt;/p&gt;
&lt;p&gt;&lt;del&gt;就是在抄solution&lt;/del&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DASCTF 2021-09 Writeup</title>
      <link>/post/dasctf-2021-09-writeup/</link>
      <pubDate>Sun, 26 Sep 2021 00:10:18 +0000</pubDate>
      
      <guid>/post/dasctf-2021-09-writeup/</guid>
      <description>[RE]ea5ycpp 一开始还被逻辑绕了一下，结果发现核心部分就是brainfuck
有一些结构体，可以恢复一下，会比较好看
brainfuck解析出来就是简单的加减法
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; unsigned char a[9999]; int c; int main(int argc, char **argv) { a[24] += 2; while (a[24]) { ++a[0]; --a[24]; } a[24] += 3; while (a[24]) { ++a[1]; --a[24]; } a[24] += 4; while (a[24]) { ++a[2]; --a[24]; } a[24] += 5; while (a[24]) { ++a[3]; --a[24]; } a[24] += 6; while (a[24]) { ++a[4]; --a[24]; } a[24] += 7; while (a[24]) { ++a[5]; --a[24]; } a[24] += 8; while (a[24]) { ++a[6]; --a[24]; } a[24] += 9; while (a[24]) { ++a[7]; --a[24]; } a[24] += 10; while (a[24]) { ++a[8]; --a[24]; } a[24] += 11; while (a[24]) { ++a[9]; --a[24]; } a[24] += 12; while (a[24]) { ++a[10]; --a[24]; } a[24] += 13; while (a[24]) { ++a[11]; --a[24]; } a[24] += 14; while (a[24]) { ++a[12]; --a[24]; } a[24] += 15; while (a[24]) { ++a[13]; --a[24]; } a[24] += 16; while (a[24]) { ++a[14]; --a[24]; } a[24] += 18; while (a[24]) { ++a[15]; --a[24]; } a[24] += 19; while (a[24]) { ++a[16]; --a[24]; } a[24] += 20; while (a[24]) { ++a[17]; --a[24]; } a[24] += 21; while (a[24]) { ++a[18]; --a[24]; } a[24] += 22; while (a[24]) { ++a[19]; --a[24]; } a[24] += 23; while (a[24]) { ++a[20]; --a[24]; } a[24] += 24; while (a[24]) { ++a[21]; --a[24]; } a[24] += 25; while (a[24]) { ++a[22]; --a[24]; } a[24] += 26; while (a[24]) { ++a[23]; --a[24]; } return 0; } 根据字符串就能看到比较的位置，密文减一下就行</description>
    </item>
    
    <item>
      <title>加密与解密学习笔记（持续更新ing）</title>
      <link>/post/note-of-book-encryption-and-decryption/</link>
      <pubDate>Sat, 25 Sep 2021 02:15:45 +0000</pubDate>
      
      <guid>/post/note-of-book-encryption-and-decryption/</guid>
      <description>&lt;p&gt;suibiankankan&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>BUUOJ RE (4) &amp;&amp; pycdc bugs</title>
      <link>/post/buuoj-re-4-pycdc-bugs/</link>
      <pubDate>Tue, 21 Sep 2021 00:39:52 +0000</pubDate>
      
      <guid>/post/buuoj-re-4-pycdc-bugs/</guid>
      <description>[FlareOn1]5get_it 给的是一个DLL文件（没记错的话），应该是用来钩取键盘输入的，根据不同的输入执行不同的内容，观察到有个函数为 sub_10001240，执行成功就说明通过了
查找引用
const char *sub_10009AF0() { if ( dword_100194FC &amp;gt; 0 ) { _cfltcvt_init(); sub_10001240(); } return &amp;#34;m&amp;#34;; } 要求让内存中一个数不为0，根据这个数再向上找
const char *sub_10009B60() { if ( dword_1001947C &amp;lt;= 0 ) { if ( dword_10019490 &amp;lt;= 0 ) { if ( dword_100194E0 &amp;lt;= 0 ) { if ( dword_100194EC &amp;lt;= 0 ) { if ( dword_100194F8 &amp;lt;= 0 ) { _cfltcvt_init(); } else { dword_100194F8 = 0; dword_100194FC = 1; } } else { dword_100194EC = 0; dword_100194F0 = 1; } } else { dword_100194E0 = 0; dword_100194E4 = 1; } } else { dword_10019490 = 0; dword_10019494 = 1; } } else { dword_1001947C = 0; dword_10019480 = 1; } return &amp;#34;o&amp;#34;; } 看到最里面就是赋值为1，所以最后两位输入就是 om</description>
    </item>
    
    <item>
      <title>BUUOJ RE (3)</title>
      <link>/post/buuoj-re-3/</link>
      <pubDate>Thu, 19 Aug 2021 19:11:32 +0000</pubDate>
      
      <guid>/post/buuoj-re-3/</guid>
      <description>[FBCTF]go_get_the_flag 没想到能在第五页见到memequal的题，真正的baby
[Zer0pts2020]QR Puzzle 文件处理 QR文件是25*25的字符串，每一位都是字符0或1
key文件每一行格式为 a#(b,c)，最后存储到链表中，末尾在前，具体结构为 int b, int c, int a, 0, *next
加密算法分析 从加密函数来看，应该是一个vm
简单整理一下
void __fastcall sub_400BD0(__int64 a1, int *a2) { int v2; // er8  int v3; // edx  _QWORD *v4; // r9  _QWORD *v5; // rcx  int v6; // er9  __int64 v7; // rax  __int64 v8; // rcx  while ( a2 ) { x = a2[2]; y = a2[0]; z = a2[1]; if ( x == 1 ) { v2 = z; v3 = y + 1; goto LABEL_4; } if ( x == 0 ) { v2 = z; v3 = y - 1; goto LABEL_4; } if ( x == 3 ) { v2 = z + 1; v3 = y; goto LABEL_4; } if ( x == 2 ) { v2 = z - 1; v3 = y; } LABEL_4: v4 = &amp;amp;a1[z]; v5 = &amp;amp;a1[v2]; *(_BYTE *)(v7 + *v4) += *(_BYTE *)(*v5 + v3); *(_BYTE *)(v3 + *v5) = *(_BYTE *)(*v4 + v7) - *(_BYTE *)(v3 + *v5); *(_BYTE *)(*v4 + v7) -= *(_BYTE *)(*v5 + v3); // 经典swap  a2 = (int *)*((_QWORD *)a2 + 2); // a2 = a2-&amp;gt;next  } } 显然加密就是和周围某个位置交换一下</description>
    </item>
    
    <item>
      <title>dfjk 2021 RE</title>
      <link>/post/2021dfjk-re/</link>
      <pubDate>Wed, 04 Aug 2021 13:48:58 +0000</pubDate>
      
      <guid>/post/2021dfjk-re/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;RE1：迷宫&lt;/li&gt;
&lt;li&gt;RE2：so层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一个好像是php？告辞&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CISCN-N 2021 RE Writeup</title>
      <link>/post/ciscn-n-2021-re-writeup/</link>
      <pubDate>Tue, 22 Jun 2021 23:25:43 +0000</pubDate>
      
      <guid>/post/ciscn-n-2021-re-writeup/</guid>
      <description>imnotavirus 解exe，解密pyc
利用解密后的pyc，找到注入的shellcode，用ida解smc，最后解密
比赛的时候还被迫阅读了一下pyinstaller的源码，收获很大
解exe 看到附件给了个pyinstaller，猜测是python逆向
先ida看一眼，有upx壳，自动脱壳，再用exeinfo确认了一下是python逆向，pyinstxtractor.py解包（之前V&amp;amp;N2021就吃了这个亏）
解pyc 解包时提示被加密了
取struct头作为标准头，用pycdc还原出main.py，发现调用了sign
去PYZ00文件夹看一下，发现被加密了，看一下目录，发现pyimod和比一般情况多了一些东西，把这些都解开看一下，有一个key文件
同时发现archive中有一个Cipher类，但是pycdc缺少指令，无法全部还原，考虑看一下pycdas解出来的字节码
字节码中有个对pyinstaller源码的引用，直接去文件夹里面看，发现能解密出来的部分完全一致
照着源码中的方法解密sign
from key import key import tinyaes print (key) f = open(&amp;#39;./PYZ-00.pyz_extracted/sign.pyc.encrypted&amp;#39;, &amp;#39;rb&amp;#39;) data = f.read() cipher = tinyaes.AES(key.encode(), data[:16]) output = cipher.CTR_xcrypt_buffer(data[16:]) f.close() import zlib output = zlib.decompress(output) f = open(&amp;#39;./sign.pyc&amp;#39;, &amp;#39;wb&amp;#39;) f.write(output) 解密 解出sign后看到有三个base64，其中两个是执行的语句，此外大部分语句涉及到了内存
另外一个base解出来是乱码，用字节码辅助恢复函数（其实特征已经很明显了），发现进行了rc4加密，直接打印出解密结果，将结果写入文件，用ida查看
发现smc
mov eax, 41178Bh mov ecx, 411802h sub ecx, eax loc_2A: mov ebx, [rax] xor ebx, 77h mov [rax], ebx loop loc_2A 解出来后尝试恢复了一下函数，结果很丑&amp;hellip;只能和汇编比较着进行分析了（好像只要把00 patch一下就可以反编译了）</description>
    </item>
    
    <item>
      <title>BUUOJ RE (2)</title>
      <link>/post/buuoj-re-2/</link>
      <pubDate>Thu, 10 Jun 2021 03:20:33 +0000</pubDate>
      
      <guid>/post/buuoj-re-2/</guid>
      <description>firmware 一道水题，主要学习一下工控逆向
不难看出，给的附件是squashfs文件，直接进行binwalk
 在安装sasquatch时遇到了一些坑，好像必须clone到~/Downloads等文件夹内才行
 binwalk之后逛一下目录，能够找到一个叫做 backdoor 的二进制文件
目标是找到连接的ip和端口，进去找一找就能看到
[FlareOn4]greek_to_me 尝试运行一下，发现不能输入
逆向，发现127.0.0.1的字样，以及socket等明显的网络通信函数
直接运行的时候看一下主机端口，发现是 127.0.0.1:2222，用Windows下的nc连上去就可以进行调试了
SMC还是很明显的
发现解SMC时仅用了第一个字节，但由于不知道里面有什么，猜测可能是对后面的字节进行验证，所以决定将程序本地复现一下，爆破解SMC的密钥
#include &amp;lt;stdio.h&amp;gt; unsigned char ida_chars[] = { 0x33, 0xE1, 0xC4, 0x99, 0x11, 0x06, 0x81, 0x16, 0xF0, 0x32, 0x9F, 0xC4, 0x91, 0x17, 0x06, 0x81, 0x14, 0xF0, 0x06, 0x81, 0x15, 0xF1, 0xC4, 0x91, 0x1A, 0x06, 0x81, 0x1B, 0xE2, 0x06, 0x81, 0x18, 0xF2, 0x06, 0x81, 0x19, 0xF1, 0x06, 0x81, 0x1E, 0xF0, 0xC4, 0x99, 0x1F, 0xC4, 0x91, 0x1C, 0x06, 0x81, 0x1D, 0xE6, 0x06, 0x81, 0x62, 0xEF, 0x06, 0x81, 0x63, 0xF2, 0x06, 0x81, 0x60, 0xE3, 0xC4, 0x99, 0x61, 0x06, 0x81, 0x66, 0xBC, 0x06, 0x81, 0x67, 0xE6, 0x06, 0x81, 0x64, 0xE8, 0x06, 0x81, 0x65, 0x9D, 0x06, 0x81, 0x6A, 0xF2, 0xC4, 0x99, 0x6B, 0x06, 0x81, 0x68, 0xA9, 0x06, 0x81, 0x69, 0xEF, 0x06, 0x81, 0x6E, 0xEE, 0x06, 0x81, 0x6F, 0xAE, 0x06, 0x81, 0x6C, 0xE3, 0x06, 0x81, 0x6D, 0xEF, 0x06, 0x81, 0x72, 0xE9, 0x06, 0x81, 0x73, 0x7C }; #define HIBYTE(x) ((x &amp;amp; 0xFF00) &amp;gt;&amp;gt; 8)  int main(){ for (unsigned short buf = 0; buf &amp;lt;= 0xff; buf++){ unsigned char new_char[130]; unsigned char *a1 = new_char; unsigned int i = 0; do { *a1 = (buf ^ ida_chars[i++]) + 34; ++a1; } while ( i &amp;lt; 121 ); unsigned int v2 = 0x79; // 0x79  a1 = new_char; unsigned short v3 = 255; for ( i = 255; v2; v3 = HIBYTE(v3) + (unsigned char)v3 ) { unsigned short v5 = i; int v6 = v2; if ( v2 &amp;gt; 0x14 ) v6 = 0x14; v2 -= v6; do { v5 += *a1; v3 += v5; ++a1; --v6; } while ( v6 ); i = HIBYTE(v5) + (unsigned char)v5; } int ret = (HIBYTE(i) + (unsigned char)i) | ((v3 &amp;lt;&amp;lt; 8) + (v3 &amp;amp; 0xFF00)); // if (buf == &amp;#39;f&amp;#39;)  // printf(&amp;#34;%x\n&amp;#34;, ret); // 0xf51c  // if (buf == &amp;#39;@&amp;#39;)  // printf(&amp;#34;%x\n&amp;#34;, ret); // 0x60ee  if (ret == 0xFB5E) { printf(&amp;#34;%d\n&amp;#34;, buf); break; } // printf(&amp;#34;%c %x\n&amp;#34;, buf, ret);  } } 一开始给的范围小了（以为会是可见字符），一直爆破不出来，反复验证了好多次，后来才发现范围是 0-0xff</description>
    </item>
    
    <item>
      <title>BUUOJ RE (1)</title>
      <link>/post/buuoj-re-1/</link>
      <pubDate>Wed, 26 May 2021 23:54:09 +0000</pubDate>
      
      <guid>/post/buuoj-re-1/</guid>
      <description>[NPUCTF2020]BasicASM 纯考察汇编的题目，有考虑想办法改成正确的汇编形式然后编译用ida看，但感觉就失去意义了，于是硬啃汇编
00007FF7A8AC5A50 push rbp 00007FF7A8AC5A52 push rdi 00007FF7A8AC5A53 sub rsp,238h 00007FF7A8AC5A5A lea rbp,[rsp+20h] 00007FF7A8AC5A5F mov rdi,rsp 00007FF7A8AC5A62 mov ecx,8Eh 00007FF7A8AC5A67 mov eax,0CCCCCCCCh 00007FF7A8AC5A6C rep stos dword ptr [rdi] 00007FF7A8AC5A6E mov rax,qword ptr [__security_cookie (07FF7A8AD3018h)] 00007FF7A8AC5A75 xor rax,rbp 00007FF7A8AC5A78 mov qword ptr [rbp+208h],rax 00007FF7A8AC5A7F lea rcx,[__06A15900_ConsoleApplication@cpp (07FF7A8AD902Ah)] 00007FF7A8AC5A86 call __CheckForDebuggerJustMyCode (07FF7A8AC1122h) 00007FF7A8AC5A8B lea rdx,[string &amp;quot;flag{this_is_a_fake_flag}&amp;quot; (07FF7A8ACF450h)] 00007FF7A8AC5A92 lea rcx,[flag] 00007FF7A8AC5A96 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt; (07FF7A8AC15E1h) 00007FF7A8AC5A9B nop 00007FF7A8AC5A9C mov dword ptr [p],0 00007FF7A8AC5AA3 mov i,0 00007FF7A8AC5AAA jmp main+64h (07FF7A8AC5AB4h) 00007FF7A8AC5AAC mov eax,i 00007FF7A8AC5AAF inc eax 00007FF7A8AC5AB1 mov i,eax 00007FF7A8AC5AB4 movsxd rax,i 00007FF7A8AC5AB8 mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5ABF lea rcx,[flag] 00007FF7A8AC5AC3 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::length (07FF7A8AC122Bh) 00007FF7A8AC5AC8 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5ACF cmp rcx,rax 00007FF7A8AC5AD2 jae main+1B2h (07FF7A8AC5C02h) ; 无符号数比较，大于或等于时跳转 00007FF7A8AC5AD8 mov eax,i 00007FF7A8AC5ADB and eax,1 ; 取最后1位 00007FF7A8AC5ADE cmp eax,1 ; 判断奇偶 00007FF7A8AC5AE1 jne main+126h (07FF7A8AC5B76h) ; 偶数跳转（不相等跳转） 00007FF7A8AC5AE7 movsxd rax,i 00007FF7A8AC5AEB mov rdx,rax 00007FF7A8AC5AEE lea rcx,[flag] 00007FF7A8AC5AF2 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5AF7 movsx eax,byte ptr [rax] ; 取flag第i位 00007FF7A8AC5AFA xor eax,42h ; 与0x42异或 00007FF7A8AC5AFD mov dword ptr [p],eax ; 异或结果移到内存中 00007FF7A8AC5B00 mov dl,30h 00007FF7A8AC5B02 lea rcx,[rbp+144h] 00007FF7A8AC5B09 call std::setfill&amp;lt;char&amp;gt; (07FF7A8AC1046h) ; 用字符&#39;0&#39;进行填充 00007FF7A8AC5B0E mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5B15 mov edx,2 00007FF7A8AC5B1A lea rcx,[rbp+168h] 00007FF7A8AC5B21 call std::setw (07FF7A8AC10D2h) ; 填充至2位 00007FF7A8AC5B26 mov qword ptr [rbp+200h],rax 00007FF7A8AC5B2D lea rdx,[std::hex (07FF7A8AC1488h)] ; 以十六进制形式输出 00007FF7A8AC5B34 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5B3B call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7160h)] 00007FF7A8AC5B41 mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5B48 mov rdx,rcx 00007FF7A8AC5B4B mov rcx,rax 00007FF7A8AC5B4E call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,__int64&amp;gt; (07FF7A8AC12F8h) 00007FF7A8AC5B53 mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5B5A mov rdx,rcx 00007FF7A8AC5B5D mov rcx,rax 00007FF7A8AC5B60 call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,char&amp;gt; (07FF7A8AC11A4h) 00007FF7A8AC5B65 mov edx,dword ptr [p] 00007FF7A8AC5B68 mov rcx,rax 00007FF7A8AC5B6B call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7158h)] 00007FF7A8AC5B71 jmp main+1ADh (07FF7A8AC5BFDh) 00007FF7A8AC5B76 movsxd rax,i ; 偶数时跳转到这里，与奇数唯一的区别为没有异或运算 00007FF7A8AC5B7A mov rdx,rax 00007FF7A8AC5B7D lea rcx,[flag] 00007FF7A8AC5B81 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::operator[] (07FF7A8AC1442h) 00007FF7A8AC5B86 movsx eax,byte ptr [rax] 00007FF7A8AC5B89 mov dword ptr [p],eax 00007FF7A8AC5B8C mov dl,30h 00007FF7A8AC5B8E lea rcx,[rbp+194h] 00007FF7A8AC5B95 call std::setfill&amp;lt;char&amp;gt; (07FF7A8AC1046h) 00007FF7A8AC5B9A mov qword ptr [rbp+1F8h],rax 00007FF7A8AC5BA1 mov edx,2 00007FF7A8AC5BA6 lea rcx,[rbp+1B8h] 00007FF7A8AC5BAD call std::setw (07FF7A8AC10D2h) 00007FF7A8AC5BB2 mov qword ptr [rbp+200h],rax 00007FF7A8AC5BB9 lea rdx,[std::hex (07FF7A8AC1488h)] 00007FF7A8AC5BC0 mov rcx,qword ptr [__imp_std::cout (07FF7A8AD71C0h)] 00007FF7A8AC5BC7 call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7160h)] 00007FF7A8AC5BCD mov rcx,qword ptr [rbp+200h] 00007FF7A8AC5BD4 mov rdx,rcx 00007FF7A8AC5BD7 mov rcx,rax 00007FF7A8AC5BDA call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,__int64&amp;gt; (07FF7A8AC12F8h) 00007FF7A8AC5BDF mov rcx,qword ptr [rbp+1F8h] 00007FF7A8AC5BE6 mov rdx,rcx 00007FF7A8AC5BE9 mov rcx,rax 00007FF7A8AC5BEC call std::operator&amp;lt;&amp;lt;&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,char&amp;gt; (07FF7A8AC11A4h) 00007FF7A8AC5BF1 mov edx,dword ptr [p] 00007FF7A8AC5BF4 mov rcx,rax 00007FF7A8AC5BF7 call qword ptr [__imp_std::basic_ostream&amp;lt;char,std::char_traits&amp;lt;char&amp;gt; &amp;gt;::operator&amp;lt;&amp;lt; (07FF7A8AD7158h)] 00007FF7A8AC5BFD jmp main+5Ch (07FF7A8AC5AACh) 00007FF7A8AC5C02 mov dword ptr [rbp+1E4h],0 00007FF7A8AC5C0C lea rcx,[flag] 00007FF7A8AC5C10 call std::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt;::~basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt; &amp;gt; (07FF7A8AC1302h) 00007FF7A8AC5C15 mov eax,dword ptr [rbp+1E4h] 00007FF7A8AC5C1B mov edi,eax 00007FF7A8AC5C1D lea rcx,[rbp-20h] 00007FF7A8AC5C21 lea rdx,[__xt_z+540h (07FF7A8ACEFE0h)] 00007FF7A8AC5C28 call _RTC_CheckStackVars (07FF7A8AC1596h) 00007FF7A8AC5C2D mov eax,edi 00007FF7A8AC5C2F mov rcx,qword ptr [rbp+208h] 00007FF7A8AC5C36 xor rcx,rbp 00007FF7A8AC5C39 call __security_check_cookie (07FF7A8AC1190h) 00007FF7A8AC5C3E lea rsp,[rbp+218h] 00007FF7A8AC5C45 pop rdi 00007FF7A8AC5C46 pop rbp 00007FF7A8AC5C47 ret 简单的说，过程就是一个循环，根据 i 的奇偶进行判断，是否与 0x42 进行异或，然后将结果以 2 位十六进制输出，所以只需要进行反向求解即可</description>
    </item>
    
    <item>
      <title>cryptohack</title>
      <link>/post/cryptohack/</link>
      <pubDate>Thu, 20 May 2021 01:51:42 +0000</pubDate>
      
      <guid>/post/cryptohack/</guid>
      <description>Encoding Challenge Pwntools的简单使用
from pwn import * import json r = remote(&amp;#39;socket.cryptohack.org&amp;#39;, 13377) def json_recv(): line = r.recvline() return json.loads(line.decode()) def json_send(hsh): request = json.dumps(hsh).encode() r.sendline(request) ENCODINGS = [ &amp;#34;base64&amp;#34;, &amp;#34;hex&amp;#34;, &amp;#34;rot13&amp;#34;, &amp;#34;bigint&amp;#34;, &amp;#34;utf-8&amp;#34;, ] from base64 import b64decode import codecs from libnum import n2s for _ in range(100): received = json_recv() print(&amp;#34;Received type: &amp;#34;) print(received[&amp;#34;type&amp;#34;]) print(&amp;#34;Received encoded value: &amp;#34;) print(received[&amp;#34;encoded&amp;#34;]) i = ENCODINGS.index(received[&amp;#39;type&amp;#39;]) decoded = received[&amp;#39;encoded&amp;#39;] if i == 0: decoded = b64decode(decoded) decoded = str(decoded)[2:-1] elif i == 1: decoded = n2s(int(decoded, 16)) decoded = str(decoded)[2:-1] elif i == 2: decoded = codecs.</description>
    </item>
    
    <item>
      <title>CISCN2021 RE writeup</title>
      <link>/post/ciscn2021-re-writeup/</link>
      <pubDate>Thu, 20 May 2021 01:21:59 +0000</pubDate>
      
      <guid>/post/ciscn2021-re-writeup/</guid>
      <description>glass 安卓逆向，使用jeb打开，发现在java层仅进行了简单的输入，然后进入so层判断
用ida打开so层，直接搜索java，进入判断函数
下面的字符串应该是密钥
qmemcpy(v6, &amp;#34;12345678&amp;#34;, sizeof(v6)); 然后调用了三个函数
sub_FFC(v7, v6, v4); sub_1088(v7, flag, 39); sub_10D4(flag, 39, v6, v4); 进入查看，第一个是RC4密钥初始化，第二个是RC4加密，第三个是对密文进行简单的运算
从字符串里拿密文，写脚本进行求解，先对简单运算进行反向运算，然后找个RC4密码的脚本，跑一下就可以找到flag
cipher = [0xA3, 0x1A, 0xE3, 0x69, 0x2F, 0xBB, 0x1A, 0x84, 0x65, 0xC2, 0xAD, 0xAD, 0x9E, 0x96, 5, 2, 0x1F, 0x8E, 0x36, 0x4F, 0xE1, 0xEB, 0xAF, 0xF0, 0xEA, 0xC4, 0xA8, 0x2D, 0x42, 0xC7, 0x6E, 0x3F, 0xB0, 0xD3, 0xCC, 0x78, 0xF9, 0x98, 0x3F, 0] key = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38] def __rc4_init(key): keylength = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] return S def rc4_crypt(key, data): S = __rc4_init(key) i = j = 0 result = b&amp;#39;&amp;#39; for a in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] k = (a ^ S[(S[i] + S[j]) % 256]).</description>
    </item>
    
    <item>
      <title>津门杯 GoodRE writeup</title>
      <link>/post/jinmen-cup-goodre-writeup/</link>
      <pubDate>Mon, 10 May 2021 02:32:59 +0000</pubDate>
      
      <guid>/post/jinmen-cup-goodre-writeup/</guid>
      <description>&lt;p&gt;和两位学长一起做出来的，总算是能在团队赛中做出来题了，结束了长达一个月的白给生涯，不容易啊&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>hmg2021 RSA Attack writeup</title>
      <link>/post/hmg2021-rsa-attack-writeup/</link>
      <pubDate>Tue, 13 Apr 2021 21:39:43 +0000</pubDate>
      
      <guid>/post/hmg2021-rsa-attack-writeup/</guid>
      <description>已知一个 $1024$ 位的 $p1$，$p2$ 比 $p1$ 稍小，根据代码知道 $p3\equiv p2!\pmod{p1}$
根据 Wilson 定理，$n$ 为质数时有 $(n-1)!\equiv -1\pmod{n}$，所以 $p2! \prod\limits_{i=p2+1}^{p1-2}i\equiv 1\pmod{p1}$，所以可以计算出 $p2+1$ 乘到 $p1-1$ 的结果，然后取模拟并调用 sympy 库即可得到 $p3$
import sympy from libnum import invmod p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031 p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034 res = 1 for i in range(p2 + 1, p1 - 1): res = res * i % p1 res = invmod(res, p1) p3 = sympy.nextprime(res) p = p3 &amp;gt;&amp;gt; 50 &amp;lt;&amp;lt; 50 得到的 $p$ 是最终 RSA 加密用的 $P$ 的高位，因此可以使用 Factoring with High Bits Known 攻击，用 sage 构造如下攻击脚本（网上找的）</description>
    </item>
    
    <item>
      <title>BUUOJ RE (0) - FlareOn Challenge</title>
      <link>/post/buuoj-re0-flareon-challenge/</link>
      <pubDate>Fri, 09 Apr 2021 01:04:16 +0000</pubDate>
      
      <guid>/post/buuoj-re0-flareon-challenge/</guid>
      <description>Chanllenge1 一个修改了 table 的 Base64
import base64 import string fake_base = &amp;#39;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&amp;#39; true_base = string.ascii_uppercase + string.ascii_lowercase + string.digits + &amp;#39;+/&amp;#39; cipher = &amp;#39;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&amp;#39; good_cipher = &amp;#39;&amp;#39; for c in cipher: good_cipher += true_base[fake_base.index(c)] print (good_cipher) print (base64.b64decode(good_cipher)) Bob Doge 先运行测试一下，发现点击 Decode 之后是乱码
用 dnSpy 打开，找到 Main 函数
private static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } 发现只新建了一个 Form1
进入 Form1，找到带有 Click 的函数
private void btnDecode_Click(object sender, EventArgs e) { this.</description>
    </item>
    
    <item>
      <title>GWCTF2019 re3 writeup</title>
      <link>/post/gwctf2019-re3-writeup/</link>
      <pubDate>Thu, 08 Apr 2021 22:36:12 +0000</pubDate>
      
      <guid>/post/gwctf2019-re3-writeup/</guid>
      <description>静态分析 首先通过关键字符串 Wrong 进入 main 函数
void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-48h]  char s[40]; // [rsp+20h] [rbp-30h] BYREF  unsigned __int64 v5; // [rsp+48h] [rbp-8h]  v5 = __readfsqword(0x28u); __isoc99_scanf(&amp;#34;%39s&amp;#34;, s); if ( (unsigned int)strlen(s) != 32 ) { puts(&amp;#34;Wrong!&amp;#34;); exit(0); } mprotect(&amp;amp;dword_400000, 0xF000uLL, 7); for ( i = 0; i &amp;lt;= 223; ++i ) *((_BYTE *)sub_402219 + i) ^= 0x99u; sub_40207B((__int64)&amp;amp;unk_603170); sub_402219(); } 阅读一下代码，发现先是输入一个长度为32的字符串</description>
    </item>
    
    <item>
      <title>高校战役 re writeups</title>
      <link>/post/gxzy-re-writeups/</link>
      <pubDate>Wed, 31 Mar 2021 20:33:02 +0000</pubDate>
      
      <guid>/post/gxzy-re-writeups/</guid>
      <description>cycle graph 天津垓 fxck easyparser  cycle graph 逆向代码 根据提示，这是一道纯算法题，拖到 ida 中，根据关键字符串定位到关键函数。查看核心代码
dword_403370 = 0; v1 = &amp;amp;unk_403384; byte_403374 = 48; v2 = 0; dword_403378 = (int)&amp;amp;unk_403380; do { v3 = dword_402178[v2]; ++v2; *(v1 - 1) = v3; *v1 = (char *)&amp;amp;unk_403380 + 12 * dword_402274[v2]; v1[1] = (char *)&amp;amp;unk_403380 + 12 * dword_4021F4[v2]; v1 += 3; } while ( (signed int)v1 &amp;lt; (signed int)&amp;amp;unk_403504 ); 上面的代码是主函数开头的初始化部分
sub_401020(&amp;#34;You need a flag to get out of this:\n&amp;#34;, a1); scan(&amp;#34;%s&amp;#34;, &amp;amp;input); v4 = dword_403370; // 0  v5 = byte_403374; // 48  v6 = 5; v7 = dword_403378; do { v11 = *(&amp;amp;input + v6); if ( *(_DWORD *)v7 + v5 == v11 ) { v7 = *(_DWORD *)(v7 + 4); } else { if ( v5 - *(_DWORD *)v7 !</description>
    </item>
    
    <item>
      <title>VNCTF2021 FilpGame and notsudoku</title>
      <link>/post/vnctf2021-filpgame-and-notsudoku/</link>
      <pubDate>Thu, 25 Mar 2021 03:06:10 +0000</pubDate>
      
      <guid>/post/vnctf2021-filpgame-and-notsudoku/</guid>
      <description>notsudoku V&amp;amp;NCTF直接白给了，全程耗在了Crackme2上，辛辛苦苦找到密文和算法后发现需要动态调试？过程中not sudoku这题就扫了一眼，结果还没发现是python逆向，于是就爬爬了。
正文 好像是第一次做python exe的逆向
首先使用 exeinfo 差壳，发现有个 UPX
用 upx.exe -d 脱壳
比赛的时候没想到这个是python逆向，直接拖到ida里面了，于是直接gg
再使用 exeinfo 查一下，会发现是 pyinstaller 编译的文件，说明是python逆向
上网下载一下 pyinstxtractor.py 进行反编译
$ python3 pyinstxtractor.py notsudoku-noupx.exe 进入文件夹，找没有后缀的文件，发现有一个叫做 2 的，使用 010editor 从 struct 文件复制文件头（第一行），然后添加 .pyc 后缀，进行 pyc 反编译
$ uncompyle6 -o 2.py 2.pyc 即可得到 python 源码文件
发现文件里有一些日文，于是边阅读边修改就行
# uncompyle6 version 3.7.4 # Python bytecode 3.7 (3394) # Decompiled from: Python 3.6.9 (default, Jan 26 2021, 15:33:00)  # [GCC 8.4.0] # Embedded file name: 2.</description>
    </item>
    
    <item>
      <title>NepCTF2021 re writeups</title>
      <link>/post/nepctf2021-re-writeups/</link>
      <pubDate>Mon, 22 Mar 2021 18:30:03 +0000</pubDate>
      
      <guid>/post/nepctf2021-re-writeups/</guid>
      <description>hardsharp (.NET 逆向) 使用exeinfo发现是 C# .NET文件
直接用 dnSpy 打开
找到主函数
private static void Main(string[] args) { AesClass aesClass = new AesClass(); string text = &amp;#34;&amp;#34;; string strB = &amp;#34;1Umgm5LG6lNPyRCd0LktJhJtyBN7ivpq+EKGmTAcXUM+0ikYZL4h4QTHGqH/3Wh0&amp;#34;; byte[] array = new byte[] { 81, 82, 87, 81, 82, 87, 68, 92, 94, 86, 93, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 }; Console.WriteLine(&amp;#34;Welcome to nepnep csharp test!</description>
    </item>
    
    <item>
      <title>HGAME2021 Vernam and FAKE</title>
      <link>/post/hgame2021-vernam-and-fake/</link>
      <pubDate>Wed, 17 Mar 2021 20:06:09 +0000</pubDate>
      
      <guid>/post/hgame2021-vernam-and-fake/</guid>
      <description>对称之美 题目 Vernam 密码
import random import string import itertools from secret import FLAG key = &amp;#39;&amp;#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) cipher = bytes([ord(m)^ord(k) for m, k in zip(FLAG, itertools.cycle(key))]) print(cipher) 思路 由于给了大量的密文，完全可以对密钥空间进行范围上的缩小。
由于进行的是异或操作，且明文与密钥均为可见字符，只需要对相同位置的密文与所有可能的密钥字符进行异或计算，结果不在可见字符范围内的均可以排除掉。
经过初步筛选后密钥空间会小很多，进行爆破或者根据上下文手动选择即可。
代码 import string import itertools key = string.ascii_letters + string.digits # first = [94, 116, 57, 32, 54, 49, 33, 32, 54, 38, 116, 59, 37, 32, 32, 116, 60, 32, 57, 59, 51, 34, 38, 39, 116, 59, 116, 38, 60, 61, 35, 58, 39, 55, 59, 116, 49, 32, 48, 39, 55, 94, 59, 116, 38, 39, 116, 50, 59, 53, 48, 122, 60, 94, 116, 61, 54, 38, 38, 32, 39, 116, 56, 59, 53, 97, 1] # first = [35, 25, 21, 25, 17, 2, 28, 3, 5, 21, 17, 3, 5, 80, 80, 18, 25, 31, 21, 31, 94, 21, 80, 4, 24, 31, 17, 3, 17, 4, 80, 80, 25, 17, 3, 0, 9, 24, 9, 25, 24, 17, 30, 3, 9, 80, 17, 17, 2, 80, 31, 80, 80, 22, 3, 3, 25, 9, 21, 24, 80, 17, 21, 80, 23, 93, 62] # first = [78, 68, 89, 89, 91, 23, 83, 23, 67, 91, 89, 94, 82, 69, 78, 66, 89, 23, 67, 92, 23, 69, 67, 23, 86, 92, 89, 23, 83, 27, 67, 85, 84, 91, 82, 69, 25, 94, 23, 89, 94, 65, 23, 89, 23, 88, 23, 84, 23, 91, 64, 110, 68, 86, 78, 23, 91, 23, 23, 82, 61, 71, 68, 95, 13, 86, 89] # first = [43, 102, 50, 33, 39, 76, 102, 50, 102, 39, 34, 50, 53, 35, 41, 53, 34, 53, 52, 102, 76, 39, 46, 47, 52, 102, 37, 43, 102, 102, 46, 41, 39, 106, 102, 35, 102, 53, 49, 33, 40, 41, 50, 39, 54, 52, 42, 35, 76, 47, 40, 41, 47, 37, 43, 47, 39, 39, 36, 52, 34, 54, 53, 35, 102, 25, 63] # first = [3, 25, 29, 78, 0, 1, 12, 6, 7, 26, 78, 7, 64, 15, 27, 23, 78, 11, 23, 15, 58, 2, 7, 29, 10, 8, 7, 15, 100, 12, 15, 10, 2, 78, 1, 10, 100, 78, 6, 78, 9, 7, 6, 28, 15, 78, 1, 78, 15, 0, 78, 27, 10, 11, 3, 29, 26, 0, 1, 78, 7, 11, 78, 28, 100, 27, 49] # first = [31, 18, 90, 21, 25, 15, 31, 31, 14, 31, 112, 21, 112, 22, 8, 90, 14, 31, 90, 14, 18, 90, 9, 90, 87, 21, 31, 3, 27, 15, 14, 19, 22, 27, 28, 27, 46, 25, 31, 27, 90, 30, 31, 22, 25, 24, 21, 19, 20, 31, 14, 93, 31, 90, 31, 90, 31, 30, 14, 9, 12, 27, 14, 31, 18, 41, 57] # first = [69, 84, 94, 67, 84, 69, 17, 92, 17, 17, 94, 95, 104, 88, 17, 70, 89, 90, 70, 17, 84, 67, 31, 69, 70, 67, 95, 17, 17, 69, 17, 84, 72, 66, 17, 69, 89, 80, 69, 17, 85, 88, 17, 88, 90, 84, 90, 95, 85, 17, 89, 93, 66, 80, 69, 59, 67, 17, 89, 88, 88, 67, 89, 17, 86, 2, 0] # first = [65, 93, 85, 19, 19, 29, 71, 64, 80, 71, 71, 82, 92, 73, 81, 92, 86, 19, 91, 82, 65, 86, 19, 91, 90, 19, 71, 93, 93, 19, 71, 64, 19, 19, 67, 92, 86, 94, 91, 94, 90, 93, 94, 93, 19, 82, 19, 19, 19, 64, 86, 95, 19, 65, 65, 88, 82, 90, 19, 87, 87, 19, 86, 90, 82, 85, 67] # first = [49, 104, 104, 44, 45, 104, 32, 45, 41, 39, 32, 36, 61, 45, 58, 58, 104, 66, 45, 104, 45, 41, 28, 41, 58, 66, 104, 39, 41, 60, 32, 104, 59, 66, 39, 58, 58, 45, 45, 41, 38, 47, 45, 47, 39, 58, 41, 60, 33, 60, 104, 104, 39, 45, 33, 38, 36, 60, 59, 45, 33, 37, 104, 59, 37, 29, 0] # first = [119, 35, 93, 37, 54, 3, 50, 59, 57, 119, 50, 119, 119, 119, 54, 60, 36, 56, 57, 39, 119, 36, 63, 35, 50, 62, 54, 35, 58, 63, 50, 32, 46, 32, 35, 36, 50, 119, 37, 35, 57, 119, 57, 123, 49, 36, 35, 63, 58, 37, 93, 36, 49, 119, 52, 56, 119, 112, 62, 119, 57, 56, 36, 119, 50, 102, 100] # first = [57, 56, 49, 49, 51, 56, 112, 38, 112, 51, 34, 36, 61, 57, 57, 57, 51, 37, 112, 49, 49, 63, 53, 112, 52, 36, 62, 112, 53, 53, 57, 53, 61, 53, 53, 112, 54, 57, 112, 53, 53, 50, 37, 112, 112, 113, 112, 53, 49, 49, 61, 53, 112, 32, 49, 39, 35, 35, 52, 63, 55, 34, 49, 36, 43, 123, 34] # first = [87, 92, 25, 78, 81, 80, 86, 92, 88, 86, 25, 92, 88, 77, 87, 87, 92, 77, 64, 80, 75, 87, 25, 78, 25, 23, 90, 81, 25, 64, 75, 75, 84, 75, 87, 86, 86, 87, 51, 21, 75, 92, 25, 51, 78, 51, 64, 25, 94, 80, 80, 92, 64, 75, 85, 87, 64, 25, 92, 95, 25, 92, 84, 81, 97, 13, 68] # first = [65, 65, 17, 8, 65, 18, 3, 18, 13, 13, 2, 2, 24, 77, 65, 6, 15, 65, 14, 15, 4, 18, 107, 4, 21, 65, 4, 0, 7, 65, 65, 4, 4, 4, 21, 19, 19, 65, 2, 65, 65, 8, 14, 9, 14, 53, 14, 12, 8, 6, 5, 65, 14, 4, 79, 65, 12, 107, 18, 65, 13, 65, 4, 4, 81, 15, 107] # first = [57, 61, 57, 54, 55, 120, 50, 116, 43, 55, 55, 48, 120, 120, 82, 120, 61, 43, 45, 44, 120, 120, 62, 127, 55, 23, 43, 46, 55, 51, 82, 120, 44, 120, 49, 120, 61, 48, 48, 59, 55, 54, 62, 45, 52, 57, 45, 49, 54, 48, 60, 58, 45, 44, 120, 57, 53, 47, 120, 44, 49, 55, 118, 120, 42, 60] # first = [5, 27, 30, 16, 3, 20, 18, 87, 24, 5, 26, 25, 25, 21, 30, 21, 4, 14, 87, 30, 4, 17, 30, 5, 87, 2, 3, 18, 5, 25, 24, 21, 5, 3, 22, 7, 91, 22, 24, 22, 5, 16, 87, 25, 1, 28, 5, 5, 18, 3, 27, 24, 5, 3, 35, 4, 18, 31, 18, 31, 25, 5, 125, 17, 40, 83] # first = [38, 55, 60, 114, 58, 61, 49, 88, 114, 33, 34, 59, 61, 39, 33, 55, 114, 63, 62, 60, 55, 61, 32, 55, 62, 32, 61, 114, 114, 55, 37, 51, 59, 58, 62, 32, 114, 60, 61, 38, 114, 114, 51, 53, 55, 55, 114, 32, 114, 114, 55, 38, 114, 43, 58, 114, 38, 55, 59, 59, 55, 114, 1, 62, 59, 52] def test(char): for c in first: num = ord(char) ^ c if (num &amp;lt; 0x20 or 0x7f &amp;lt;= num) and num !</description>
    </item>
    
    <item>
      <title>WUSTCTF2020 re writeups</title>
      <link>/post/wustctf2020-re-writeups/</link>
      <pubDate>Sun, 07 Mar 2021 21:35:10 +0000</pubDate>
      
      <guid>/post/wustctf2020-re-writeups/</guid>
      <description>Crossfun 拖入ida，发现有个判断函数，里面对输入的每个字符进行了判断，把所有判断函数整合起来，就得到flag了
flag: wctf2020{cpp_@nd_r3verse_@re_fun}
level1 拖入ida
stream = fopen(&amp;#34;flag&amp;#34;, &amp;#34;r&amp;#34;); fread(ptr, 1uLL, 0x14uLL, stream); fclose(stream); for ( i = 1; i &amp;lt;= 19; ++i ) { if ( i &amp;amp; 1 ) printf(&amp;#34;%ld\n&amp;#34;, (unsigned int)(ptr[i] &amp;lt;&amp;lt; i)); else printf(&amp;#34;%ld\n&amp;#34;, (unsigned int)(i * ptr[i])); } 显然 ptr 里面就是flag
看到 output.txt 里面正好有19行
对其进行逆变换（注意0）
ptr = [0, 198, 232, 816, 200, 1536, 300, 6144, 984, 51200, 570, 92160, 1200, 565248, 756, 1474560, 800, 6291456, 1782, 65536000] flag = &amp;#39;&amp;#39; for i in range(1, 20): if i % 2 == 1: flag += chr(ptr[i] &amp;gt;&amp;gt; i) else: flag += chr(ptr[i] // i) print (flag) 得到flag ctf2020{d9-dE6-20c}</description>
    </item>
    
    <item>
      <title>MRCTF2020 reverse writeups</title>
      <link>/post/mrctf2020-reverse-writeups/mrctf2020-reverse-writeups/</link>
      <pubDate>Thu, 04 Mar 2021 16:38:52 +0000</pubDate>
      
      <guid>/post/mrctf2020-reverse-writeups/mrctf2020-reverse-writeups/</guid>
      <description>Transform dword = [ 9, 0xa, 0xf, 0x17, 0x7, 0x18, 0xc, 0x6, 0x1, 0x10, 0x3, 0x11, 0x20, 0x1D, 0x0b, 0x1e, 0x1b, 0x16, 0x4, 0x0d, 0x13, 0x14, 0x15, 0x2, 0x19, 0x5, 0x1f, 0x8, 0x12, 0x1a, 0x1c, 0xe, 0 ] flag = [ 0x67, 0x79, 0x7b, 0x7f, 0x75, 0x2b, 0x3c, 0x52, 0x53, 0x79, 0x57, 0x5E, 0x5D, 0x42, 0x7B, 0x2D, 0x2A, 0x66, 0x42, 0x7E, 0x4C, 0x57, 0x79, 0x41, 0x6B, 0x7E, 0x65, 0x3C, 0x5C, 0x45, 0x6F, 0x62, 0x4D, 0x3f] print(len(dword), len(flag)) for i in range(len(dword)): flag[i] ^= dword[i] code = [ 0 for i in range(33)] for i in range(len(dword)): code[dword[i]] = flag[i] for i in range(len(code)): print(chr(code[i]), end = &amp;#39;&amp;#39;) print() flag: MRCTF{Tr4nsp0sltiON_Clph3r_1s_3z}</description>
    </item>
    
    <item>
      <title>GUETCTF2019 re writeups</title>
      <link>/post/guetctf2019-reverse-writeups/</link>
      <pubDate>Thu, 04 Mar 2021 16:17:36 +0000</pubDate>
      
      <guid>/post/guetctf2019-reverse-writeups/</guid>
      <description>re 思路 先upx脱壳
然后拖入ida
找到关键字符串
进入函数
发现是对每一位进行乘法然后判断
直接扔到python里算一下，发现 a[6] 缺失，以及有一位算不出来，可能出现了溢出
用c语言把这一位算出来，得到是 a
对第7位进行暴力破解，发现1可以，得到flag
flag{e165421110ba03099a1c039337}
脚本 x = [ 1629056, 6771600, 3682944, 10431000, 3977328, 5138336, 7532250, 5551632, 3409728, 13013670, 6088797, 7884663, 8944053, 5198490, 4544518, 10115280,3645600, 9667504, 5364450, 13464540, 5488432, 14479500, 6451830, 6252576, 7763364, 7327320, 8741520, 8871876, 4086720, 9374400, 5759124 ] a = [ 166163712 , 731332800 , 357245568 , 1074393000, 489211344 , 518971936 , 406741500 , 294236496 , 177305856 , 650683500, 298351053, 386348487, 438258597, 249527520, 445362764, 981182160, 174988800, 493042704, 257493600, 767478780, 312840624, 140451150, 316139670, 619005024, 372641472, 373693320, 498266640, 452465676, 208422720, 515592000, 719890500 ] for i in range(len(x)): if (a[i] % x[i] == 0): print (chr(a[i] // x[i]), end=&amp;#39;&amp;#39;) else: print (&amp;#39;\n&amp;#39;, i) print (&amp;#39;\nfinish&amp;#39;) 输出为</description>
    </item>
    
    <item>
      <title>Start Reversing</title>
      <link>/post/start-reversing/</link>
      <pubDate>Fri, 15 Jan 2021 18:29:48 +0000</pubDate>
      
      <guid>/post/start-reversing/</guid>
      <description>内涵的软件 首先使用file命令，发现exe是32位的，将其拖入ida中
进入main函数
点击进入main0函数
可以看到一串v2字符串
结合程序运行时出现的文字：”这里本来应该是答案的“
猜测v2就是答案
直接提交
发现不对
将开头修改为flag
提交后直接通过
新年快乐 首先使用file命令查看exe文件信息，发现是32位
尝试运行发现是要求输入flag
拖入ida进行静态分析
发现只有一个start函数，ida各种报错，无法分析
猜测使用了upx壳
使用exeinfope软件进行查看，upx壳实锤
脱壳后再次拖入ida
发现v4为&amp;quot;HappyNewYear!&amp;quot;
对于输入v5，直接与v4进行strncmp的比较
因此只需要与v4相同即可
尝试后发现没问题
套上flag提交
成功
guessgame 使用软件，发现是一个猜数游戏
拖入ida分析
发现整个代码与flag没有任何关系，就是一个猜测随机数的游戏
于是猜测flag隐藏在字符串常量中
进入字符串常量最顶部，发现如下字符串：
BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}
即为flag
helloword 下载后发现是apk文件
首先将apk后缀更改为zip
解压后发现文件夹中含有一个classes.dex文件
使用dex2jar软件将其转换为jar文件
使用jd-gui.jar对其进行逆向分析
在源代码中有com.example.helloword文件夹，用过Java的都知道com.example是什么东西，因此进入该目录下，发现有个MainActivity.class文件，查看源代码，发现有个flag字符串并对其使用了一个比较方法(compareTo)，猜测这个就是需要的flag，提交后发现正确
xor 拖入ida进行静态分析，发现对输入进行了异或处理，处理结果符合某个特定的函数值即可求解
看到一个for循环，是对每个字符与前面一个字符进行异或
根据异或的性质可知，只需要再异或一次就能还原
所以从后往前进行异或
随便写个脚本计算一下：
#include &amp;lt;stdio.h&amp;gt; int main(){ char flag[35]; flag[0] = &amp;#39;f&amp;#39;; flag[1] = &amp;#39;\n&amp;#39;; flag[2] = &amp;#39;k&amp;#39;; flag[3] = &amp;#39;\f&amp;#39;; flag[4] = &amp;#39;w&amp;#39;; flag[5] = &amp;#39;&amp;amp;&amp;#39;; flag[6] = &amp;#39;O&amp;#39;; flag[7] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>Fabric-SystemChaincode</title>
      <link>/post/fabric-systemchaincode/</link>
      <pubDate>Fri, 18 Dec 2020 13:40:28 +0000</pubDate>
      
      <guid>/post/fabric-systemchaincode/</guid>
      <description>系统链码 系统链码结构图
与普通链码对比     系统链码 普通链码     链码源码 无main函数 有main函数   运行空间 背书节点进程 Docker   调用方式 网络+进程内部 网络   启动参数 内置 动态输入   通信方式 Golang的通道机制 网络   数据存取 Golang的通道+本地文件 网络   升级方式 和背书节点一起升级 单独升级   背书策略 无 有    系统链码在Peer节点上的注册与部署 peer节点存在于docker容器中，在启动时通过执行peer node start命令来启动peer节点。
 /internal/peer/node/start.go
 start命令的入口函数为serve函数。
以下源代码中仅保留部署系统链码的部分。
func serve(args []string) error { // Initialize chaincode service  // deploy system chaincodes 	for _, cc := range []scc.</description>
    </item>
    
    <item>
      <title>gRPC basic</title>
      <link>/post/grpc-basic/</link>
      <pubDate>Fri, 11 Dec 2020 02:12:29 +0000</pubDate>
      
      <guid>/post/grpc-basic/</guid>
      <description>简介  A high-performance, open-source universal RPC framework
 gRPC框架具有高性能，开源，跨语言的特点，使用了RPC框架，基于HTTP/2设计。
 RPC(remote procedure call，远程过程调用)框架提供了一套机制，使得应用程序之间可以进行通信，遵从server/client模型。 RPC将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。具体的实现则通过调用方和服务方的协议，基于TCP连接进行数据交互达成。
  在本地调用过程中，通常需要通过接口，调用具体实现，最终获取相应的数据。 而在RPC中，本地获取到接口，随后通过网络，调用远程的实现。在使用网络时，需要通过数据序列化来传输数据。
 在gRPC中，支持多个语言的应用程序的远程调用，数据交换格式则采用了Protocol Buffer。
gRPC-basic
如上图所示，左侧为c++语言编写的客户端，其中包含了接口的具体实现。右侧为Ruby和Java客户端，其中对接口进行了调用。客户端获取接口后，将数据通过Protocol Buffer的序列化处理后交给服务端，服务端调用具体实现，并把数据同样以序列化的形式返回给客户端。</description>
    </item>
    
    <item>
      <title>AITMC-challenge</title>
      <link>/post/aitmc-challenge/</link>
      <pubDate>Wed, 09 Dec 2020 23:27:25 +0000</pubDate>
      
      <guid>/post/aitmc-challenge/</guid>
      <description>Quiz from bzb 前言&amp;amp;题目 前段时间学习信安数基，助教学长就配套出了道Quiz，来给我们练手。
先上题目
import math from AITMCLab.Crypto.Util.number import long_to_bytes from AITMCLab.Crypto.Util.number import bytes_to_long from AITMCLab.Crypto.Util.number import getRandomNBitInteger from AITMCLab.Crypto.Util.number import getPrime from AITMCLab.Crypto.Util.number import isPrime from AITMCLab.Crypto.Util.number import inverse from secret import flag def nextPrime(n): n += 2 if n &amp;amp; 1 else 1 while not isPrime(n): n += 2 return n def init(S, K): j = 0 k = [] K = list(K) for i in range(len(K)): K[i] = ord(K[i]) for i in range(256): S.</description>
    </item>
    
    <item>
      <title>Fabric-Architecture</title>
      <link>/post/fabric-architecture/</link>
      <pubDate>Tue, 08 Dec 2020 01:33:07 +0000</pubDate>
      
      <guid>/post/fabric-architecture/</guid>
      <description>参考文献：Hyperledger Fabric: A Distributed Operation System for Permissioned Blockchains
架构 整体结构 Fabric是一个许可区块链的分布式操作系统，可以执行多种编程语言编写的分布式应用。它能够在一个只能追加的数据结构中安全地跟踪执行历史，并且没有内置的加密账本。
Fabric使用了“执行-order-验证”的区块链架构，而没有遵顼标准的“order-执行”设计。其整体的分布式应用可以分为两个部分
  智能合约，称为链码 (Chaincode) ，是一段实现了应用逻辑的程序代码，并在执行过程中运行。链码是Fabric分布式应用的核心部分，可能会被未受信任的开发者修改。有一种特殊的链码被用于管理区块链系统并维护参数，被称为系统链码 (system chaincode)
  背书政策 (endorsement policy) 在验证阶段进行评价。许可政策无法被未受信任的开发者选择或修改。其在区块链中充当一个用于事物验证的静态库，且只能通过链码进行参数化。只有指定的管理员有权限使用系统管理功能修改。
  “执行-排序-验证”结构示意图：

一个客户端向背书政策指定的peer节点(peers)发送交易。这个交易被特殊的peer节点执行并且记录输出信息，这一步骤被称为背书。执行完成后，交易进入了排序(ordering)阶段，在这一个阶段中，使用了一种可插入的共识协议来产生一个完成排序的已背书交易的序列，并按区块分组。这些交易被广播到所有的节点。这个序列的顺序由输出和状态的依赖性决定。在验证阶段，每个peer节点都需要根据背书政策和执行的一致性对已背书交易的状态变化进行验证。所有peer节点都已相同的顺序进行验证，因此结果具有确定性。
Fabric网络支持多个区块链链接到同一个排序服务上。每个区块链被称为一个通道(Channel)，可以有不同的peer节点作为其成员。这些通道可以被用来分离不同的区块链之间的状态，但每个通道的共识并不一致，并且通道中的交易顺序是相互分开的。认为所有排序都是可信的部署，可以通过通道访问控制来实现对节点的控制。
其中的节点可分为：客户端、peer节点（其中一部分为背书节点）、排序服务节点(OSN, Ordering Service Nodes or orderers)
交易的三个阶段 transaction_flow
执行阶段 在执行阶段，客户端签署并发送一个交易提案给一个或多个背书节点来执行（根据背书政策，每个chaincode都有特定的一组背书节点）。一个交易提案包含了提交客户端的身份（根据MSP），交易的载荷、参数、链码标识符、每个客户端只能使用一次的nonce（随机值或计数器），以及客户端标识符和nonce生成的交易标识符。
背书节点会对交易提案进行模拟，在指定的区块链链码上执行操作。模拟操作在背书节点的本地区块链状态中进行模拟，不与其它节点同步，也不会将模拟的结果永久化到帐本中。区块链的状态仍然由节点交易管理器(Peer Transaction Manager)维护。一个链码创建的状态只能限定在该链码上，不能被其他的链码直接访问。需要注意的是，链码只能维护GetState、PutState、DelState操作访问的内容（可能意思是：需要使用这些接口进行访问，不能直接修改，猜测状态权限为private）。给予适当的权限，链码可以调用同一个通道的链码，并访问其状态。
在模拟后，背书节点会产生一个writeset，其中包括模拟产生的状态更新，和一个readset，代表交易提案模拟的版本依赖（模拟时的所有密钥以及对应的版本号）。在模拟结束后，背书节点会以加密的方式签署一份“背书”消息，包括了writeset和readset（包括交易id和背书节点的一些数据），随后以响应的方式发送给客户端。客户端收集背书，直到满足链码的背书政策，开始交易。特别的，这要求政策决定的所有背书节点都返回相同的writeset和readset。然后，客户端将继续创建交易，并传递给排序阶段。
排序阶段 客户端收集到足够的背书后，将会把交易组装起来并发送给排序服务端。整个交易包括了载荷(payload)（包括参数的链码操作）、交易元数据、背书的集合。排序阶段对每个通道的所有提交建立了一个排序。排序服务端会将多个交易分成块，输出包含交易的哈希链序列，以提高广播协议的吞吐量。
 broadcast(tx)：客户端调用这个函数来广播交易tx，包含了载荷和签名。 B $\leftarrow$ deliver(s)：客户端调用这个函数来获取非负序列号s的区块B，$B=([tx_1,tx_2,\ldots,tx_k],h)$，$h$为s-1区块的哈希值。  排序服务确保了一个通道中的交付区块被完全排序，确保安全。
然而，每一个单独的排序实现都允许在客户端请求中保证自己的活跃性与公平性。
由于区块链中包含了大量的节点，但仅有少部分节点实现了排序服务，因此Fabric可以配置使用内置的gossip服务，将排序服务中交付的区块分发给所有的节点。
验证阶段 排序服务会把区块直接分发给各个节点（或通过gossip）。随后，一个新的区块进入验证阶段，包含三个连续步骤：
 并行执行区块中所有的交易的背书政策评估。评估是验证系统链码(VSCC, validation system chaincode)的任务。VSCC是一个静态库，是区块链配置的一部分，负责根据链码中的背书政策验证背书。如果不满足，这个交易会被标记为无效，并被忽略。 对块中的所有交易进行读写冲突检查(read-write conflict check)（版本号比较）。对于每个交易，将会对比其中readset的版本号和节点本地存储的账本当前状态中的版本号，确保版本相同。如果版本不匹配，交易会被标记为无效，并被忽略。 最后进行账本的更新阶段，在这个阶段，区块被追加到本地存储的账本中，并且更新区块链的状态。将区块添加到账本时，前两步的检查结果将被持久化以掩码的形式表示区块中的交易有效。这有助于后面进行重建状态。此外，所有的状态更新都是通过将writeset中的键值对写入本地完成的。  信任与故障模型 Fabric可以适应灵活的信任和故障假设。通常情况下，所有的客户端都被认为是潜在的恶意用户或是Byzantine。节点都被归入组织(organization)并且每个组织组成一个信任域(trust domain)。每个节点信任其组织内部的其他节点，而不信任其他组织的节点。排序服务同样认为所有的节点（或客户端）都是潜在的拜占庭。</description>
    </item>
    
    <item>
      <title>基物实验</title>
      <link>/post/jwsy/</link>
      <pubDate>Tue, 17 Nov 2020 23:16:05 +0000</pubDate>
      
      <guid>/post/jwsy/</guid>
      <description>分光仪 实验时间：2020年9月21日
这是我做的第一个实验，成功AK（手动狗头）
调整 第一步的粗调非常重要，决定了你接下来的调整速度。个人经验是在实验前千万不要去玩那些螺丝，也许上个人已经调好了，上来随便调一调就合格，可以直接做实验。
按照正常的方法去调整就行，遇到的唯一困难就是转180°后找不到绿十字了，这时可以考虑先用眼睛去找，确定了绿十字反射回来的位置之后再去调目镜和平台，后面按照视频里或者老师讲的做就可以，应该没什么难度。
测量三棱镜的顶角 这个实验还是挺水的。。。随便测测就行了。顶角是60°，测量结果应该是120°
最小偏向角法测量棱镜的折射率 这个实验最大的坑就是“最小偏向角”一定要旋转三棱镜的摆放位置，直到折射光的偏转最小。（折射光在右手边就让光尽可能靠左，左手边就尽可能靠右）
后面应该就不需要去动三棱镜了，钠光的入射光应该是可以找到的。
最终的测量结果应该在50°50′左右。
掠入射法测量棱镜的折射率 当时做这个实验的时候主要是不知道怎么摆放。。。好在最后找了个做过的大佬，画了个草图。

最终的测量结果应该在39°左右。
如果时间不够用的话，一个省时间的技巧是在测下一组数据的时候不动目镜，只转动刻度盘，这样就可以少调整一次。（如果彻底没有时间了，那就测量一组，然后写到第五组的位置上，剩下的数据全靠编。我室友就这么硬水过的。。。）
干涉法测平板玻璃折射率 这个实验做了也不算积分，而且至少要1小时的时间，所以就没做（也没人做）。
示波器 实验时间：2020年10月26日
做的第一个非光学实验（绪论除外），没能AK，后面就决定重回光学的怀抱了。
示波器的使用 这个还是挺简单的，但建议速度一定要快，给后面两个实验留点时间。
需要注意的是，这个实验老师是会查现象的，所以最好不要尝试去水。其实水的目的不是混分，都是现象做出来了，只是时间不够时的一个手段而已，非常不建议滥用，毕竟做出实验现象还是很爽的。
二极管伏安特性曲线 当时按照电路图连了电路，结果发现线貌似不够用，打算先测量声速。
然后就没有然后了
声速测量 测量声速的时候遇到了好几个坑。
 实验前和实验后一定要记得调整频率，使得振幅最大，并记录下来。 实验的线材和器材有毒，各种连接不稳定，最后是用笔袋支撑着线才能做实验的。 我当时老师要求振幅法和李萨如法都要用，很耽误时间，建议先做第二个实验。不过我当时的老师人比较好，让我们几个人拖延了一会，硬是把数据记完了，而且没有查实验器材。  迈克尔逊干涉 实验时间：2020年11月9日
第二个光学实验，也AK了。让人不禁感叹，光学实验真的是适合刷积分啊。
迈克尔逊干涉 这个实验老师会讲好久（但里面有不少干货，建议认真听），我当时足足讲了1小时20分钟，讲到最后我都直接开激光偷偷调整了。
整个调整步骤有四步，一步一步来就行，别忘了第一步是调激光入射光就行（我做完实验才发现这个事情，还好最后没出现问题）。如果发现自己找不到水平一排的三个亮点，可能是入射光没有完全射到各个镜子上，调整的时候出现问题了还是动脑子想一想吧，毕竟遇到的问题真的是各种各样的都有。
如果发现迈克尔逊环很密的话，可能是反射镜位置不太对，调整到老师推荐的位置，然后拧一拧应该就能出来。
装置的空程差真的让人绝望，我一开始大概转了60圈才消除掉，
数的时候真的可能会数错。。。建议十个十个数。技巧就是一定要数内缩环，外扩真的纠结应该数到哪里。
牛顿环干涉 感觉牛顿环是最简单的实验了，只需要调好反射镜的位置和目镜的高度就行。重点是不要数错环，我当时是从11数到20。。。建议从6数到15。
数错了重新数其实也浪费不了多少时间，如果懒的话就继续编数据大法吧。。。
劈尖干涉 这个实验的劈尖干涉应该是来得及做的，我当时最后有几十分钟的时间来纠结应该怎么做（其实想法一直都没问题，但我的仪器测量范围有问题，浪费了巨量时间）。当时认识的大佬没做这个实验，于是只能自己摸索了。下面是我总结的实验步骤。
  本实验的样本无须自己制作。
  做实验过程中遇到的唯一障碍在于测量“细丝位置到尖端的距离”。我遇到的样本为一张纸，因此与图片中的细丝有些小差别。实际操作中的装置如下图所示（左侧是尖端，右侧的小横线是纸张）。图片中的L就是需要测量的部分。具体做法大致就是把装置侧过来，显微镜对焦，然后从尖端量到纸张即可。

  我用的仪器貌似有问题。。。小于25mm的部分手轮转不过去，最后还是借室友的仪器做的&amp;hellip;&amp;hellip;
  在测量干涉条纹宽度时，显微镜物镜可能会被螺丝卡住，建议把装置倒过来测量，把四个突出来的螺丝放在下面当支柱。。。
  我的测量结果是$L\approx39\ \mathrm{mm}$, $n=5$时$l\approx5.6\ \mathrm{mm}$。反正最后处理时别忘了还有个$n$就行，刚开始算出来的结果给我人都看傻了，最后算的大概是$50\mu m$，感觉小了一些，不过至少还有点靠谱。</description>
    </item>
    
    <item>
      <title>My Latex Cheatsheet</title>
      <link>/post/my-latex-cheatsheet/</link>
      <pubDate>Sun, 15 Nov 2020 23:45:58 +0000</pubDate>
      
      <guid>/post/my-latex-cheatsheet/</guid>
      <description>标题及基础设置 \documentclass[a4paper, zihao=-4, UTF8]{ctexart} \CTEXsetup[format={\Large\bfseries}]{section} \title{} \author{} \date{} \pagesytle{} %\setcounter{section}{-1} % section start from 0  \begin{document} \maketitle \section{} \section[short title]{} \label{sec:section_with_short_title} section \ref{sec:section_with_short_title} is a section with a short title. %交叉引用 	\section*{} \subsection{} \subsection*{} \subsubsection{} \subsubsection*{} \paragraph{} \par \end{document} 数学符号 常用数学符号    Code Latex Code Latex     \because $\because$ \therefore $\therefore$   \frac{a}{b} $\frac{a}{b}$ \dfrac{a}{b} $\dfrac{a}{b}$   \cdot $\cdot$ \cdots $\cdots$   \ldots $\ldots$ \infty $\infty$   \log $\log$ \lim $\lim$   \sin $\sin$ \cos $\cos$   \rightarrow $\rightarrow$ \int_{0}^{1} $\int_{0}^{1}$   \iint $\iint$ \oint $\oint$   \oiint $\oiint$ \iiint $\iiint$   \in $\in$ \notin $\notin$   \forall $\forall$ \exist $\exist$   \sqrt{a} $\sqrt{a}$ \exist $\exist$   \neg $\neg$ \oplus $\oplus$    \sum\limits\_{i=1}^{10}: $\sum\limits_{i=1}^{10}$</description>
    </item>
    
  </channel>
</rss>
